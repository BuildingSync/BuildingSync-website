#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Apr 18 10:48:50 2017 by generateDS.py version 2.25a.
#
# Command line options:
#   ('-o', 'classes.py')
#   ('--use-getter-setter', 'none')
#
# Command line arguments:
#   BuildingSync_2_0.xsd
#
# Command line:
#   /usr/local/bin/generateds -o "classes.py" --use-getter-setter="none" BuildingSync_2_0.xsd
#
# Current working directory (os.getcwd()):
#   xsd_to_html
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Audits(GeneratedsSuper):
    """BuildingSync Schema Version 2.0 (September 25, 2015)"""
    subclass = None
    superclass = None
    def __init__(self, Audit=None):
        self.original_tagname_ = None
        if Audit is None:
            self.Audit = []
        else:
            self.Audit = Audit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Audits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Audits.subclass:
            return Audits.subclass(*args_, **kwargs_)
        else:
            return Audits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Audit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Audits', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Audits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Audits', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Audits'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Audits', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Audit_ in self.Audit:
            Audit_.export(outfile, level, namespace_, name_='Audit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Audit':
            obj_ = AuditType.factory()
            obj_.build(child_)
            self.Audit.append(obj_)
            obj_.original_tagname_ = 'Audit'
# end class Audits


class SiteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PremisesIdentifiers=None, PremisesName=None, PremisesNotes=None, OccupancyClassification=None, Address=None, ClimateZoneType=None, eGRIDRegionCode=None, WeatherDataStationID=None, WeatherStationName=None, WeatherStationCategory=None, Longitude=None, Latitude=None, FloorAreas=None, Ownership=None, OwnershipStatus=None, PrimaryContactID=None, CommercialFacilities=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        if PremisesIdentifiers is None:
            self.PremisesIdentifiers = []
        else:
            self.PremisesIdentifiers = PremisesIdentifiers
        self.PremisesName = PremisesName
        self.PremisesNotes = PremisesNotes
        self.OccupancyClassification = OccupancyClassification
        self.validate_OccupancyClassification(self.OccupancyClassification)
        self.Address = Address
        self.ClimateZoneType = ClimateZoneType
        self.eGRIDRegionCode = eGRIDRegionCode
        self.validate_eGRIDRegionCodeType(self.eGRIDRegionCode)
        self.WeatherDataStationID = WeatherDataStationID
        self.WeatherStationName = WeatherStationName
        self.WeatherStationCategory = WeatherStationCategory
        self.validate_WeatherStationCategoryType(self.WeatherStationCategory)
        self.Longitude = Longitude
        self.Latitude = Latitude
        self.FloorAreas = FloorAreas
        self.Ownership = Ownership
        self.validate_Ownership(self.Ownership)
        self.OwnershipStatus = OwnershipStatus
        self.validate_OwnershipStatus(self.OwnershipStatus)
        self.PrimaryContactID = PrimaryContactID
        self.CommercialFacilities = CommercialFacilities
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SiteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SiteType.subclass:
            return SiteType.subclass(*args_, **kwargs_)
        else:
            return SiteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OccupancyClassification(self, value):
        # Validate type OccupancyClassification, a restriction on xs:string.
        pass
    def validate_eGRIDRegionCodeType(self, value):
        # Validate type eGRIDRegionCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AKGD', 'AKMS', 'AZNM', 'CAMX', 'ERCT', 'FRCC', 'HIMS', 'HIOA', 'MORE', 'MROW', 'NEWE', 'NWPP', 'NYCW', 'NYLI', 'NYUP', 'RFCE', 'RFCM', 'RFCW', 'RMPA', 'SPNO', 'SPSO', 'SRMV', 'SRMW', 'SRSO', 'SRTV', 'SRVC', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on eGRIDRegionCodeType' % {"value" : value.encode("utf-8")} )
    def validate_WeatherStationCategoryType(self, value):
        # Validate type WeatherStationCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAA', 'ICAO', 'NWS', 'WBAN', 'WMO', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeatherStationCategoryType' % {"value" : value.encode("utf-8")} )
    def validate_Ownership(self, value):
        # Validate type Ownership, a restriction on xs:string.
        pass
    def validate_OwnershipStatus(self, value):
        # Validate type OwnershipStatus, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PremisesIdentifiers or
            self.PremisesName is not None or
            self.PremisesNotes is not None or
            self.OccupancyClassification is not None or
            self.Address is not None or
            self.ClimateZoneType is not None or
            self.eGRIDRegionCode is not None or
            self.WeatherDataStationID is not None or
            self.WeatherStationName is not None or
            self.WeatherStationCategory is not None or
            self.Longitude is not None or
            self.Latitude is not None or
            self.FloorAreas is not None or
            self.Ownership is not None or
            self.OwnershipStatus is not None or
            self.PrimaryContactID is not None or
            self.CommercialFacilities is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SiteType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SiteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SiteType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SiteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PremisesIdentifiers_ in self.PremisesIdentifiers:
            PremisesIdentifiers_.export(outfile, level, namespace_='auc:', name_='PremisesIdentifiers', pretty_print=pretty_print)
        if self.PremisesName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesName>%s</%sPremisesName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesName), input_name='PremisesName')), namespace_, eol_))
        if self.PremisesNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesNotes>%s</%sPremisesNotes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesNotes), input_name='PremisesNotes')), namespace_, eol_))
        if self.OccupancyClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupancyClassification>%s</%sOccupancyClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupancyClassification), input_name='OccupancyClassification')), namespace_, eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_='auc:', name_='Address', pretty_print=pretty_print)
        if self.ClimateZoneType is not None:
            self.ClimateZoneType.export(outfile, level, namespace_, name_='ClimateZoneType', pretty_print=pretty_print)
        if self.eGRIDRegionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seGRIDRegionCode>%s</%seGRIDRegionCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.eGRIDRegionCode), input_name='eGRIDRegionCode')), namespace_, eol_))
        if self.WeatherDataStationID is not None:
            self.WeatherDataStationID.export(outfile, level, namespace_, name_='WeatherDataStationID', pretty_print=pretty_print)
        if self.WeatherStationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherStationName>%s</%sWeatherStationName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WeatherStationName), input_name='WeatherStationName')), namespace_, eol_))
        if self.WeatherStationCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherStationCategory>%s</%sWeatherStationCategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WeatherStationCategory), input_name='WeatherStationCategory')), namespace_, eol_))
        if self.Longitude is not None:
            self.Longitude.export(outfile, level, namespace_, name_='Longitude', pretty_print=pretty_print)
        if self.Latitude is not None:
            self.Latitude.export(outfile, level, namespace_, name_='Latitude', pretty_print=pretty_print)
        if self.FloorAreas is not None:
            self.FloorAreas.export(outfile, level, namespace_='auc:', name_='FloorAreas', pretty_print=pretty_print)
        if self.Ownership is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwnership>%s</%sOwnership>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ownership), input_name='Ownership')), namespace_, eol_))
        if self.OwnershipStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwnershipStatus>%s</%sOwnershipStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OwnershipStatus), input_name='OwnershipStatus')), namespace_, eol_))
        if self.PrimaryContactID is not None:
            self.PrimaryContactID.export(outfile, level, namespace_='auc:', name_='PrimaryContactID', pretty_print=pretty_print)
        if self.CommercialFacilities is not None:
            self.CommercialFacilities.export(outfile, level, namespace_, name_='CommercialFacilities', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PremisesIdentifiers':
            obj_ = PremisesIdentifiers.factory()
            obj_.build(child_)
            self.PremisesIdentifiers.append(obj_)
            obj_.original_tagname_ = 'PremisesIdentifiers'
        elif nodeName_ == 'PremisesName':
            PremisesName_ = child_.text
            PremisesName_ = self.gds_validate_string(PremisesName_, node, 'PremisesName')
            self.PremisesName = PremisesName_
        elif nodeName_ == 'PremisesNotes':
            PremisesNotes_ = child_.text
            PremisesNotes_ = self.gds_validate_string(PremisesNotes_, node, 'PremisesNotes')
            self.PremisesNotes = PremisesNotes_
        elif nodeName_ == 'OccupancyClassification':
            OccupancyClassification_ = child_.text
            OccupancyClassification_ = self.gds_validate_string(OccupancyClassification_, node, 'OccupancyClassification')
            self.OccupancyClassification = OccupancyClassification_
            # validate type OccupancyClassification
            self.validate_OccupancyClassification(self.OccupancyClassification)
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'ClimateZoneType':
            obj_ = ClimateZoneTypeType.factory()
            obj_.build(child_)
            self.ClimateZoneType = obj_
            obj_.original_tagname_ = 'ClimateZoneType'
        elif nodeName_ == 'eGRIDRegionCode':
            eGRIDRegionCode_ = child_.text
            eGRIDRegionCode_ = self.gds_validate_string(eGRIDRegionCode_, node, 'eGRIDRegionCode')
            self.eGRIDRegionCode = eGRIDRegionCode_
            # validate type eGRIDRegionCodeType
            self.validate_eGRIDRegionCodeType(self.eGRIDRegionCode)
        elif nodeName_ == 'WeatherDataStationID':
            obj_ = WeatherDataStationIDType.factory()
            obj_.build(child_)
            self.WeatherDataStationID = obj_
            obj_.original_tagname_ = 'WeatherDataStationID'
        elif nodeName_ == 'WeatherStationName':
            WeatherStationName_ = child_.text
            WeatherStationName_ = self.gds_validate_string(WeatherStationName_, node, 'WeatherStationName')
            self.WeatherStationName = WeatherStationName_
        elif nodeName_ == 'WeatherStationCategory':
            WeatherStationCategory_ = child_.text
            WeatherStationCategory_ = self.gds_validate_string(WeatherStationCategory_, node, 'WeatherStationCategory')
            self.WeatherStationCategory = WeatherStationCategory_
            # validate type WeatherStationCategoryType
            self.validate_WeatherStationCategoryType(self.WeatherStationCategory)
        elif nodeName_ == 'Longitude':
            obj_ = LongitudeType.factory()
            obj_.build(child_)
            self.Longitude = obj_
            obj_.original_tagname_ = 'Longitude'
        elif nodeName_ == 'Latitude':
            obj_ = LatitudeType.factory()
            obj_.build(child_)
            self.Latitude = obj_
            obj_.original_tagname_ = 'Latitude'
        elif nodeName_ == 'FloorAreas':
            obj_ = FloorAreas.factory()
            obj_.build(child_)
            self.FloorAreas = obj_
            obj_.original_tagname_ = 'FloorAreas'
        elif nodeName_ == 'Ownership':
            Ownership_ = child_.text
            Ownership_ = self.gds_validate_string(Ownership_, node, 'Ownership')
            self.Ownership = Ownership_
            # validate type Ownership
            self.validate_Ownership(self.Ownership)
        elif nodeName_ == 'OwnershipStatus':
            OwnershipStatus_ = child_.text
            OwnershipStatus_ = self.gds_validate_string(OwnershipStatus_, node, 'OwnershipStatus')
            self.OwnershipStatus = OwnershipStatus_
            # validate type OwnershipStatus
            self.validate_OwnershipStatus(self.OwnershipStatus)
        elif nodeName_ == 'PrimaryContactID':
            obj_ = PrimaryContactID.factory()
            obj_.build(child_)
            self.PrimaryContactID = obj_
            obj_.original_tagname_ = 'PrimaryContactID'
        elif nodeName_ == 'CommercialFacilities':
            obj_ = CommercialFacilitiesType.factory()
            obj_.build(child_)
            self.CommercialFacilities = obj_
            obj_.original_tagname_ = 'CommercialFacilities'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class SiteType


class CommercialFacilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PremisesName=None, PremisesNotes=None, PremisesIdentifiers=None, OccupancyClassification=None, OccupancyLevels=None, SpatialUnits=None, Ownership=None, OwnershipStatus=None, PrimaryContactID=None, NAICSCode=None, PubliclySubsidized=None, FederalBuilding=None, PortfolioManager=None, NumberOfBusinesses=None, FloorAreas=None, AspectRatio=None, Perimeter=None, HeightDistribution=None, HorizontalSurroundings=None, VerticalSurroundings=None, Assessment=None, YearOfConstruction=None, YearOccupied=None, YearOfLastEnergyAudit=None, RetrocommissioningDate=None, YearOfLatestRetrofit=None, YearOfLastMajorRemodel=None, PercentOccupiedByOwner=None, OperatorType=None, Subsections=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.PremisesName = PremisesName
        self.PremisesNotes = PremisesNotes
        if PremisesIdentifiers is None:
            self.PremisesIdentifiers = []
        else:
            self.PremisesIdentifiers = PremisesIdentifiers
        self.OccupancyClassification = OccupancyClassification
        self.validate_OccupancyClassification(self.OccupancyClassification)
        self.OccupancyLevels = OccupancyLevels
        if SpatialUnits is None:
            self.SpatialUnits = []
        else:
            self.SpatialUnits = SpatialUnits
        self.Ownership = Ownership
        self.validate_Ownership(self.Ownership)
        self.OwnershipStatus = OwnershipStatus
        self.validate_OwnershipStatus(self.OwnershipStatus)
        self.PrimaryContactID = PrimaryContactID
        self.NAICSCode = NAICSCode
        self.PubliclySubsidized = PubliclySubsidized
        self.FederalBuilding = FederalBuilding
        self.PortfolioManager = PortfolioManager
        self.NumberOfBusinesses = NumberOfBusinesses
        self.FloorAreas = FloorAreas
        self.AspectRatio = AspectRatio
        self.Perimeter = Perimeter
        self.HeightDistribution = HeightDistribution
        self.validate_HeightDistributionType(self.HeightDistribution)
        self.HorizontalSurroundings = HorizontalSurroundings
        self.validate_HorizontalSurroundingsType(self.HorizontalSurroundings)
        self.VerticalSurroundings = VerticalSurroundings
        self.validate_VerticalSurroundingsType(self.VerticalSurroundings)
        if Assessment is None:
            self.Assessment = []
        else:
            self.Assessment = Assessment
        self.YearOfConstruction = YearOfConstruction
        self.YearOccupied = YearOccupied
        self.YearOfLastEnergyAudit = YearOfLastEnergyAudit
        if isinstance(RetrocommissioningDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RetrocommissioningDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RetrocommissioningDate
        self.RetrocommissioningDate = initvalue_
        self.YearOfLatestRetrofit = YearOfLatestRetrofit
        self.YearOfLastMajorRemodel = YearOfLastMajorRemodel
        self.PercentOccupiedByOwner = PercentOccupiedByOwner
        self.OperatorType = OperatorType
        self.validate_OperatorTypeType(self.OperatorType)
        self.Subsections = Subsections
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommercialFacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommercialFacilityType.subclass:
            return CommercialFacilityType.subclass(*args_, **kwargs_)
        else:
            return CommercialFacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OccupancyClassification(self, value):
        # Validate type OccupancyClassification, a restriction on xs:string.
        pass
    def validate_Ownership(self, value):
        # Validate type Ownership, a restriction on xs:string.
        pass
    def validate_OwnershipStatus(self, value):
        # Validate type OwnershipStatus, a restriction on xs:string.
        pass
    def validate_HeightDistributionType(self, value):
        # Validate type HeightDistributionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Multiple Heights', 'Uniform Height']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeightDistributionType' % {"value" : value.encode("utf-8")} )
    def validate_HorizontalSurroundingsType(self, value):
        # Validate type HorizontalSurroundingsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['No abutments', 'Attached from Above', 'Attached from Below', 'Attached from Above and Below', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HorizontalSurroundingsType' % {"value" : value.encode("utf-8")} )
    def validate_VerticalSurroundingsType(self, value):
        # Validate type VerticalSurroundingsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Stand-alone', 'Attached on one side', 'Attached on two sides', 'Attached on three sides', 'Within a building', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VerticalSurroundingsType' % {"value" : value.encode("utf-8")} )
    def validate_OperatorTypeType(self, value):
        # Validate type OperatorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Owner', 'Occupant', 'Property management company', 'Other corporation/partnership/LLC', 'Religious organization', 'Other non-profit organization', 'Privately-owned school', 'Individual owner', 'Other nongovernment owner', 'Government', 'Federal government', 'State government', 'Local government', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OperatorTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PremisesName is not None or
            self.PremisesNotes is not None or
            self.PremisesIdentifiers or
            self.OccupancyClassification is not None or
            self.OccupancyLevels is not None or
            self.SpatialUnits or
            self.Ownership is not None or
            self.OwnershipStatus is not None or
            self.PrimaryContactID is not None or
            self.NAICSCode is not None or
            self.PubliclySubsidized is not None or
            self.FederalBuilding is not None or
            self.PortfolioManager is not None or
            self.NumberOfBusinesses is not None or
            self.FloorAreas is not None or
            self.AspectRatio is not None or
            self.Perimeter is not None or
            self.HeightDistribution is not None or
            self.HorizontalSurroundings is not None or
            self.VerticalSurroundings is not None or
            self.Assessment or
            self.YearOfConstruction is not None or
            self.YearOccupied is not None or
            self.YearOfLastEnergyAudit is not None or
            self.RetrocommissioningDate is not None or
            self.YearOfLatestRetrofit is not None or
            self.YearOfLastMajorRemodel is not None or
            self.PercentOccupiedByOwner is not None or
            self.OperatorType is not None or
            self.Subsections is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CommercialFacilityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommercialFacilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CommercialFacilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CommercialFacilityType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CommercialFacilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PremisesName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesName>%s</%sPremisesName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesName), input_name='PremisesName')), namespace_, eol_))
        if self.PremisesNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesNotes>%s</%sPremisesNotes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesNotes), input_name='PremisesNotes')), namespace_, eol_))
        for PremisesIdentifiers_ in self.PremisesIdentifiers:
            PremisesIdentifiers_.export(outfile, level, namespace_='auc:', name_='PremisesIdentifiers', pretty_print=pretty_print)
        if self.OccupancyClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupancyClassification>%s</%sOccupancyClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupancyClassification), input_name='OccupancyClassification')), namespace_, eol_))
        if self.OccupancyLevels is not None:
            self.OccupancyLevels.export(outfile, level, namespace_='auc:', name_='OccupancyLevels', pretty_print=pretty_print)
        for SpatialUnits_ in self.SpatialUnits:
            SpatialUnits_.export(outfile, level, namespace_, name_='SpatialUnits', pretty_print=pretty_print)
        if self.Ownership is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwnership>%s</%sOwnership>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Ownership), input_name='Ownership')), namespace_, eol_))
        if self.OwnershipStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwnershipStatus>%s</%sOwnershipStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OwnershipStatus), input_name='OwnershipStatus')), namespace_, eol_))
        if self.PrimaryContactID is not None:
            self.PrimaryContactID.export(outfile, level, namespace_='auc:', name_='PrimaryContactID', pretty_print=pretty_print)
        if self.NAICSCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAICSCode>%s</%sNAICSCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NAICSCode), input_name='NAICSCode')), namespace_, eol_))
        if self.PubliclySubsidized is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPubliclySubsidized>%s</%sPubliclySubsidized>%s' % (namespace_, self.gds_format_boolean(self.PubliclySubsidized, input_name='PubliclySubsidized'), namespace_, eol_))
        if self.FederalBuilding is not None:
            self.FederalBuilding.export(outfile, level, namespace_, name_='FederalBuilding', pretty_print=pretty_print)
        if self.PortfolioManager is not None:
            self.PortfolioManager.export(outfile, level, namespace_, name_='PortfolioManager', pretty_print=pretty_print)
        if self.NumberOfBusinesses is not None:
            self.NumberOfBusinesses.export(outfile, level, namespace_, name_='NumberOfBusinesses', pretty_print=pretty_print)
        if self.FloorAreas is not None:
            self.FloorAreas.export(outfile, level, namespace_='auc:', name_='FloorAreas', pretty_print=pretty_print)
        if self.AspectRatio is not None:
            self.AspectRatio.export(outfile, level, namespace_, name_='AspectRatio', pretty_print=pretty_print)
        if self.Perimeter is not None:
            self.Perimeter.export(outfile, level, namespace_, name_='Perimeter', pretty_print=pretty_print)
        if self.HeightDistribution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeightDistribution>%s</%sHeightDistribution>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeightDistribution), input_name='HeightDistribution')), namespace_, eol_))
        if self.HorizontalSurroundings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHorizontalSurroundings>%s</%sHorizontalSurroundings>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HorizontalSurroundings), input_name='HorizontalSurroundings')), namespace_, eol_))
        if self.VerticalSurroundings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerticalSurroundings>%s</%sVerticalSurroundings>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VerticalSurroundings), input_name='VerticalSurroundings')), namespace_, eol_))
        for Assessment_ in self.Assessment:
            Assessment_.export(outfile, level, namespace_, name_='Assessment', pretty_print=pretty_print)
        if self.YearOfConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOfConstruction>%s</%sYearOfConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOfConstruction), input_name='YearOfConstruction')), namespace_, eol_))
        if self.YearOccupied is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOccupied>%s</%sYearOccupied>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOccupied), input_name='YearOccupied')), namespace_, eol_))
        if self.YearOfLastEnergyAudit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOfLastEnergyAudit>%s</%sYearOfLastEnergyAudit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOfLastEnergyAudit), input_name='YearOfLastEnergyAudit')), namespace_, eol_))
        if self.RetrocommissioningDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRetrocommissioningDate>%s</%sRetrocommissioningDate>%s' % (namespace_, self.gds_format_date(self.RetrocommissioningDate, input_name='RetrocommissioningDate'), namespace_, eol_))
        if self.YearOfLatestRetrofit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOfLatestRetrofit>%s</%sYearOfLatestRetrofit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOfLatestRetrofit), input_name='YearOfLatestRetrofit')), namespace_, eol_))
        if self.YearOfLastMajorRemodel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOfLastMajorRemodel>%s</%sYearOfLastMajorRemodel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOfLastMajorRemodel), input_name='YearOfLastMajorRemodel')), namespace_, eol_))
        if self.PercentOccupiedByOwner is not None:
            self.PercentOccupiedByOwner.export(outfile, level, namespace_, name_='PercentOccupiedByOwner', pretty_print=pretty_print)
        if self.OperatorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperatorType>%s</%sOperatorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OperatorType), input_name='OperatorType')), namespace_, eol_))
        if self.Subsections is not None:
            self.Subsections.export(outfile, level, namespace_, name_='Subsections', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PremisesName':
            PremisesName_ = child_.text
            PremisesName_ = self.gds_validate_string(PremisesName_, node, 'PremisesName')
            self.PremisesName = PremisesName_
        elif nodeName_ == 'PremisesNotes':
            PremisesNotes_ = child_.text
            PremisesNotes_ = self.gds_validate_string(PremisesNotes_, node, 'PremisesNotes')
            self.PremisesNotes = PremisesNotes_
        elif nodeName_ == 'PremisesIdentifiers':
            obj_ = PremisesIdentifiers.factory()
            obj_.build(child_)
            self.PremisesIdentifiers.append(obj_)
            obj_.original_tagname_ = 'PremisesIdentifiers'
        elif nodeName_ == 'OccupancyClassification':
            OccupancyClassification_ = child_.text
            OccupancyClassification_ = self.gds_validate_string(OccupancyClassification_, node, 'OccupancyClassification')
            self.OccupancyClassification = OccupancyClassification_
            # validate type OccupancyClassification
            self.validate_OccupancyClassification(self.OccupancyClassification)
        elif nodeName_ == 'OccupancyLevels':
            obj_ = OccupancyLevels.factory()
            obj_.build(child_)
            self.OccupancyLevels = obj_
            obj_.original_tagname_ = 'OccupancyLevels'
        elif nodeName_ == 'SpatialUnits':
            obj_ = SpatialUnitsType.factory()
            obj_.build(child_)
            self.SpatialUnits.append(obj_)
            obj_.original_tagname_ = 'SpatialUnits'
        elif nodeName_ == 'Ownership':
            Ownership_ = child_.text
            Ownership_ = self.gds_validate_string(Ownership_, node, 'Ownership')
            self.Ownership = Ownership_
            # validate type Ownership
            self.validate_Ownership(self.Ownership)
        elif nodeName_ == 'OwnershipStatus':
            OwnershipStatus_ = child_.text
            OwnershipStatus_ = self.gds_validate_string(OwnershipStatus_, node, 'OwnershipStatus')
            self.OwnershipStatus = OwnershipStatus_
            # validate type OwnershipStatus
            self.validate_OwnershipStatus(self.OwnershipStatus)
        elif nodeName_ == 'PrimaryContactID':
            obj_ = PrimaryContactID.factory()
            obj_.build(child_)
            self.PrimaryContactID = obj_
            obj_.original_tagname_ = 'PrimaryContactID'
        elif nodeName_ == 'NAICSCode':
            NAICSCode_ = child_.text
            NAICSCode_ = self.gds_validate_string(NAICSCode_, node, 'NAICSCode')
            self.NAICSCode = NAICSCode_
        elif nodeName_ == 'PubliclySubsidized':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PubliclySubsidized')
            self.PubliclySubsidized = ival_
        elif nodeName_ == 'FederalBuilding':
            obj_ = FederalBuildingType.factory()
            obj_.build(child_)
            self.FederalBuilding = obj_
            obj_.original_tagname_ = 'FederalBuilding'
        elif nodeName_ == 'PortfolioManager':
            obj_ = PortfolioManagerType.factory()
            obj_.build(child_)
            self.PortfolioManager = obj_
            obj_.original_tagname_ = 'PortfolioManager'
        elif nodeName_ == 'NumberOfBusinesses':
            obj_ = NumberOfBusinessesType.factory()
            obj_.build(child_)
            self.NumberOfBusinesses = obj_
            obj_.original_tagname_ = 'NumberOfBusinesses'
        elif nodeName_ == 'FloorAreas':
            obj_ = FloorAreas.factory()
            obj_.build(child_)
            self.FloorAreas = obj_
            obj_.original_tagname_ = 'FloorAreas'
        elif nodeName_ == 'AspectRatio':
            obj_ = AspectRatioType.factory()
            obj_.build(child_)
            self.AspectRatio = obj_
            obj_.original_tagname_ = 'AspectRatio'
        elif nodeName_ == 'Perimeter':
            obj_ = PerimeterType.factory()
            obj_.build(child_)
            self.Perimeter = obj_
            obj_.original_tagname_ = 'Perimeter'
        elif nodeName_ == 'HeightDistribution':
            HeightDistribution_ = child_.text
            HeightDistribution_ = self.gds_validate_string(HeightDistribution_, node, 'HeightDistribution')
            self.HeightDistribution = HeightDistribution_
            # validate type HeightDistributionType
            self.validate_HeightDistributionType(self.HeightDistribution)
        elif nodeName_ == 'HorizontalSurroundings':
            HorizontalSurroundings_ = child_.text
            HorizontalSurroundings_ = self.gds_validate_string(HorizontalSurroundings_, node, 'HorizontalSurroundings')
            self.HorizontalSurroundings = HorizontalSurroundings_
            # validate type HorizontalSurroundingsType
            self.validate_HorizontalSurroundingsType(self.HorizontalSurroundings)
        elif nodeName_ == 'VerticalSurroundings':
            VerticalSurroundings_ = child_.text
            VerticalSurroundings_ = self.gds_validate_string(VerticalSurroundings_, node, 'VerticalSurroundings')
            self.VerticalSurroundings = VerticalSurroundings_
            # validate type VerticalSurroundingsType
            self.validate_VerticalSurroundingsType(self.VerticalSurroundings)
        elif nodeName_ == 'Assessment':
            obj_ = AssessmentType.factory()
            obj_.build(child_)
            self.Assessment.append(obj_)
            obj_.original_tagname_ = 'Assessment'
        elif nodeName_ == 'YearOfConstruction':
            YearOfConstruction_ = child_.text
            YearOfConstruction_ = self.gds_validate_string(YearOfConstruction_, node, 'YearOfConstruction')
            self.YearOfConstruction = YearOfConstruction_
        elif nodeName_ == 'YearOccupied':
            YearOccupied_ = child_.text
            YearOccupied_ = self.gds_validate_string(YearOccupied_, node, 'YearOccupied')
            self.YearOccupied = YearOccupied_
        elif nodeName_ == 'YearOfLastEnergyAudit':
            YearOfLastEnergyAudit_ = child_.text
            YearOfLastEnergyAudit_ = self.gds_validate_string(YearOfLastEnergyAudit_, node, 'YearOfLastEnergyAudit')
            self.YearOfLastEnergyAudit = YearOfLastEnergyAudit_
        elif nodeName_ == 'RetrocommissioningDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RetrocommissioningDate = dval_
        elif nodeName_ == 'YearOfLatestRetrofit':
            YearOfLatestRetrofit_ = child_.text
            YearOfLatestRetrofit_ = self.gds_validate_string(YearOfLatestRetrofit_, node, 'YearOfLatestRetrofit')
            self.YearOfLatestRetrofit = YearOfLatestRetrofit_
        elif nodeName_ == 'YearOfLastMajorRemodel':
            YearOfLastMajorRemodel_ = child_.text
            YearOfLastMajorRemodel_ = self.gds_validate_string(YearOfLastMajorRemodel_, node, 'YearOfLastMajorRemodel')
            self.YearOfLastMajorRemodel = YearOfLastMajorRemodel_
        elif nodeName_ == 'PercentOccupiedByOwner':
            obj_ = PercentOccupiedByOwnerType.factory()
            obj_.build(child_)
            self.PercentOccupiedByOwner = obj_
            obj_.original_tagname_ = 'PercentOccupiedByOwner'
        elif nodeName_ == 'OperatorType':
            OperatorType_ = child_.text
            OperatorType_ = self.gds_validate_string(OperatorType_, node, 'OperatorType')
            self.OperatorType = OperatorType_
            # validate type OperatorTypeType
            self.validate_OperatorTypeType(self.OperatorType)
        elif nodeName_ == 'Subsections':
            obj_ = SubsectionsType.factory()
            obj_.build(child_)
            self.Subsections = obj_
            obj_.original_tagname_ = 'Subsections'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class CommercialFacilityType


class BlockType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PremisesName=None, PremisesNotes=None, PremisesIdentifiers=None, OccupancyClassification=None, OccupancyLevels=None, PrimaryContactID=None, YearOfConstruction=None, FootprintShape=None, FloorAreas=None, ThermalZoneLayout=None, PerimeterZoneDepth=None, SideA1Orientation=None, Sides=None, RoofID=None, FoundationID=None, XOffset=None, YOffset=None, ZOffset=None, FloorsAboveGrade=None, FloorsBelowGrade=None, FloorsPartiallyBelowGrade=None, FloorToFloorHeight=None, FloorToCeilingHeight=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.PremisesName = PremisesName
        self.PremisesNotes = PremisesNotes
        if PremisesIdentifiers is None:
            self.PremisesIdentifiers = []
        else:
            self.PremisesIdentifiers = PremisesIdentifiers
        self.OccupancyClassification = OccupancyClassification
        self.validate_OccupancyClassification(self.OccupancyClassification)
        self.OccupancyLevels = OccupancyLevels
        self.PrimaryContactID = PrimaryContactID
        self.YearOfConstruction = YearOfConstruction
        self.FootprintShape = FootprintShape
        self.validate_FootprintShapeType(self.FootprintShape)
        self.FloorAreas = FloorAreas
        self.ThermalZoneLayout = ThermalZoneLayout
        self.validate_ThermalZoneLayoutType(self.ThermalZoneLayout)
        self.PerimeterZoneDepth = PerimeterZoneDepth
        self.SideA1Orientation = SideA1Orientation
        self.Sides = Sides
        self.RoofID = RoofID
        self.FoundationID = FoundationID
        self.XOffset = XOffset
        self.YOffset = YOffset
        self.ZOffset = ZOffset
        self.FloorsAboveGrade = FloorsAboveGrade
        self.FloorsBelowGrade = FloorsBelowGrade
        self.FloorsPartiallyBelowGrade = FloorsPartiallyBelowGrade
        self.FloorToFloorHeight = FloorToFloorHeight
        self.FloorToCeilingHeight = FloorToCeilingHeight
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockType.subclass:
            return BlockType.subclass(*args_, **kwargs_)
        else:
            return BlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OccupancyClassification(self, value):
        # Validate type OccupancyClassification, a restriction on xs:string.
        pass
    def validate_FootprintShapeType(self, value):
        # Validate type FootprintShapeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Rectangular', 'L-Shape', 'U-Shape', 'H-Shape', 'T-Shape', 'O-Shape', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FootprintShapeType' % {"value" : value.encode("utf-8")} )
    def validate_ThermalZoneLayoutType(self, value):
        # Validate type ThermalZoneLayoutType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Perimeter', 'Perimeter and core', 'Single zone', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThermalZoneLayoutType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PremisesName is not None or
            self.PremisesNotes is not None or
            self.PremisesIdentifiers or
            self.OccupancyClassification is not None or
            self.OccupancyLevels is not None or
            self.PrimaryContactID is not None or
            self.YearOfConstruction is not None or
            self.FootprintShape is not None or
            self.FloorAreas is not None or
            self.ThermalZoneLayout is not None or
            self.PerimeterZoneDepth is not None or
            self.SideA1Orientation is not None or
            self.Sides is not None or
            self.RoofID is not None or
            self.FoundationID is not None or
            self.XOffset is not None or
            self.YOffset is not None or
            self.ZOffset is not None or
            self.FloorsAboveGrade is not None or
            self.FloorsBelowGrade is not None or
            self.FloorsPartiallyBelowGrade is not None or
            self.FloorToFloorHeight is not None or
            self.FloorToCeilingHeight is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BlockType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BlockType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PremisesName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesName>%s</%sPremisesName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesName), input_name='PremisesName')), namespace_, eol_))
        if self.PremisesNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesNotes>%s</%sPremisesNotes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesNotes), input_name='PremisesNotes')), namespace_, eol_))
        for PremisesIdentifiers_ in self.PremisesIdentifiers:
            PremisesIdentifiers_.export(outfile, level, namespace_='auc:', name_='PremisesIdentifiers', pretty_print=pretty_print)
        if self.OccupancyClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupancyClassification>%s</%sOccupancyClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupancyClassification), input_name='OccupancyClassification')), namespace_, eol_))
        if self.OccupancyLevels is not None:
            self.OccupancyLevels.export(outfile, level, namespace_='auc:', name_='OccupancyLevels', pretty_print=pretty_print)
        if self.PrimaryContactID is not None:
            self.PrimaryContactID.export(outfile, level, namespace_='auc:', name_='PrimaryContactID', pretty_print=pretty_print)
        if self.YearOfConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearOfConstruction>%s</%sYearOfConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearOfConstruction), input_name='YearOfConstruction')), namespace_, eol_))
        if self.FootprintShape is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFootprintShape>%s</%sFootprintShape>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FootprintShape), input_name='FootprintShape')), namespace_, eol_))
        if self.FloorAreas is not None:
            self.FloorAreas.export(outfile, level, namespace_='auc:', name_='FloorAreas', pretty_print=pretty_print)
        if self.ThermalZoneLayout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThermalZoneLayout>%s</%sThermalZoneLayout>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThermalZoneLayout), input_name='ThermalZoneLayout')), namespace_, eol_))
        if self.PerimeterZoneDepth is not None:
            self.PerimeterZoneDepth.export(outfile, level, namespace_, name_='PerimeterZoneDepth', pretty_print=pretty_print)
        if self.SideA1Orientation is not None:
            self.SideA1Orientation.export(outfile, level, namespace_, name_='SideA1Orientation', pretty_print=pretty_print)
        if self.Sides is not None:
            self.Sides.export(outfile, level, namespace_, name_='Sides', pretty_print=pretty_print)
        if self.RoofID is not None:
            self.RoofID.export(outfile, level, namespace_, name_='RoofID', pretty_print=pretty_print)
        if self.FoundationID is not None:
            self.FoundationID.export(outfile, level, namespace_, name_='FoundationID', pretty_print=pretty_print)
        if self.XOffset is not None:
            self.XOffset.export(outfile, level, namespace_, name_='XOffset', pretty_print=pretty_print)
        if self.YOffset is not None:
            self.YOffset.export(outfile, level, namespace_, name_='YOffset', pretty_print=pretty_print)
        if self.ZOffset is not None:
            self.ZOffset.export(outfile, level, namespace_, name_='ZOffset', pretty_print=pretty_print)
        if self.FloorsAboveGrade is not None:
            self.FloorsAboveGrade.export(outfile, level, namespace_, name_='FloorsAboveGrade', pretty_print=pretty_print)
        if self.FloorsBelowGrade is not None:
            self.FloorsBelowGrade.export(outfile, level, namespace_, name_='FloorsBelowGrade', pretty_print=pretty_print)
        if self.FloorsPartiallyBelowGrade is not None:
            self.FloorsPartiallyBelowGrade.export(outfile, level, namespace_, name_='FloorsPartiallyBelowGrade', pretty_print=pretty_print)
        if self.FloorToFloorHeight is not None:
            self.FloorToFloorHeight.export(outfile, level, namespace_, name_='FloorToFloorHeight', pretty_print=pretty_print)
        if self.FloorToCeilingHeight is not None:
            self.FloorToCeilingHeight.export(outfile, level, namespace_, name_='FloorToCeilingHeight', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PremisesName':
            PremisesName_ = child_.text
            PremisesName_ = self.gds_validate_string(PremisesName_, node, 'PremisesName')
            self.PremisesName = PremisesName_
        elif nodeName_ == 'PremisesNotes':
            PremisesNotes_ = child_.text
            PremisesNotes_ = self.gds_validate_string(PremisesNotes_, node, 'PremisesNotes')
            self.PremisesNotes = PremisesNotes_
        elif nodeName_ == 'PremisesIdentifiers':
            obj_ = PremisesIdentifiers.factory()
            obj_.build(child_)
            self.PremisesIdentifiers.append(obj_)
            obj_.original_tagname_ = 'PremisesIdentifiers'
        elif nodeName_ == 'OccupancyClassification':
            OccupancyClassification_ = child_.text
            OccupancyClassification_ = self.gds_validate_string(OccupancyClassification_, node, 'OccupancyClassification')
            self.OccupancyClassification = OccupancyClassification_
            # validate type OccupancyClassification
            self.validate_OccupancyClassification(self.OccupancyClassification)
        elif nodeName_ == 'OccupancyLevels':
            obj_ = OccupancyLevels.factory()
            obj_.build(child_)
            self.OccupancyLevels = obj_
            obj_.original_tagname_ = 'OccupancyLevels'
        elif nodeName_ == 'PrimaryContactID':
            obj_ = PrimaryContactID.factory()
            obj_.build(child_)
            self.PrimaryContactID = obj_
            obj_.original_tagname_ = 'PrimaryContactID'
        elif nodeName_ == 'YearOfConstruction':
            YearOfConstruction_ = child_.text
            YearOfConstruction_ = self.gds_validate_string(YearOfConstruction_, node, 'YearOfConstruction')
            self.YearOfConstruction = YearOfConstruction_
        elif nodeName_ == 'FootprintShape':
            FootprintShape_ = child_.text
            FootprintShape_ = self.gds_validate_string(FootprintShape_, node, 'FootprintShape')
            self.FootprintShape = FootprintShape_
            # validate type FootprintShapeType
            self.validate_FootprintShapeType(self.FootprintShape)
        elif nodeName_ == 'FloorAreas':
            obj_ = FloorAreas.factory()
            obj_.build(child_)
            self.FloorAreas = obj_
            obj_.original_tagname_ = 'FloorAreas'
        elif nodeName_ == 'ThermalZoneLayout':
            ThermalZoneLayout_ = child_.text
            ThermalZoneLayout_ = self.gds_validate_string(ThermalZoneLayout_, node, 'ThermalZoneLayout')
            self.ThermalZoneLayout = ThermalZoneLayout_
            # validate type ThermalZoneLayoutType
            self.validate_ThermalZoneLayoutType(self.ThermalZoneLayout)
        elif nodeName_ == 'PerimeterZoneDepth':
            obj_ = PerimeterZoneDepthType.factory()
            obj_.build(child_)
            self.PerimeterZoneDepth = obj_
            obj_.original_tagname_ = 'PerimeterZoneDepth'
        elif nodeName_ == 'SideA1Orientation':
            obj_ = SideA1OrientationType.factory()
            obj_.build(child_)
            self.SideA1Orientation = obj_
            obj_.original_tagname_ = 'SideA1Orientation'
        elif nodeName_ == 'Sides':
            obj_ = SidesType.factory()
            obj_.build(child_)
            self.Sides = obj_
            obj_.original_tagname_ = 'Sides'
        elif nodeName_ == 'RoofID':
            obj_ = RoofIDType.factory()
            obj_.build(child_)
            self.RoofID = obj_
            obj_.original_tagname_ = 'RoofID'
        elif nodeName_ == 'FoundationID':
            obj_ = FoundationIDType.factory()
            obj_.build(child_)
            self.FoundationID = obj_
            obj_.original_tagname_ = 'FoundationID'
        elif nodeName_ == 'XOffset':
            obj_ = XOffsetType.factory()
            obj_.build(child_)
            self.XOffset = obj_
            obj_.original_tagname_ = 'XOffset'
        elif nodeName_ == 'YOffset':
            obj_ = YOffsetType.factory()
            obj_.build(child_)
            self.YOffset = obj_
            obj_.original_tagname_ = 'YOffset'
        elif nodeName_ == 'ZOffset':
            obj_ = ZOffsetType.factory()
            obj_.build(child_)
            self.ZOffset = obj_
            obj_.original_tagname_ = 'ZOffset'
        elif nodeName_ == 'FloorsAboveGrade':
            obj_ = FloorsAboveGradeType.factory()
            obj_.build(child_)
            self.FloorsAboveGrade = obj_
            obj_.original_tagname_ = 'FloorsAboveGrade'
        elif nodeName_ == 'FloorsBelowGrade':
            obj_ = FloorsBelowGradeType.factory()
            obj_.build(child_)
            self.FloorsBelowGrade = obj_
            obj_.original_tagname_ = 'FloorsBelowGrade'
        elif nodeName_ == 'FloorsPartiallyBelowGrade':
            obj_ = FloorsPartiallyBelowGradeType.factory()
            obj_.build(child_)
            self.FloorsPartiallyBelowGrade = obj_
            obj_.original_tagname_ = 'FloorsPartiallyBelowGrade'
        elif nodeName_ == 'FloorToFloorHeight':
            obj_ = FloorToFloorHeightType.factory()
            obj_.build(child_)
            self.FloorToFloorHeight = obj_
            obj_.original_tagname_ = 'FloorToFloorHeight'
        elif nodeName_ == 'FloorToCeilingHeight':
            obj_ = FloorToCeilingHeightType.factory()
            obj_.build(child_)
            self.FloorToCeilingHeight = obj_
            obj_.original_tagname_ = 'FloorToCeilingHeight'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class BlockType


class ZoneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PremisesName=None, DeliveryID=None, HVACScheduleID=None, BlockID=None, SetpointTemperatureHeating=None, SetbackTemperatureHeating=None, HeatLowered=None, SetpointTemperatureCooling=None, SetupTemperatureCooling=None, ACAdjusted=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.PremisesName = PremisesName
        if DeliveryID is None:
            self.DeliveryID = []
        else:
            self.DeliveryID = DeliveryID
        if HVACScheduleID is None:
            self.HVACScheduleID = []
        else:
            self.HVACScheduleID = HVACScheduleID
        self.BlockID = BlockID
        self.SetpointTemperatureHeating = SetpointTemperatureHeating
        self.SetbackTemperatureHeating = SetbackTemperatureHeating
        self.HeatLowered = HeatLowered
        self.validate_HeatLoweredType(self.HeatLowered)
        self.SetpointTemperatureCooling = SetpointTemperatureCooling
        self.SetupTemperatureCooling = SetupTemperatureCooling
        self.ACAdjusted = ACAdjusted
        self.validate_ACAdjustedType(self.ACAdjusted)
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneType.subclass:
            return ZoneType.subclass(*args_, **kwargs_)
        else:
            return ZoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HeatLoweredType(self, value):
        # Validate type HeatLoweredType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['During the day', 'At night', 'During sleeping and unoccupied hours', 'Never / rarely', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeatLoweredType' % {"value" : value.encode("utf-8")} )
    def validate_ACAdjustedType(self, value):
        # Validate type ACAdjustedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['During the day', 'At night', 'During sleeping and unoccupied hours', 'Seasonal', 'Never-rarely', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ACAdjustedType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PremisesName is not None or
            self.DeliveryID or
            self.HVACScheduleID or
            self.BlockID is not None or
            self.SetpointTemperatureHeating is not None or
            self.SetbackTemperatureHeating is not None or
            self.HeatLowered is not None or
            self.SetpointTemperatureCooling is not None or
            self.SetupTemperatureCooling is not None or
            self.ACAdjusted is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PremisesName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesName>%s</%sPremisesName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesName), input_name='PremisesName')), namespace_, eol_))
        for DeliveryID_ in self.DeliveryID:
            DeliveryID_.export(outfile, level, namespace_, name_='DeliveryID', pretty_print=pretty_print)
        for HVACScheduleID_ in self.HVACScheduleID:
            HVACScheduleID_.export(outfile, level, namespace_, name_='HVACScheduleID', pretty_print=pretty_print)
        if self.BlockID is not None:
            self.BlockID.export(outfile, level, namespace_, name_='BlockID', pretty_print=pretty_print)
        if self.SetpointTemperatureHeating is not None:
            self.SetpointTemperatureHeating.export(outfile, level, namespace_, name_='SetpointTemperatureHeating', pretty_print=pretty_print)
        if self.SetbackTemperatureHeating is not None:
            self.SetbackTemperatureHeating.export(outfile, level, namespace_, name_='SetbackTemperatureHeating', pretty_print=pretty_print)
        if self.HeatLowered is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatLowered>%s</%sHeatLowered>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatLowered), input_name='HeatLowered')), namespace_, eol_))
        if self.SetpointTemperatureCooling is not None:
            self.SetpointTemperatureCooling.export(outfile, level, namespace_, name_='SetpointTemperatureCooling', pretty_print=pretty_print)
        if self.SetupTemperatureCooling is not None:
            self.SetupTemperatureCooling.export(outfile, level, namespace_, name_='SetupTemperatureCooling', pretty_print=pretty_print)
        if self.ACAdjusted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACAdjusted>%s</%sACAdjusted>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ACAdjusted), input_name='ACAdjusted')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PremisesName':
            PremisesName_ = child_.text
            PremisesName_ = self.gds_validate_string(PremisesName_, node, 'PremisesName')
            self.PremisesName = PremisesName_
        elif nodeName_ == 'DeliveryID':
            obj_ = DeliveryIDType.factory()
            obj_.build(child_)
            self.DeliveryID.append(obj_)
            obj_.original_tagname_ = 'DeliveryID'
        elif nodeName_ == 'HVACScheduleID':
            obj_ = HVACScheduleIDType.factory()
            obj_.build(child_)
            self.HVACScheduleID.append(obj_)
            obj_.original_tagname_ = 'HVACScheduleID'
        elif nodeName_ == 'BlockID':
            obj_ = BlockIDType.factory()
            obj_.build(child_)
            self.BlockID = obj_
            obj_.original_tagname_ = 'BlockID'
        elif nodeName_ == 'SetpointTemperatureHeating':
            obj_ = SetpointTemperatureHeatingType.factory()
            obj_.build(child_)
            self.SetpointTemperatureHeating = obj_
            obj_.original_tagname_ = 'SetpointTemperatureHeating'
        elif nodeName_ == 'SetbackTemperatureHeating':
            obj_ = SetbackTemperatureHeatingType.factory()
            obj_.build(child_)
            self.SetbackTemperatureHeating = obj_
            obj_.original_tagname_ = 'SetbackTemperatureHeating'
        elif nodeName_ == 'HeatLowered':
            HeatLowered_ = child_.text
            HeatLowered_ = self.gds_validate_string(HeatLowered_, node, 'HeatLowered')
            self.HeatLowered = HeatLowered_
            # validate type HeatLoweredType
            self.validate_HeatLoweredType(self.HeatLowered)
        elif nodeName_ == 'SetpointTemperatureCooling':
            obj_ = SetpointTemperatureCoolingType.factory()
            obj_.build(child_)
            self.SetpointTemperatureCooling = obj_
            obj_.original_tagname_ = 'SetpointTemperatureCooling'
        elif nodeName_ == 'SetupTemperatureCooling':
            obj_ = SetupTemperatureCoolingType.factory()
            obj_.build(child_)
            self.SetupTemperatureCooling = obj_
            obj_.original_tagname_ = 'SetupTemperatureCooling'
        elif nodeName_ == 'ACAdjusted':
            ACAdjusted_ = child_.text
            ACAdjusted_ = self.gds_validate_string(ACAdjusted_, node, 'ACAdjusted')
            self.ACAdjusted = ACAdjusted_
            # validate type ACAdjustedType
            self.validate_ACAdjustedType(self.ACAdjusted)
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ZoneType


class SpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PremisesName=None, PremisesNotes=None, PremisesIdentifiers=None, OccupancyClassification=None, OccupancyLevels=None, OccupancyScheduleID=None, OccupantsActivityLevel=None, DaylightingIlluminanceSetPoint=None, PrimaryContactID=None, FloorAreas=None, PercentageOfCommonSpace=None, ConditionedVolume=None, ZoneID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.PremisesName = PremisesName
        self.PremisesNotes = PremisesNotes
        if PremisesIdentifiers is None:
            self.PremisesIdentifiers = []
        else:
            self.PremisesIdentifiers = PremisesIdentifiers
        self.OccupancyClassification = OccupancyClassification
        self.validate_OccupancyClassification(self.OccupancyClassification)
        self.OccupancyLevels = OccupancyLevels
        if OccupancyScheduleID is None:
            self.OccupancyScheduleID = []
        else:
            self.OccupancyScheduleID = OccupancyScheduleID
        self.OccupantsActivityLevel = OccupantsActivityLevel
        self.validate_OccupantsActivityLevelType(self.OccupantsActivityLevel)
        self.DaylightingIlluminanceSetPoint = DaylightingIlluminanceSetPoint
        self.PrimaryContactID = PrimaryContactID
        self.FloorAreas = FloorAreas
        self.PercentageOfCommonSpace = PercentageOfCommonSpace
        self.ConditionedVolume = ConditionedVolume
        self.ZoneID = ZoneID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceType.subclass:
            return SpaceType.subclass(*args_, **kwargs_)
        else:
            return SpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OccupancyClassification(self, value):
        # Validate type OccupancyClassification, a restriction on xs:string.
        pass
    def validate_OccupantsActivityLevelType(self, value):
        # Validate type OccupantsActivityLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Low', 'High', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OccupantsActivityLevelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PremisesName is not None or
            self.PremisesNotes is not None or
            self.PremisesIdentifiers or
            self.OccupancyClassification is not None or
            self.OccupancyLevels is not None or
            self.OccupancyScheduleID or
            self.OccupantsActivityLevel is not None or
            self.DaylightingIlluminanceSetPoint is not None or
            self.PrimaryContactID is not None or
            self.FloorAreas is not None or
            self.PercentageOfCommonSpace is not None or
            self.ConditionedVolume is not None or
            self.ZoneID is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PremisesName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesName>%s</%sPremisesName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesName), input_name='PremisesName')), namespace_, eol_))
        if self.PremisesNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPremisesNotes>%s</%sPremisesNotes>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PremisesNotes), input_name='PremisesNotes')), namespace_, eol_))
        for PremisesIdentifiers_ in self.PremisesIdentifiers:
            PremisesIdentifiers_.export(outfile, level, namespace_='auc:', name_='PremisesIdentifiers', pretty_print=pretty_print)
        if self.OccupancyClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupancyClassification>%s</%sOccupancyClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupancyClassification), input_name='OccupancyClassification')), namespace_, eol_))
        if self.OccupancyLevels is not None:
            self.OccupancyLevels.export(outfile, level, namespace_='auc:', name_='OccupancyLevels', pretty_print=pretty_print)
        for OccupancyScheduleID_ in self.OccupancyScheduleID:
            OccupancyScheduleID_.export(outfile, level, namespace_, name_='OccupancyScheduleID', pretty_print=pretty_print)
        if self.OccupantsActivityLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupantsActivityLevel>%s</%sOccupantsActivityLevel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupantsActivityLevel), input_name='OccupantsActivityLevel')), namespace_, eol_))
        if self.DaylightingIlluminanceSetPoint is not None:
            self.DaylightingIlluminanceSetPoint.export(outfile, level, namespace_, name_='DaylightingIlluminanceSetPoint', pretty_print=pretty_print)
        if self.PrimaryContactID is not None:
            self.PrimaryContactID.export(outfile, level, namespace_='auc:', name_='PrimaryContactID', pretty_print=pretty_print)
        if self.FloorAreas is not None:
            self.FloorAreas.export(outfile, level, namespace_='auc:', name_='FloorAreas', pretty_print=pretty_print)
        if self.PercentageOfCommonSpace is not None:
            self.PercentageOfCommonSpace.export(outfile, level, namespace_, name_='PercentageOfCommonSpace', pretty_print=pretty_print)
        if self.ConditionedVolume is not None:
            self.ConditionedVolume.export(outfile, level, namespace_, name_='ConditionedVolume', pretty_print=pretty_print)
        if self.ZoneID is not None:
            self.ZoneID.export(outfile, level, namespace_, name_='ZoneID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PremisesName':
            PremisesName_ = child_.text
            PremisesName_ = self.gds_validate_string(PremisesName_, node, 'PremisesName')
            self.PremisesName = PremisesName_
        elif nodeName_ == 'PremisesNotes':
            PremisesNotes_ = child_.text
            PremisesNotes_ = self.gds_validate_string(PremisesNotes_, node, 'PremisesNotes')
            self.PremisesNotes = PremisesNotes_
        elif nodeName_ == 'PremisesIdentifiers':
            obj_ = PremisesIdentifiers.factory()
            obj_.build(child_)
            self.PremisesIdentifiers.append(obj_)
            obj_.original_tagname_ = 'PremisesIdentifiers'
        elif nodeName_ == 'OccupancyClassification':
            OccupancyClassification_ = child_.text
            OccupancyClassification_ = self.gds_validate_string(OccupancyClassification_, node, 'OccupancyClassification')
            self.OccupancyClassification = OccupancyClassification_
            # validate type OccupancyClassification
            self.validate_OccupancyClassification(self.OccupancyClassification)
        elif nodeName_ == 'OccupancyLevels':
            obj_ = OccupancyLevels.factory()
            obj_.build(child_)
            self.OccupancyLevels = obj_
            obj_.original_tagname_ = 'OccupancyLevels'
        elif nodeName_ == 'OccupancyScheduleID':
            obj_ = OccupancyScheduleIDType.factory()
            obj_.build(child_)
            self.OccupancyScheduleID.append(obj_)
            obj_.original_tagname_ = 'OccupancyScheduleID'
        elif nodeName_ == 'OccupantsActivityLevel':
            OccupantsActivityLevel_ = child_.text
            OccupantsActivityLevel_ = self.gds_validate_string(OccupantsActivityLevel_, node, 'OccupantsActivityLevel')
            self.OccupantsActivityLevel = OccupantsActivityLevel_
            # validate type OccupantsActivityLevelType
            self.validate_OccupantsActivityLevelType(self.OccupantsActivityLevel)
        elif nodeName_ == 'DaylightingIlluminanceSetPoint':
            obj_ = DaylightingIlluminanceSetPointType.factory()
            obj_.build(child_)
            self.DaylightingIlluminanceSetPoint = obj_
            obj_.original_tagname_ = 'DaylightingIlluminanceSetPoint'
        elif nodeName_ == 'PrimaryContactID':
            obj_ = PrimaryContactID.factory()
            obj_.build(child_)
            self.PrimaryContactID = obj_
            obj_.original_tagname_ = 'PrimaryContactID'
        elif nodeName_ == 'FloorAreas':
            obj_ = FloorAreas.factory()
            obj_.build(child_)
            self.FloorAreas = obj_
            obj_.original_tagname_ = 'FloorAreas'
        elif nodeName_ == 'PercentageOfCommonSpace':
            obj_ = PercentageOfCommonSpaceType.factory()
            obj_.build(child_)
            self.PercentageOfCommonSpace = obj_
            obj_.original_tagname_ = 'PercentageOfCommonSpace'
        elif nodeName_ == 'ConditionedVolume':
            obj_ = ConditionedVolumeType.factory()
            obj_.build(child_)
            self.ConditionedVolume = obj_
            obj_.original_tagname_ = 'ConditionedVolume'
        elif nodeName_ == 'ZoneID':
            obj_ = ZoneIDType15.factory()
            obj_.build(child_)
            self.ZoneID = obj_
            obj_.original_tagname_ = 'ZoneID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class SpaceType


class ScheduleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, SchedulePeriodBeginDate=None, SchedulePeriodEndDate=None, ScheduleDetails=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        if isinstance(SchedulePeriodBeginDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(SchedulePeriodBeginDate, '%Y-%m-%d').date()
        else:
            initvalue_ = SchedulePeriodBeginDate
        self.SchedulePeriodBeginDate = initvalue_
        if isinstance(SchedulePeriodEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(SchedulePeriodEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = SchedulePeriodEndDate
        self.SchedulePeriodEndDate = initvalue_
        if ScheduleDetails is None:
            self.ScheduleDetails = []
        else:
            self.ScheduleDetails = ScheduleDetails
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScheduleType.subclass:
            return ScheduleType.subclass(*args_, **kwargs_)
        else:
            return ScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SchedulePeriodBeginDate is not None or
            self.SchedulePeriodEndDate is not None or
            self.ScheduleDetails or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScheduleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScheduleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScheduleType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScheduleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SchedulePeriodBeginDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSchedulePeriodBeginDate>%s</%sSchedulePeriodBeginDate>%s' % (namespace_, self.gds_format_date(self.SchedulePeriodBeginDate, input_name='SchedulePeriodBeginDate'), namespace_, eol_))
        if self.SchedulePeriodEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSchedulePeriodEndDate>%s</%sSchedulePeriodEndDate>%s' % (namespace_, self.gds_format_date(self.SchedulePeriodEndDate, input_name='SchedulePeriodEndDate'), namespace_, eol_))
        for ScheduleDetails_ in self.ScheduleDetails:
            ScheduleDetails_.export(outfile, level, namespace_, name_='ScheduleDetails', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchedulePeriodBeginDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.SchedulePeriodBeginDate = dval_
        elif nodeName_ == 'SchedulePeriodEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.SchedulePeriodEndDate = dval_
        elif nodeName_ == 'ScheduleDetails':
            obj_ = ScheduleDetailsType.factory()
            obj_.build(child_)
            self.ScheduleDetails.append(obj_)
            obj_.original_tagname_ = 'ScheduleDetails'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ScheduleType


class ContactType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ContactRole=None, ContactName=None, ContactCompany=None, Address=None, ContactTelephoneNumbers=None, ContactEmailAddresses=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.ContactRole = ContactRole
        self.validate_ContactRoleType(self.ContactRole)
        self.ContactName = ContactName
        self.ContactCompany = ContactCompany
        self.Address = Address
        if ContactTelephoneNumbers is None:
            self.ContactTelephoneNumbers = []
        else:
            self.ContactTelephoneNumbers = ContactTelephoneNumbers
        if ContactEmailAddresses is None:
            self.ContactEmailAddresses = []
        else:
            self.ContactEmailAddresses = ContactEmailAddresses
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ContactRoleType(self, value):
        # Validate type ContactRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Premises', 'Occupant', 'Agency', 'Owner', 'Customer', 'Customer agreement', 'Administrator', 'Qualified Assessor', 'Contributor', 'Property Management Company', 'Operator', 'Energy Auditor', 'Energy Modeler', 'Contractor', 'Implementer', 'Financier', 'Commissioning Agent', 'MV Agent', 'Evaluator', 'Builder', 'Service', 'Billing', 'Architect', 'Mechanical Engineer', 'Energy Consultant', 'Service and Product Provider', 'Authority Having Jurisdiction', 'Utility', 'Power plant', 'Electric Distribution Utility (EDU)', 'ESCO', 'Facilitator', 'Finance Specialist', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ContactRoleType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ContactRole is not None or
            self.ContactName is not None or
            self.ContactCompany is not None or
            self.Address is not None or
            self.ContactTelephoneNumbers or
            self.ContactEmailAddresses or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ContactType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ContactType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ContactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactRole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactRole>%s</%sContactRole>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactRole), input_name='ContactRole')), namespace_, eol_))
        if self.ContactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactName>%s</%sContactName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactName), input_name='ContactName')), namespace_, eol_))
        if self.ContactCompany is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactCompany>%s</%sContactCompany>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactCompany), input_name='ContactCompany')), namespace_, eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_='auc:', name_='Address', pretty_print=pretty_print)
        for ContactTelephoneNumbers_ in self.ContactTelephoneNumbers:
            ContactTelephoneNumbers_.export(outfile, level, namespace_, name_='ContactTelephoneNumbers', pretty_print=pretty_print)
        for ContactEmailAddresses_ in self.ContactEmailAddresses:
            ContactEmailAddresses_.export(outfile, level, namespace_, name_='ContactEmailAddresses', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactRole':
            ContactRole_ = child_.text
            ContactRole_ = self.gds_validate_string(ContactRole_, node, 'ContactRole')
            self.ContactRole = ContactRole_
            # validate type ContactRoleType
            self.validate_ContactRoleType(self.ContactRole)
        elif nodeName_ == 'ContactName':
            ContactName_ = child_.text
            ContactName_ = self.gds_validate_string(ContactName_, node, 'ContactName')
            self.ContactName = ContactName_
        elif nodeName_ == 'ContactCompany':
            ContactCompany_ = child_.text
            ContactCompany_ = self.gds_validate_string(ContactCompany_, node, 'ContactCompany')
            self.ContactCompany = ContactCompany_
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'ContactTelephoneNumbers':
            obj_ = ContactTelephoneNumbersType.factory()
            obj_.build(child_)
            self.ContactTelephoneNumbers.append(obj_)
            obj_.original_tagname_ = 'ContactTelephoneNumbers'
        elif nodeName_ == 'ContactEmailAddresses':
            obj_ = ContactEmailAddressesType.factory()
            obj_.build(child_)
            self.ContactEmailAddresses.append(obj_)
            obj_.original_tagname_ = 'ContactEmailAddresses'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ContactType


class ScenarioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ScenarioName=None, TemporalStatus=None, Normalization=None, ScenarioType_member=None, WeatherType=None, ResourceUses=None, TimeSeriesData=None, AllResourceTotals=None, AnnualHeatingDegreeDays=None, AnnualCoolingDegreeDays=None, HDDBaseTemperature=None, CDDBaseTemperature=None, LinkedPremises=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.ScenarioName = ScenarioName
        self.TemporalStatus = TemporalStatus
        self.validate_TemporalStatus(self.TemporalStatus)
        self.Normalization = Normalization
        self.validate_NormalizationType(self.Normalization)
        self.ScenarioType = ScenarioType_member
        self.WeatherType = WeatherType
        self.ResourceUses = ResourceUses
        self.TimeSeriesData = TimeSeriesData
        self.AllResourceTotals = AllResourceTotals
        self.AnnualHeatingDegreeDays = AnnualHeatingDegreeDays
        self.AnnualCoolingDegreeDays = AnnualCoolingDegreeDays
        self.HDDBaseTemperature = HDDBaseTemperature
        self.CDDBaseTemperature = CDDBaseTemperature
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScenarioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScenarioType.subclass:
            return ScenarioType.subclass(*args_, **kwargs_)
        else:
            return ScenarioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TemporalStatus(self, value):
        # Validate type TemporalStatus, a restriction on xs:string.
        pass
    def validate_NormalizationType(self, value):
        # Validate type NormalizationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['National Median', 'Regional Median', 'Adjusted to specific year', 'Weather normalized', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NormalizationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ScenarioName is not None or
            self.TemporalStatus is not None or
            self.Normalization is not None or
            self.ScenarioType is not None or
            self.WeatherType is not None or
            self.ResourceUses is not None or
            self.TimeSeriesData is not None or
            self.AllResourceTotals is not None or
            self.AnnualHeatingDegreeDays is not None or
            self.AnnualCoolingDegreeDays is not None or
            self.HDDBaseTemperature is not None or
            self.CDDBaseTemperature is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScenarioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScenarioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScenarioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScenarioType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScenarioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ScenarioName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScenarioName>%s</%sScenarioName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ScenarioName), input_name='ScenarioName')), namespace_, eol_))
        if self.TemporalStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTemporalStatus>%s</%sTemporalStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TemporalStatus), input_name='TemporalStatus')), namespace_, eol_))
        if self.Normalization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNormalization>%s</%sNormalization>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Normalization), input_name='Normalization')), namespace_, eol_))
        if self.ScenarioType is not None:
            self.ScenarioType.export(outfile, level, namespace_, name_='ScenarioType', pretty_print=pretty_print)
        if self.WeatherType is not None:
            self.WeatherType.export(outfile, level, namespace_, name_='WeatherType', pretty_print=pretty_print)
        if self.ResourceUses is not None:
            self.ResourceUses.export(outfile, level, namespace_, name_='ResourceUses', pretty_print=pretty_print)
        if self.TimeSeriesData is not None:
            self.TimeSeriesData.export(outfile, level, namespace_, name_='TimeSeriesData', pretty_print=pretty_print)
        if self.AllResourceTotals is not None:
            self.AllResourceTotals.export(outfile, level, namespace_, name_='AllResourceTotals', pretty_print=pretty_print)
        if self.AnnualHeatingDegreeDays is not None:
            self.AnnualHeatingDegreeDays.export(outfile, level, namespace_, name_='AnnualHeatingDegreeDays', pretty_print=pretty_print)
        if self.AnnualCoolingDegreeDays is not None:
            self.AnnualCoolingDegreeDays.export(outfile, level, namespace_, name_='AnnualCoolingDegreeDays', pretty_print=pretty_print)
        if self.HDDBaseTemperature is not None:
            self.HDDBaseTemperature.export(outfile, level, namespace_, name_='HDDBaseTemperature', pretty_print=pretty_print)
        if self.CDDBaseTemperature is not None:
            self.CDDBaseTemperature.export(outfile, level, namespace_, name_='CDDBaseTemperature', pretty_print=pretty_print)
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScenarioName':
            ScenarioName_ = child_.text
            ScenarioName_ = self.gds_validate_string(ScenarioName_, node, 'ScenarioName')
            self.ScenarioName = ScenarioName_
        elif nodeName_ == 'TemporalStatus':
            TemporalStatus_ = child_.text
            TemporalStatus_ = self.gds_validate_string(TemporalStatus_, node, 'TemporalStatus')
            self.TemporalStatus = TemporalStatus_
            # validate type TemporalStatus
            self.validate_TemporalStatus(self.TemporalStatus)
        elif nodeName_ == 'Normalization':
            Normalization_ = child_.text
            Normalization_ = self.gds_validate_string(Normalization_, node, 'Normalization')
            self.Normalization = Normalization_
            # validate type NormalizationType
            self.validate_NormalizationType(self.Normalization)
        elif nodeName_ == 'ScenarioType':
            obj_ = ScenarioTypeType.factory()
            obj_.build(child_)
            self.ScenarioType = obj_
            obj_.original_tagname_ = 'ScenarioType'
        elif nodeName_ == 'WeatherType':
            obj_ = WeatherTypeType.factory()
            obj_.build(child_)
            self.WeatherType = obj_
            obj_.original_tagname_ = 'WeatherType'
        elif nodeName_ == 'ResourceUses':
            obj_ = ResourceUsesType.factory()
            obj_.build(child_)
            self.ResourceUses = obj_
            obj_.original_tagname_ = 'ResourceUses'
        elif nodeName_ == 'TimeSeriesData':
            obj_ = TimeSeriesDataType.factory()
            obj_.build(child_)
            self.TimeSeriesData = obj_
            obj_.original_tagname_ = 'TimeSeriesData'
        elif nodeName_ == 'AllResourceTotals':
            obj_ = AllResourceTotalsType.factory()
            obj_.build(child_)
            self.AllResourceTotals = obj_
            obj_.original_tagname_ = 'AllResourceTotals'
        elif nodeName_ == 'AnnualHeatingDegreeDays':
            obj_ = AnnualHeatingDegreeDaysType.factory()
            obj_.build(child_)
            self.AnnualHeatingDegreeDays = obj_
            obj_.original_tagname_ = 'AnnualHeatingDegreeDays'
        elif nodeName_ == 'AnnualCoolingDegreeDays':
            obj_ = AnnualCoolingDegreeDaysType.factory()
            obj_.build(child_)
            self.AnnualCoolingDegreeDays = obj_
            obj_.original_tagname_ = 'AnnualCoolingDegreeDays'
        elif nodeName_ == 'HDDBaseTemperature':
            obj_ = HDDBaseTemperatureType.factory()
            obj_.build(child_)
            self.HDDBaseTemperature = obj_
            obj_.original_tagname_ = 'HDDBaseTemperature'
        elif nodeName_ == 'CDDBaseTemperature':
            obj_ = CDDBaseTemperatureType.factory()
            obj_.build(child_)
            self.CDDBaseTemperature = obj_
            obj_.original_tagname_ = 'CDDBaseTemperature'
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ScenarioType


class ResourceUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, EnergyResource=None, ResourceBoundary=None, WaterResource=None, ResourceUnits=None, PercentResource=None, SharedResourceSystem=None, EndUse=None, PercentEndUse=None, AnnualFuelUseNativeUnits=None, AnnualFuelUseConsistentUnits=None, FuelUseIntensity=None, Utility=None, Emissions=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.EnergyResource = EnergyResource
        self.validate_EnergyResource(self.EnergyResource)
        self.ResourceBoundary = ResourceBoundary
        self.validate_ResourceBoundary(self.ResourceBoundary)
        self.WaterResource = WaterResource
        self.validate_WaterResource(self.WaterResource)
        self.ResourceUnits = ResourceUnits
        self.validate_ResourceUnits(self.ResourceUnits)
        self.PercentResource = PercentResource
        self.SharedResourceSystem = SharedResourceSystem
        self.validate_SharedResourceSystemType(self.SharedResourceSystem)
        self.EndUse = EndUse
        self.validate_EndUse(self.EndUse)
        self.PercentEndUse = PercentEndUse
        self.AnnualFuelUseNativeUnits = AnnualFuelUseNativeUnits
        self.AnnualFuelUseConsistentUnits = AnnualFuelUseConsistentUnits
        self.FuelUseIntensity = FuelUseIntensity
        if Utility is None:
            self.Utility = []
        else:
            self.Utility = Utility
        if Emissions is None:
            self.Emissions = []
        else:
            self.Emissions = Emissions
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceUseType.subclass:
            return ResourceUseType.subclass(*args_, **kwargs_)
        else:
            return ResourceUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnergyResource(self, value):
        # Validate type EnergyResource, a restriction on xs:string.
        pass
    def validate_ResourceBoundary(self, value):
        # Validate type ResourceBoundary, a restriction on xs:string.
        pass
    def validate_WaterResource(self, value):
        # Validate type WaterResource, a restriction on xs:string.
        pass
    def validate_ResourceUnits(self, value):
        # Validate type ResourceUnits, a restriction on xs:string.
        pass
    def validate_SharedResourceSystemType(self, value):
        # Validate type SharedResourceSystemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Shared energy systems or meters for multiple building on a single lot', 'Shared energy systems or meter for multiple buildings on multiple lots', 'Energy system or meter not shared', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SharedResourceSystemType' % {"value" : value.encode("utf-8")} )
    def validate_EndUse(self, value):
        # Validate type EndUse, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Whole building', 'Total lighting', 'Interior lighting', 'Exterior lighting', 'Heating', 'Cooling', 'Ventilation', 'Pump', 'IT', 'Plug-in electric vehicle', 'Plug load', 'Process load', 'Conveyance', 'Domestic hot water', 'Refrigeration', 'Cooking', 'Dishwasher', 'Laundry', 'Pool heating', 'On-site generation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EndUse' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EnergyResource is not None or
            self.ResourceBoundary is not None or
            self.WaterResource is not None or
            self.ResourceUnits is not None or
            self.PercentResource is not None or
            self.SharedResourceSystem is not None or
            self.EndUse is not None or
            self.PercentEndUse is not None or
            self.AnnualFuelUseNativeUnits is not None or
            self.AnnualFuelUseConsistentUnits is not None or
            self.FuelUseIntensity is not None or
            self.Utility or
            self.Emissions or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResourceUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceUseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResourceUseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResourceUseType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResourceUseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyResource>%s</%sEnergyResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyResource), input_name='EnergyResource')), namespace_, eol_))
        if self.ResourceBoundary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceBoundary>%s</%sResourceBoundary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ResourceBoundary), input_name='ResourceBoundary')), namespace_, eol_))
        if self.WaterResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterResource>%s</%sWaterResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterResource), input_name='WaterResource')), namespace_, eol_))
        if self.ResourceUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceUnits>%s</%sResourceUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ResourceUnits), input_name='ResourceUnits')), namespace_, eol_))
        if self.PercentResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentResource>%s</%sPercentResource>%s' % (namespace_, self.gds_format_float(self.PercentResource, input_name='PercentResource'), namespace_, eol_))
        if self.SharedResourceSystem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedResourceSystem>%s</%sSharedResourceSystem>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SharedResourceSystem), input_name='SharedResourceSystem')), namespace_, eol_))
        if self.EndUse is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndUse>%s</%sEndUse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndUse), input_name='EndUse')), namespace_, eol_))
        if self.PercentEndUse is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentEndUse>%s</%sPercentEndUse>%s' % (namespace_, self.gds_format_float(self.PercentEndUse, input_name='PercentEndUse'), namespace_, eol_))
        if self.AnnualFuelUseNativeUnits is not None:
            self.AnnualFuelUseNativeUnits.export(outfile, level, namespace_, name_='AnnualFuelUseNativeUnits', pretty_print=pretty_print)
        if self.AnnualFuelUseConsistentUnits is not None:
            self.AnnualFuelUseConsistentUnits.export(outfile, level, namespace_, name_='AnnualFuelUseConsistentUnits', pretty_print=pretty_print)
        if self.FuelUseIntensity is not None:
            self.FuelUseIntensity.export(outfile, level, namespace_, name_='FuelUseIntensity', pretty_print=pretty_print)
        for Utility_ in self.Utility:
            Utility_.export(outfile, level, namespace_, name_='Utility', pretty_print=pretty_print)
        for Emissions_ in self.Emissions:
            Emissions_.export(outfile, level, namespace_, name_='Emissions', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyResource':
            EnergyResource_ = child_.text
            EnergyResource_ = self.gds_validate_string(EnergyResource_, node, 'EnergyResource')
            self.EnergyResource = EnergyResource_
            # validate type EnergyResource
            self.validate_EnergyResource(self.EnergyResource)
        elif nodeName_ == 'ResourceBoundary':
            ResourceBoundary_ = child_.text
            ResourceBoundary_ = self.gds_validate_string(ResourceBoundary_, node, 'ResourceBoundary')
            self.ResourceBoundary = ResourceBoundary_
            # validate type ResourceBoundary
            self.validate_ResourceBoundary(self.ResourceBoundary)
        elif nodeName_ == 'WaterResource':
            WaterResource_ = child_.text
            WaterResource_ = self.gds_validate_string(WaterResource_, node, 'WaterResource')
            self.WaterResource = WaterResource_
            # validate type WaterResource
            self.validate_WaterResource(self.WaterResource)
        elif nodeName_ == 'ResourceUnits':
            ResourceUnits_ = child_.text
            ResourceUnits_ = self.gds_validate_string(ResourceUnits_, node, 'ResourceUnits')
            self.ResourceUnits = ResourceUnits_
            # validate type ResourceUnits
            self.validate_ResourceUnits(self.ResourceUnits)
        elif nodeName_ == 'PercentResource':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentResource')
            self.PercentResource = fval_
        elif nodeName_ == 'SharedResourceSystem':
            SharedResourceSystem_ = child_.text
            SharedResourceSystem_ = self.gds_validate_string(SharedResourceSystem_, node, 'SharedResourceSystem')
            self.SharedResourceSystem = SharedResourceSystem_
            # validate type SharedResourceSystemType
            self.validate_SharedResourceSystemType(self.SharedResourceSystem)
        elif nodeName_ == 'EndUse':
            EndUse_ = child_.text
            EndUse_ = self.gds_validate_string(EndUse_, node, 'EndUse')
            self.EndUse = EndUse_
            # validate type EndUse
            self.validate_EndUse(self.EndUse)
        elif nodeName_ == 'PercentEndUse':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentEndUse')
            self.PercentEndUse = fval_
        elif nodeName_ == 'AnnualFuelUseNativeUnits':
            obj_ = AnnualFuelUseNativeUnitsType.factory()
            obj_.build(child_)
            self.AnnualFuelUseNativeUnits = obj_
            obj_.original_tagname_ = 'AnnualFuelUseNativeUnits'
        elif nodeName_ == 'AnnualFuelUseConsistentUnits':
            obj_ = AnnualFuelUseConsistentUnitsType.factory()
            obj_.build(child_)
            self.AnnualFuelUseConsistentUnits = obj_
            obj_.original_tagname_ = 'AnnualFuelUseConsistentUnits'
        elif nodeName_ == 'FuelUseIntensity':
            obj_ = FuelUseIntensityType.factory()
            obj_.build(child_)
            self.FuelUseIntensity = obj_
            obj_.original_tagname_ = 'FuelUseIntensity'
        elif nodeName_ == 'Utility':
            obj_ = UtilityType.factory()
            obj_.build(child_)
            self.Utility.append(obj_)
            obj_.original_tagname_ = 'Utility'
        elif nodeName_ == 'Emissions':
            obj_ = EmissionsType56.factory()
            obj_.build(child_)
            self.Emissions.append(obj_)
            obj_.original_tagname_ = 'Emissions'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ResourceUseType


class AllResourceTotalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, EndUse=None, TemporalStatus=None, ResourceBoundary=None, SiteEnergyUse=None, SiteEnergyUseIntensity=None, SourceEnergyUse=None, SourceEnergyUseIntensity=None, EnergyCost=None, OnsiteRenewableSystemElectricityExported=None, ElectricitySourcedFromOnsiteRenewableSystems=None, SummerPeak=None, WinterPeak=None, WaterResource=None, WaterUse=None, WaterIntensity=None, WaterCost=None, WasteWaterVolume=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.EndUse = EndUse
        self.validate_EndUse(self.EndUse)
        self.TemporalStatus = TemporalStatus
        self.validate_TemporalStatus(self.TemporalStatus)
        self.ResourceBoundary = ResourceBoundary
        self.validate_ResourceBoundary(self.ResourceBoundary)
        self.SiteEnergyUse = SiteEnergyUse
        self.SiteEnergyUseIntensity = SiteEnergyUseIntensity
        self.SourceEnergyUse = SourceEnergyUse
        self.SourceEnergyUseIntensity = SourceEnergyUseIntensity
        self.EnergyCost = EnergyCost
        self.OnsiteRenewableSystemElectricityExported = OnsiteRenewableSystemElectricityExported
        self.ElectricitySourcedFromOnsiteRenewableSystems = ElectricitySourcedFromOnsiteRenewableSystems
        self.SummerPeak = SummerPeak
        self.WinterPeak = WinterPeak
        self.WaterResource = WaterResource
        self.validate_WaterResource(self.WaterResource)
        self.WaterUse = WaterUse
        self.WaterIntensity = WaterIntensity
        self.WaterCost = WaterCost
        self.WasteWaterVolume = WasteWaterVolume
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AllResourceTotalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AllResourceTotalType.subclass:
            return AllResourceTotalType.subclass(*args_, **kwargs_)
        else:
            return AllResourceTotalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EndUse(self, value):
        # Validate type EndUse, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Whole building', 'Total lighting', 'Interior lighting', 'Exterior lighting', 'Heating', 'Cooling', 'Ventilation', 'Pump', 'IT', 'Plug-in electric vehicle', 'Plug load', 'Process load', 'Conveyance', 'Domestic hot water', 'Refrigeration', 'Cooking', 'Dishwasher', 'Laundry', 'Pool heating', 'On-site generation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EndUse' % {"value" : value.encode("utf-8")} )
    def validate_TemporalStatus(self, value):
        # Validate type TemporalStatus, a restriction on xs:string.
        pass
    def validate_ResourceBoundary(self, value):
        # Validate type ResourceBoundary, a restriction on xs:string.
        pass
    def validate_WaterResource(self, value):
        # Validate type WaterResource, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.EndUse is not None or
            self.TemporalStatus is not None or
            self.ResourceBoundary is not None or
            self.SiteEnergyUse is not None or
            self.SiteEnergyUseIntensity is not None or
            self.SourceEnergyUse is not None or
            self.SourceEnergyUseIntensity is not None or
            self.EnergyCost is not None or
            self.OnsiteRenewableSystemElectricityExported is not None or
            self.ElectricitySourcedFromOnsiteRenewableSystems is not None or
            self.SummerPeak is not None or
            self.WinterPeak is not None or
            self.WaterResource is not None or
            self.WaterUse is not None or
            self.WaterIntensity is not None or
            self.WaterCost is not None or
            self.WasteWaterVolume is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AllResourceTotalType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllResourceTotalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AllResourceTotalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AllResourceTotalType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AllResourceTotalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndUse is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndUse>%s</%sEndUse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndUse), input_name='EndUse')), namespace_, eol_))
        if self.TemporalStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTemporalStatus>%s</%sTemporalStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TemporalStatus), input_name='TemporalStatus')), namespace_, eol_))
        if self.ResourceBoundary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceBoundary>%s</%sResourceBoundary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ResourceBoundary), input_name='ResourceBoundary')), namespace_, eol_))
        if self.SiteEnergyUse is not None:
            self.SiteEnergyUse.export(outfile, level, namespace_, name_='SiteEnergyUse', pretty_print=pretty_print)
        if self.SiteEnergyUseIntensity is not None:
            self.SiteEnergyUseIntensity.export(outfile, level, namespace_, name_='SiteEnergyUseIntensity', pretty_print=pretty_print)
        if self.SourceEnergyUse is not None:
            self.SourceEnergyUse.export(outfile, level, namespace_, name_='SourceEnergyUse', pretty_print=pretty_print)
        if self.SourceEnergyUseIntensity is not None:
            self.SourceEnergyUseIntensity.export(outfile, level, namespace_, name_='SourceEnergyUseIntensity', pretty_print=pretty_print)
        if self.EnergyCost is not None:
            self.EnergyCost.export(outfile, level, namespace_, name_='EnergyCost', pretty_print=pretty_print)
        if self.OnsiteRenewableSystemElectricityExported is not None:
            self.OnsiteRenewableSystemElectricityExported.export(outfile, level, namespace_, name_='OnsiteRenewableSystemElectricityExported', pretty_print=pretty_print)
        if self.ElectricitySourcedFromOnsiteRenewableSystems is not None:
            self.ElectricitySourcedFromOnsiteRenewableSystems.export(outfile, level, namespace_, name_='ElectricitySourcedFromOnsiteRenewableSystems', pretty_print=pretty_print)
        if self.SummerPeak is not None:
            self.SummerPeak.export(outfile, level, namespace_, name_='SummerPeak', pretty_print=pretty_print)
        if self.WinterPeak is not None:
            self.WinterPeak.export(outfile, level, namespace_, name_='WinterPeak', pretty_print=pretty_print)
        if self.WaterResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterResource>%s</%sWaterResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterResource), input_name='WaterResource')), namespace_, eol_))
        if self.WaterUse is not None:
            self.WaterUse.export(outfile, level, namespace_, name_='WaterUse', pretty_print=pretty_print)
        if self.WaterIntensity is not None:
            self.WaterIntensity.export(outfile, level, namespace_, name_='WaterIntensity', pretty_print=pretty_print)
        if self.WaterCost is not None:
            self.WaterCost.export(outfile, level, namespace_, name_='WaterCost', pretty_print=pretty_print)
        if self.WasteWaterVolume is not None:
            self.WasteWaterVolume.export(outfile, level, namespace_, name_='WasteWaterVolume', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndUse':
            EndUse_ = child_.text
            EndUse_ = self.gds_validate_string(EndUse_, node, 'EndUse')
            self.EndUse = EndUse_
            # validate type EndUse
            self.validate_EndUse(self.EndUse)
        elif nodeName_ == 'TemporalStatus':
            TemporalStatus_ = child_.text
            TemporalStatus_ = self.gds_validate_string(TemporalStatus_, node, 'TemporalStatus')
            self.TemporalStatus = TemporalStatus_
            # validate type TemporalStatus
            self.validate_TemporalStatus(self.TemporalStatus)
        elif nodeName_ == 'ResourceBoundary':
            ResourceBoundary_ = child_.text
            ResourceBoundary_ = self.gds_validate_string(ResourceBoundary_, node, 'ResourceBoundary')
            self.ResourceBoundary = ResourceBoundary_
            # validate type ResourceBoundary
            self.validate_ResourceBoundary(self.ResourceBoundary)
        elif nodeName_ == 'SiteEnergyUse':
            obj_ = SiteEnergyUseType.factory()
            obj_.build(child_)
            self.SiteEnergyUse = obj_
            obj_.original_tagname_ = 'SiteEnergyUse'
        elif nodeName_ == 'SiteEnergyUseIntensity':
            obj_ = SiteEnergyUseIntensityType.factory()
            obj_.build(child_)
            self.SiteEnergyUseIntensity = obj_
            obj_.original_tagname_ = 'SiteEnergyUseIntensity'
        elif nodeName_ == 'SourceEnergyUse':
            obj_ = SourceEnergyUseType.factory()
            obj_.build(child_)
            self.SourceEnergyUse = obj_
            obj_.original_tagname_ = 'SourceEnergyUse'
        elif nodeName_ == 'SourceEnergyUseIntensity':
            obj_ = SourceEnergyUseIntensityType.factory()
            obj_.build(child_)
            self.SourceEnergyUseIntensity = obj_
            obj_.original_tagname_ = 'SourceEnergyUseIntensity'
        elif nodeName_ == 'EnergyCost':
            obj_ = EnergyCostType.factory()
            obj_.build(child_)
            self.EnergyCost = obj_
            obj_.original_tagname_ = 'EnergyCost'
        elif nodeName_ == 'OnsiteRenewableSystemElectricityExported':
            obj_ = OnsiteRenewableSystemElectricityExportedType.factory()
            obj_.build(child_)
            self.OnsiteRenewableSystemElectricityExported = obj_
            obj_.original_tagname_ = 'OnsiteRenewableSystemElectricityExported'
        elif nodeName_ == 'ElectricitySourcedFromOnsiteRenewableSystems':
            obj_ = ElectricitySourcedFromOnsiteRenewableSystemsType.factory()
            obj_.build(child_)
            self.ElectricitySourcedFromOnsiteRenewableSystems = obj_
            obj_.original_tagname_ = 'ElectricitySourcedFromOnsiteRenewableSystems'
        elif nodeName_ == 'SummerPeak':
            obj_ = SummerPeakType.factory()
            obj_.build(child_)
            self.SummerPeak = obj_
            obj_.original_tagname_ = 'SummerPeak'
        elif nodeName_ == 'WinterPeak':
            obj_ = WinterPeakType.factory()
            obj_.build(child_)
            self.WinterPeak = obj_
            obj_.original_tagname_ = 'WinterPeak'
        elif nodeName_ == 'WaterResource':
            WaterResource_ = child_.text
            WaterResource_ = self.gds_validate_string(WaterResource_, node, 'WaterResource')
            self.WaterResource = WaterResource_
            # validate type WaterResource
            self.validate_WaterResource(self.WaterResource)
        elif nodeName_ == 'WaterUse':
            obj_ = WaterUseType57.factory()
            obj_.build(child_)
            self.WaterUse = obj_
            obj_.original_tagname_ = 'WaterUse'
        elif nodeName_ == 'WaterIntensity':
            obj_ = WaterIntensityType.factory()
            obj_.build(child_)
            self.WaterIntensity = obj_
            obj_.original_tagname_ = 'WaterIntensity'
        elif nodeName_ == 'WaterCost':
            obj_ = WaterCostType.factory()
            obj_.build(child_)
            self.WaterCost = obj_
            obj_.original_tagname_ = 'WaterCost'
        elif nodeName_ == 'WasteWaterVolume':
            obj_ = WasteWaterVolumeType.factory()
            obj_.build(child_)
            self.WasteWaterVolume = obj_
            obj_.original_tagname_ = 'WasteWaterVolume'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class AllResourceTotalType


class TimeSeriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ReadingType=None, TimeSeriesReadingQuantity=None, StartTimeStamp=None, EndTimeStamp=None, IntervalFrequency=None, IntervalReading=None, Phase=None, EnergyFlowDirection=None, HeatingDegreeDays=None, CoolingDegreeDays=None, HDDBaseTemperature=None, CDDBaseTemperature=None, ResourceUseID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.ReadingType = ReadingType
        self.validate_ReadingTypeType(self.ReadingType)
        self.TimeSeriesReadingQuantity = TimeSeriesReadingQuantity
        self.validate_TimeSeriesReadingQuantityType(self.TimeSeriesReadingQuantity)
        if isinstance(StartTimeStamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTimeStamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTimeStamp
        self.StartTimeStamp = initvalue_
        if isinstance(EndTimeStamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndTimeStamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EndTimeStamp
        self.EndTimeStamp = initvalue_
        self.IntervalFrequency = IntervalFrequency
        self.validate_IntervalFrequencyType(self.IntervalFrequency)
        self.IntervalReading = IntervalReading
        self.Phase = Phase
        self.validate_PhaseType(self.Phase)
        self.EnergyFlowDirection = EnergyFlowDirection
        self.validate_EnergyFlowDirectionType(self.EnergyFlowDirection)
        self.HeatingDegreeDays = HeatingDegreeDays
        self.CoolingDegreeDays = CoolingDegreeDays
        self.HDDBaseTemperature = HDDBaseTemperature
        self.CDDBaseTemperature = CDDBaseTemperature
        self.ResourceUseID = ResourceUseID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeriesType.subclass:
            return TimeSeriesType.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ReadingTypeType(self, value):
        # Validate type ReadingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Point', 'Median', 'Average', 'Total', 'Peak', 'Minimum', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReadingTypeType' % {"value" : value.encode("utf-8")} )
    def validate_TimeSeriesReadingQuantityType(self, value):
        # Validate type TimeSeriesReadingQuantityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Currency', 'Current', 'Current Angle', 'Demand', 'Frequency', 'Power', 'Power Factor', 'Energy', 'Voltage', 'Voltage Angle', 'Distortion Power Factor', 'Volumetric Flow', 'Humidity ratio', 'Relative humidity', 'Diffuse Horizontal Radiation', 'Direct Normal Radiation', 'Global Horizontal Radiation', 'Dry-Bulb Temperature', 'Wet-Bulb Temperature', 'Wind Speed', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeSeriesReadingQuantityType' % {"value" : value.encode("utf-8")} )
    def validate_IntervalFrequencyType(self, value):
        # Validate type IntervalFrequencyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10-minute', '15-minute', '30-minute', 'Hourly', 'Daily', 'Weekly', 'Monthly', 'Annually', 'Quarterly', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IntervalFrequencyType' % {"value" : value.encode("utf-8")} )
    def validate_PhaseType(self, value):
        # Validate type PhaseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Phase AN', 'Phase A', 'Phase AB', 'Phase BN', 'Phase B', 'Phase CN', 'Phase C', 'Phase ABC', 'Phase BC', 'Phase CA', 'Phase S1', 'Phase S2', 'Phase S1S2', 'Phase S1N', 'Phase S2N', 'Phase S1S2N', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhaseType' % {"value" : value.encode("utf-8")} )
    def validate_EnergyFlowDirectionType(self, value):
        # Validate type EnergyFlowDirectionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Forward', 'Reverse', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnergyFlowDirectionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReadingType is not None or
            self.TimeSeriesReadingQuantity is not None or
            self.StartTimeStamp is not None or
            self.EndTimeStamp is not None or
            self.IntervalFrequency is not None or
            self.IntervalReading is not None or
            self.Phase is not None or
            self.EnergyFlowDirection is not None or
            self.HeatingDegreeDays is not None or
            self.CoolingDegreeDays is not None or
            self.HDDBaseTemperature is not None or
            self.CDDBaseTemperature is not None or
            self.ResourceUseID is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TimeSeriesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TimeSeriesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TimeSeriesType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TimeSeriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReadingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReadingType>%s</%sReadingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReadingType), input_name='ReadingType')), namespace_, eol_))
        if self.TimeSeriesReadingQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeSeriesReadingQuantity>%s</%sTimeSeriesReadingQuantity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TimeSeriesReadingQuantity), input_name='TimeSeriesReadingQuantity')), namespace_, eol_))
        if self.StartTimeStamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTimeStamp>%s</%sStartTimeStamp>%s' % (namespace_, self.gds_format_datetime(self.StartTimeStamp, input_name='StartTimeStamp'), namespace_, eol_))
        if self.EndTimeStamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTimeStamp>%s</%sEndTimeStamp>%s' % (namespace_, self.gds_format_datetime(self.EndTimeStamp, input_name='EndTimeStamp'), namespace_, eol_))
        if self.IntervalFrequency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIntervalFrequency>%s</%sIntervalFrequency>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IntervalFrequency), input_name='IntervalFrequency')), namespace_, eol_))
        if self.IntervalReading is not None:
            self.IntervalReading.export(outfile, level, namespace_, name_='IntervalReading', pretty_print=pretty_print)
        if self.Phase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhase>%s</%sPhase>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Phase), input_name='Phase')), namespace_, eol_))
        if self.EnergyFlowDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyFlowDirection>%s</%sEnergyFlowDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyFlowDirection), input_name='EnergyFlowDirection')), namespace_, eol_))
        if self.HeatingDegreeDays is not None:
            self.HeatingDegreeDays.export(outfile, level, namespace_, name_='HeatingDegreeDays', pretty_print=pretty_print)
        if self.CoolingDegreeDays is not None:
            self.CoolingDegreeDays.export(outfile, level, namespace_, name_='CoolingDegreeDays', pretty_print=pretty_print)
        if self.HDDBaseTemperature is not None:
            self.HDDBaseTemperature.export(outfile, level, namespace_, name_='HDDBaseTemperature', pretty_print=pretty_print)
        if self.CDDBaseTemperature is not None:
            self.CDDBaseTemperature.export(outfile, level, namespace_, name_='CDDBaseTemperature', pretty_print=pretty_print)
        if self.ResourceUseID is not None:
            self.ResourceUseID.export(outfile, level, namespace_, name_='ResourceUseID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReadingType':
            ReadingType_ = child_.text
            ReadingType_ = self.gds_validate_string(ReadingType_, node, 'ReadingType')
            self.ReadingType = ReadingType_
            # validate type ReadingTypeType
            self.validate_ReadingTypeType(self.ReadingType)
        elif nodeName_ == 'TimeSeriesReadingQuantity':
            TimeSeriesReadingQuantity_ = child_.text
            TimeSeriesReadingQuantity_ = self.gds_validate_string(TimeSeriesReadingQuantity_, node, 'TimeSeriesReadingQuantity')
            self.TimeSeriesReadingQuantity = TimeSeriesReadingQuantity_
            # validate type TimeSeriesReadingQuantityType
            self.validate_TimeSeriesReadingQuantityType(self.TimeSeriesReadingQuantity)
        elif nodeName_ == 'StartTimeStamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTimeStamp = dval_
        elif nodeName_ == 'EndTimeStamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EndTimeStamp = dval_
        elif nodeName_ == 'IntervalFrequency':
            IntervalFrequency_ = child_.text
            IntervalFrequency_ = self.gds_validate_string(IntervalFrequency_, node, 'IntervalFrequency')
            self.IntervalFrequency = IntervalFrequency_
            # validate type IntervalFrequencyType
            self.validate_IntervalFrequencyType(self.IntervalFrequency)
        elif nodeName_ == 'IntervalReading':
            obj_ = IntervalReadingType.factory()
            obj_.build(child_)
            self.IntervalReading = obj_
            obj_.original_tagname_ = 'IntervalReading'
        elif nodeName_ == 'Phase':
            Phase_ = child_.text
            Phase_ = self.gds_validate_string(Phase_, node, 'Phase')
            self.Phase = Phase_
            # validate type PhaseType
            self.validate_PhaseType(self.Phase)
        elif nodeName_ == 'EnergyFlowDirection':
            EnergyFlowDirection_ = child_.text
            EnergyFlowDirection_ = self.gds_validate_string(EnergyFlowDirection_, node, 'EnergyFlowDirection')
            self.EnergyFlowDirection = EnergyFlowDirection_
            # validate type EnergyFlowDirectionType
            self.validate_EnergyFlowDirectionType(self.EnergyFlowDirection)
        elif nodeName_ == 'HeatingDegreeDays':
            obj_ = HeatingDegreeDaysType.factory()
            obj_.build(child_)
            self.HeatingDegreeDays = obj_
            obj_.original_tagname_ = 'HeatingDegreeDays'
        elif nodeName_ == 'CoolingDegreeDays':
            obj_ = CoolingDegreeDaysType.factory()
            obj_.build(child_)
            self.CoolingDegreeDays = obj_
            obj_.original_tagname_ = 'CoolingDegreeDays'
        elif nodeName_ == 'HDDBaseTemperature':
            obj_ = HDDBaseTemperatureType58.factory()
            obj_.build(child_)
            self.HDDBaseTemperature = obj_
            obj_.original_tagname_ = 'HDDBaseTemperature'
        elif nodeName_ == 'CDDBaseTemperature':
            obj_ = CDDBaseTemperatureType59.factory()
            obj_.build(child_)
            self.CDDBaseTemperature = obj_
            obj_.original_tagname_ = 'CDDBaseTemperature'
        elif nodeName_ == 'ResourceUseID':
            obj_ = ResourceUseIDType.factory()
            obj_.build(child_)
            self.ResourceUseID = obj_
            obj_.original_tagname_ = 'ResourceUseID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class TimeSeriesType


class MeasureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, TypeOfMeasure=None, SystemCategoryAffected=None, PremisesAffected=None, TechnologyCategory=None, MeasureScaleOfApplication=None, LongDescription=None, MeasureSavingsAnalysis=None, MVCost=None, MVOption=None, UsefulLife=None, MeasureFirstCost=None, CapitalReplacementCost=None, ResidualValue=None, Recommended=None, StartDate=None, EndDate=None, ImplementationStatus=None, DiscardReason=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.TypeOfMeasure = TypeOfMeasure
        self.SystemCategoryAffected = SystemCategoryAffected
        self.validate_SystemCategoryAffectedType(self.SystemCategoryAffected)
        if PremisesAffected is None:
            self.PremisesAffected = []
        else:
            self.PremisesAffected = PremisesAffected
        if TechnologyCategory is None:
            self.TechnologyCategory = []
        else:
            self.TechnologyCategory = TechnologyCategory
        self.MeasureScaleOfApplication = MeasureScaleOfApplication
        self.validate_MeasureScaleOfApplicationType(self.MeasureScaleOfApplication)
        self.LongDescription = LongDescription
        self.MeasureSavingsAnalysis = MeasureSavingsAnalysis
        self.MVCost = MVCost
        self.MVOption = MVOption
        self.validate_MVOptionType(self.MVOption)
        self.UsefulLife = UsefulLife
        self.MeasureFirstCost = MeasureFirstCost
        self.CapitalReplacementCost = CapitalReplacementCost
        self.ResidualValue = ResidualValue
        self.Recommended = Recommended
        if isinstance(StartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
        if isinstance(EndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
        self.ImplementationStatus = ImplementationStatus
        self.validate_ImplementationStatusType(self.ImplementationStatus)
        self.DiscardReason = DiscardReason
        self.validate_DiscardReasonType(self.DiscardReason)
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureType.subclass:
            return MeasureType.subclass(*args_, **kwargs_)
        else:
            return MeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SystemCategoryAffectedType(self, value):
        # Validate type SystemCategoryAffectedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Air Distribution', 'Heating System', 'Cooling System', 'Other HVAC', 'Lighting', 'Domestic Hot Water', 'Cooking', 'Refrigeration', 'Dishwasher', 'Laundry', 'Pump', 'Fan', 'Motor', 'Heat Recovery', 'Wall', 'Roof / Ceiling', 'Fenestration', 'Foundation', 'General Controls and Operations', 'Critical IT System', 'Plug Load', 'Process Load', 'Conveyance', 'On-Site Storage, Transmission, Generation', 'Pool', 'Water Use', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SystemCategoryAffectedType' % {"value" : value.encode("utf-8")} )
    def validate_MeasureScaleOfApplicationType(self, value):
        # Validate type MeasureScaleOfApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Individual system', 'Multiple systems', 'Individual premise', 'Multiple premises', 'Entire facility', 'Entire site']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureScaleOfApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_MVOptionType(self, value):
        # Validate type MVOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Option A: Retrofit Isolation With Partial Measurement', 'Option B: Retrofit Isolation With Full Measurement', 'Option C: Whole Building Measurement', 'Option D: Calibrated Simulation', 'Combination', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MVOptionType' % {"value" : value.encode("utf-8")} )
    def validate_ImplementationStatusType(self, value):
        # Validate type ImplementationStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Proposed', 'Evaluated', 'Selected', 'Recommended', 'Initiated', 'Discarded', 'In Progress', 'Completed', 'MV', 'Verified', 'Unsatisfactory', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImplementationStatusType' % {"value" : value.encode("utf-8")} )
    def validate_DiscardReasonType(self, value):
        # Validate type DiscardReasonType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Not discarded', 'Long payback', 'Requires permit', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DiscardReasonType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TypeOfMeasure is not None or
            self.SystemCategoryAffected is not None or
            self.PremisesAffected or
            self.TechnologyCategory or
            self.MeasureScaleOfApplication is not None or
            self.LongDescription is not None or
            self.MeasureSavingsAnalysis is not None or
            self.MVCost is not None or
            self.MVOption is not None or
            self.UsefulLife is not None or
            self.MeasureFirstCost is not None or
            self.CapitalReplacementCost is not None or
            self.ResidualValue is not None or
            self.Recommended is not None or
            self.StartDate is not None or
            self.EndDate is not None or
            self.ImplementationStatus is not None or
            self.DiscardReason is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasureType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TypeOfMeasure is not None:
            self.TypeOfMeasure.export(outfile, level, namespace_, name_='TypeOfMeasure', pretty_print=pretty_print)
        if self.SystemCategoryAffected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystemCategoryAffected>%s</%sSystemCategoryAffected>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SystemCategoryAffected), input_name='SystemCategoryAffected')), namespace_, eol_))
        for PremisesAffected_ in self.PremisesAffected:
            PremisesAffected_.export(outfile, level, namespace_, name_='PremisesAffected', pretty_print=pretty_print)
        for TechnologyCategory_ in self.TechnologyCategory:
            TechnologyCategory_.export(outfile, level, namespace_, name_='TechnologyCategory', pretty_print=pretty_print)
        if self.MeasureScaleOfApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureScaleOfApplication>%s</%sMeasureScaleOfApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeasureScaleOfApplication), input_name='MeasureScaleOfApplication')), namespace_, eol_))
        if self.LongDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLongDescription>%s</%sLongDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LongDescription), input_name='LongDescription')), namespace_, eol_))
        if self.MeasureSavingsAnalysis is not None:
            self.MeasureSavingsAnalysis.export(outfile, level, namespace_, name_='MeasureSavingsAnalysis', pretty_print=pretty_print)
        if self.MVCost is not None:
            self.MVCost.export(outfile, level, namespace_, name_='MVCost', pretty_print=pretty_print)
        if self.MVOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMVOption>%s</%sMVOption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MVOption), input_name='MVOption')), namespace_, eol_))
        if self.UsefulLife is not None:
            self.UsefulLife.export(outfile, level, namespace_, name_='UsefulLife', pretty_print=pretty_print)
        if self.MeasureFirstCost is not None:
            self.MeasureFirstCost.export(outfile, level, namespace_, name_='MeasureFirstCost', pretty_print=pretty_print)
        if self.CapitalReplacementCost is not None:
            self.CapitalReplacementCost.export(outfile, level, namespace_, name_='CapitalReplacementCost', pretty_print=pretty_print)
        if self.ResidualValue is not None:
            self.ResidualValue.export(outfile, level, namespace_, name_='ResidualValue', pretty_print=pretty_print)
        if self.Recommended is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecommended>%s</%sRecommended>%s' % (namespace_, self.gds_format_boolean(self.Recommended, input_name='Recommended'), namespace_, eol_))
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartDate>%s</%sStartDate>%s' % (namespace_, self.gds_format_date(self.StartDate, input_name='StartDate'), namespace_, eol_))
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndDate>%s</%sEndDate>%s' % (namespace_, self.gds_format_date(self.EndDate, input_name='EndDate'), namespace_, eol_))
        if self.ImplementationStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImplementationStatus>%s</%sImplementationStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ImplementationStatus), input_name='ImplementationStatus')), namespace_, eol_))
        if self.DiscardReason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscardReason>%s</%sDiscardReason>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DiscardReason), input_name='DiscardReason')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TypeOfMeasure':
            obj_ = TypeOfMeasureType.factory()
            obj_.build(child_)
            self.TypeOfMeasure = obj_
            obj_.original_tagname_ = 'TypeOfMeasure'
        elif nodeName_ == 'SystemCategoryAffected':
            SystemCategoryAffected_ = child_.text
            SystemCategoryAffected_ = self.gds_validate_string(SystemCategoryAffected_, node, 'SystemCategoryAffected')
            self.SystemCategoryAffected = SystemCategoryAffected_
            # validate type SystemCategoryAffectedType
            self.validate_SystemCategoryAffectedType(self.SystemCategoryAffected)
        elif nodeName_ == 'PremisesAffected':
            obj_ = PremisesAffectedType.factory()
            obj_.build(child_)
            self.PremisesAffected.append(obj_)
            obj_.original_tagname_ = 'PremisesAffected'
        elif nodeName_ == 'TechnologyCategory':
            obj_ = TechnologyCategoryType.factory()
            obj_.build(child_)
            self.TechnologyCategory.append(obj_)
            obj_.original_tagname_ = 'TechnologyCategory'
        elif nodeName_ == 'MeasureScaleOfApplication':
            MeasureScaleOfApplication_ = child_.text
            MeasureScaleOfApplication_ = self.gds_validate_string(MeasureScaleOfApplication_, node, 'MeasureScaleOfApplication')
            self.MeasureScaleOfApplication = MeasureScaleOfApplication_
            # validate type MeasureScaleOfApplicationType
            self.validate_MeasureScaleOfApplicationType(self.MeasureScaleOfApplication)
        elif nodeName_ == 'LongDescription':
            LongDescription_ = child_.text
            LongDescription_ = self.gds_validate_string(LongDescription_, node, 'LongDescription')
            self.LongDescription = LongDescription_
        elif nodeName_ == 'MeasureSavingsAnalysis':
            obj_ = MeasureSavingsAnalysisType.factory()
            obj_.build(child_)
            self.MeasureSavingsAnalysis = obj_
            obj_.original_tagname_ = 'MeasureSavingsAnalysis'
        elif nodeName_ == 'MVCost':
            obj_ = MVCostType103.factory()
            obj_.build(child_)
            self.MVCost = obj_
            obj_.original_tagname_ = 'MVCost'
        elif nodeName_ == 'MVOption':
            MVOption_ = child_.text
            MVOption_ = self.gds_validate_string(MVOption_, node, 'MVOption')
            self.MVOption = MVOption_
            # validate type MVOptionType
            self.validate_MVOptionType(self.MVOption)
        elif nodeName_ == 'UsefulLife':
            obj_ = UsefulLifeType.factory()
            obj_.build(child_)
            self.UsefulLife = obj_
            obj_.original_tagname_ = 'UsefulLife'
        elif nodeName_ == 'MeasureFirstCost':
            obj_ = MeasureFirstCostType.factory()
            obj_.build(child_)
            self.MeasureFirstCost = obj_
            obj_.original_tagname_ = 'MeasureFirstCost'
        elif nodeName_ == 'CapitalReplacementCost':
            obj_ = CapitalReplacementCostType.factory()
            obj_.build(child_)
            self.CapitalReplacementCost = obj_
            obj_.original_tagname_ = 'CapitalReplacementCost'
        elif nodeName_ == 'ResidualValue':
            obj_ = ResidualValueType.factory()
            obj_.build(child_)
            self.ResidualValue = obj_
            obj_.original_tagname_ = 'ResidualValue'
        elif nodeName_ == 'Recommended':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Recommended')
            self.Recommended = ival_
        elif nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
        elif nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
        elif nodeName_ == 'ImplementationStatus':
            ImplementationStatus_ = child_.text
            ImplementationStatus_ = self.gds_validate_string(ImplementationStatus_, node, 'ImplementationStatus')
            self.ImplementationStatus = ImplementationStatus_
            # validate type ImplementationStatusType
            self.validate_ImplementationStatusType(self.ImplementationStatus)
        elif nodeName_ == 'DiscardReason':
            DiscardReason_ = child_.text
            DiscardReason_ = self.gds_validate_string(DiscardReason_, node, 'DiscardReason')
            self.DiscardReason = DiscardReason_
            # validate type DiscardReasonType
            self.validate_DiscardReasonType(self.DiscardReason)
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class MeasureType


class HVACSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, Plants=None, HeatingAndCoolingSystems=None, DuctSystems=None, OtherHVACSystems=None, Location=None, Priority=None, FrequencyOfMaintenance=None, PrimaryHVACControlStrategy=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.Plants = Plants
        self.HeatingAndCoolingSystems = HeatingAndCoolingSystems
        self.DuctSystems = DuctSystems
        self.OtherHVACSystems = OtherHVACSystems
        self.Location = Location
        self.validate_Location(self.Location)
        self.Priority = Priority
        self.validate_Priority(self.Priority)
        self.FrequencyOfMaintenance = FrequencyOfMaintenance
        self.validate_FrequencyOfMaintenanceType(self.FrequencyOfMaintenance)
        self.PrimaryHVACControlStrategy = PrimaryHVACControlStrategy
        self.validate_PrimaryHVACControlStrategyType(self.PrimaryHVACControlStrategy)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HVACSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HVACSystemType.subclass:
            return HVACSystemType.subclass(*args_, **kwargs_)
        else:
            return HVACSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def validate_Priority(self, value):
        # Validate type Priority, a restriction on xs:string.
        pass
    def validate_FrequencyOfMaintenanceType(self, value):
        # Validate type FrequencyOfMaintenanceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['As needed', 'Daily', 'Weekly', 'Bi-weekly', 'Monthly', 'Semi-quarterly', 'Quarterly', 'Semi-annually', 'Annually', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FrequencyOfMaintenanceType' % {"value" : value.encode("utf-8")} )
    def validate_PrimaryHVACControlStrategyType(self, value):
        # Validate type PrimaryHVACControlStrategyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Pneumatic', 'Electric', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PrimaryHVACControlStrategyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Plants is not None or
            self.HeatingAndCoolingSystems is not None or
            self.DuctSystems is not None or
            self.OtherHVACSystems is not None or
            self.Location is not None or
            self.Priority is not None or
            self.FrequencyOfMaintenance is not None or
            self.PrimaryHVACControlStrategy is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HVACSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HVACSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HVACSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HVACSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HVACSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Plants is not None:
            self.Plants.export(outfile, level, namespace_, name_='Plants', pretty_print=pretty_print)
        if self.HeatingAndCoolingSystems is not None:
            self.HeatingAndCoolingSystems.export(outfile, level, namespace_, name_='HeatingAndCoolingSystems', pretty_print=pretty_print)
        if self.DuctSystems is not None:
            self.DuctSystems.export(outfile, level, namespace_, name_='DuctSystems', pretty_print=pretty_print)
        if self.OtherHVACSystems is not None:
            self.OtherHVACSystems.export(outfile, level, namespace_, name_='OtherHVACSystems', pretty_print=pretty_print)
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.Priority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPriority>%s</%sPriority>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Priority), input_name='Priority')), namespace_, eol_))
        if self.FrequencyOfMaintenance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFrequencyOfMaintenance>%s</%sFrequencyOfMaintenance>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FrequencyOfMaintenance), input_name='FrequencyOfMaintenance')), namespace_, eol_))
        if self.PrimaryHVACControlStrategy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryHVACControlStrategy>%s</%sPrimaryHVACControlStrategy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryHVACControlStrategy), input_name='PrimaryHVACControlStrategy')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Plants':
            obj_ = PlantsType.factory()
            obj_.build(child_)
            self.Plants = obj_
            obj_.original_tagname_ = 'Plants'
        elif nodeName_ == 'HeatingAndCoolingSystems':
            obj_ = HeatingAndCoolingSystemsType.factory()
            obj_.build(child_)
            self.HeatingAndCoolingSystems = obj_
            obj_.original_tagname_ = 'HeatingAndCoolingSystems'
        elif nodeName_ == 'DuctSystems':
            obj_ = DuctSystemsType.factory()
            obj_.build(child_)
            self.DuctSystems = obj_
            obj_.original_tagname_ = 'DuctSystems'
        elif nodeName_ == 'OtherHVACSystems':
            obj_ = OtherHVACSystemsType.factory()
            obj_.build(child_)
            self.OtherHVACSystems = obj_
            obj_.original_tagname_ = 'OtherHVACSystems'
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'Priority':
            Priority_ = child_.text
            Priority_ = self.gds_validate_string(Priority_, node, 'Priority')
            self.Priority = Priority_
            # validate type Priority
            self.validate_Priority(self.Priority)
        elif nodeName_ == 'FrequencyOfMaintenance':
            FrequencyOfMaintenance_ = child_.text
            FrequencyOfMaintenance_ = self.gds_validate_string(FrequencyOfMaintenance_, node, 'FrequencyOfMaintenance')
            self.FrequencyOfMaintenance = FrequencyOfMaintenance_
            # validate type FrequencyOfMaintenanceType
            self.validate_FrequencyOfMaintenanceType(self.FrequencyOfMaintenance)
        elif nodeName_ == 'PrimaryHVACControlStrategy':
            PrimaryHVACControlStrategy_ = child_.text
            PrimaryHVACControlStrategy_ = self.gds_validate_string(PrimaryHVACControlStrategy_, node, 'PrimaryHVACControlStrategy')
            self.PrimaryHVACControlStrategy = PrimaryHVACControlStrategy_
            # validate type PrimaryHVACControlStrategyType
            self.validate_PrimaryHVACControlStrategyType(self.PrimaryHVACControlStrategy)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class HVACSystemType


class DuctSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, DuctConfiguration=None, MinimumOutsideAirPercentage=None, MaximumOAFlowRate=None, DuctInsulationCondition=None, DuctSealing=None, DuctInsulationRValue=None, DuctSurfaceArea=None, SupplyDuctPercentConditionedSpace=None, ReturnDuctPercentConditionedSpace=None, StaticPressureInstalled=None, DuctType=None, DuctLeakageTestMethod=None, DuctPressureTestLeakageRate=None, SupplyFractionOfDuctLeakage=None, DuctPressureTestLeakagePercentage=None, Quantity=None, Location=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, HeatingDeliveryID=None, CoolingDeliveryID=None, LinkedPremises=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.DuctConfiguration = DuctConfiguration
        self.validate_DuctConfigurationType(self.DuctConfiguration)
        self.MinimumOutsideAirPercentage = MinimumOutsideAirPercentage
        self.MaximumOAFlowRate = MaximumOAFlowRate
        self.DuctInsulationCondition = DuctInsulationCondition
        self.validate_DuctInsulationConditionType(self.DuctInsulationCondition)
        self.DuctSealing = DuctSealing
        self.validate_DuctSealingType(self.DuctSealing)
        self.DuctInsulationRValue = DuctInsulationRValue
        self.DuctSurfaceArea = DuctSurfaceArea
        self.SupplyDuctPercentConditionedSpace = SupplyDuctPercentConditionedSpace
        self.ReturnDuctPercentConditionedSpace = ReturnDuctPercentConditionedSpace
        self.StaticPressureInstalled = StaticPressureInstalled
        self.DuctType = DuctType
        self.validate_DuctTypeType(self.DuctType)
        self.DuctLeakageTestMethod = DuctLeakageTestMethod
        self.validate_DuctLeakageTestMethodType(self.DuctLeakageTestMethod)
        self.DuctPressureTestLeakageRate = DuctPressureTestLeakageRate
        self.SupplyFractionOfDuctLeakage = SupplyFractionOfDuctLeakage
        self.DuctPressureTestLeakagePercentage = DuctPressureTestLeakagePercentage
        self.Quantity = Quantity
        self.Location = Location
        self.validate_Location(self.Location)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.HeatingDeliveryID = HeatingDeliveryID
        self.CoolingDeliveryID = CoolingDeliveryID
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctSystemType.subclass:
            return DuctSystemType.subclass(*args_, **kwargs_)
        else:
            return DuctSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DuctConfigurationType(self, value):
        # Validate type DuctConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Single', 'Dual', 'Three', 'Ductless', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DuctConfigurationType' % {"value" : value.encode("utf-8")} )
    def validate_DuctInsulationConditionType(self, value):
        # Validate type DuctInsulationConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Excellent', 'Good', 'Average', 'Fair', 'Poor', 'Very poor', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DuctInsulationConditionType' % {"value" : value.encode("utf-8")} )
    def validate_DuctSealingType(self, value):
        # Validate type DuctSealingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Connections sealed with mastic', 'No observable leaks', 'Some observable leaks', 'Significant leaks', 'Catastrophic leaks', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DuctSealingType' % {"value" : value.encode("utf-8")} )
    def validate_DuctTypeType(self, value):
        # Validate type DuctTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flex uncategorized', 'Grey flex', 'Mylar flex', 'Duct board', 'Sheet metal', 'Galvanized', 'Flexible', 'Fiberboard', 'No ducting', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DuctTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DuctLeakageTestMethodType(self, value):
        # Validate type DuctLeakageTestMethodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Duct leakage tester', 'Blower door subtract', 'Pressure pan', 'Visual inspection', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DuctLeakageTestMethodType' % {"value" : value.encode("utf-8")} )
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DuctConfiguration is not None or
            self.MinimumOutsideAirPercentage is not None or
            self.MaximumOAFlowRate is not None or
            self.DuctInsulationCondition is not None or
            self.DuctSealing is not None or
            self.DuctInsulationRValue is not None or
            self.DuctSurfaceArea is not None or
            self.SupplyDuctPercentConditionedSpace is not None or
            self.ReturnDuctPercentConditionedSpace is not None or
            self.StaticPressureInstalled is not None or
            self.DuctType is not None or
            self.DuctLeakageTestMethod is not None or
            self.DuctPressureTestLeakageRate is not None or
            self.SupplyFractionOfDuctLeakage is not None or
            self.DuctPressureTestLeakagePercentage is not None or
            self.Quantity is not None or
            self.Location is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.HeatingDeliveryID is not None or
            self.CoolingDeliveryID is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuctConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuctConfiguration>%s</%sDuctConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DuctConfiguration), input_name='DuctConfiguration')), namespace_, eol_))
        if self.MinimumOutsideAirPercentage is not None:
            self.MinimumOutsideAirPercentage.export(outfile, level, namespace_, name_='MinimumOutsideAirPercentage', pretty_print=pretty_print)
        if self.MaximumOAFlowRate is not None:
            self.MaximumOAFlowRate.export(outfile, level, namespace_, name_='MaximumOAFlowRate', pretty_print=pretty_print)
        if self.DuctInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuctInsulationCondition>%s</%sDuctInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DuctInsulationCondition), input_name='DuctInsulationCondition')), namespace_, eol_))
        if self.DuctSealing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuctSealing>%s</%sDuctSealing>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DuctSealing), input_name='DuctSealing')), namespace_, eol_))
        if self.DuctInsulationRValue is not None:
            self.DuctInsulationRValue.export(outfile, level, namespace_, name_='DuctInsulationRValue', pretty_print=pretty_print)
        if self.DuctSurfaceArea is not None:
            self.DuctSurfaceArea.export(outfile, level, namespace_, name_='DuctSurfaceArea', pretty_print=pretty_print)
        if self.SupplyDuctPercentConditionedSpace is not None:
            self.SupplyDuctPercentConditionedSpace.export(outfile, level, namespace_, name_='SupplyDuctPercentConditionedSpace', pretty_print=pretty_print)
        if self.ReturnDuctPercentConditionedSpace is not None:
            self.ReturnDuctPercentConditionedSpace.export(outfile, level, namespace_, name_='ReturnDuctPercentConditionedSpace', pretty_print=pretty_print)
        if self.StaticPressureInstalled is not None:
            self.StaticPressureInstalled.export(outfile, level, namespace_, name_='StaticPressureInstalled', pretty_print=pretty_print)
        if self.DuctType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuctType>%s</%sDuctType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DuctType), input_name='DuctType')), namespace_, eol_))
        if self.DuctLeakageTestMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuctLeakageTestMethod>%s</%sDuctLeakageTestMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DuctLeakageTestMethod), input_name='DuctLeakageTestMethod')), namespace_, eol_))
        if self.DuctPressureTestLeakageRate is not None:
            self.DuctPressureTestLeakageRate.export(outfile, level, namespace_, name_='DuctPressureTestLeakageRate', pretty_print=pretty_print)
        if self.SupplyFractionOfDuctLeakage is not None:
            self.SupplyFractionOfDuctLeakage.export(outfile, level, namespace_, name_='SupplyFractionOfDuctLeakage', pretty_print=pretty_print)
        if self.DuctPressureTestLeakagePercentage is not None:
            self.DuctPressureTestLeakagePercentage.export(outfile, level, namespace_, name_='DuctPressureTestLeakagePercentage', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.HeatingDeliveryID is not None:
            self.HeatingDeliveryID.export(outfile, level, namespace_, name_='HeatingDeliveryID', pretty_print=pretty_print)
        if self.CoolingDeliveryID is not None:
            self.CoolingDeliveryID.export(outfile, level, namespace_, name_='CoolingDeliveryID', pretty_print=pretty_print)
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DuctConfiguration':
            DuctConfiguration_ = child_.text
            DuctConfiguration_ = self.gds_validate_string(DuctConfiguration_, node, 'DuctConfiguration')
            self.DuctConfiguration = DuctConfiguration_
            # validate type DuctConfigurationType
            self.validate_DuctConfigurationType(self.DuctConfiguration)
        elif nodeName_ == 'MinimumOutsideAirPercentage':
            obj_ = MinimumOutsideAirPercentageType.factory()
            obj_.build(child_)
            self.MinimumOutsideAirPercentage = obj_
            obj_.original_tagname_ = 'MinimumOutsideAirPercentage'
        elif nodeName_ == 'MaximumOAFlowRate':
            obj_ = MaximumOAFlowRateType.factory()
            obj_.build(child_)
            self.MaximumOAFlowRate = obj_
            obj_.original_tagname_ = 'MaximumOAFlowRate'
        elif nodeName_ == 'DuctInsulationCondition':
            DuctInsulationCondition_ = child_.text
            DuctInsulationCondition_ = self.gds_validate_string(DuctInsulationCondition_, node, 'DuctInsulationCondition')
            self.DuctInsulationCondition = DuctInsulationCondition_
            # validate type DuctInsulationConditionType
            self.validate_DuctInsulationConditionType(self.DuctInsulationCondition)
        elif nodeName_ == 'DuctSealing':
            DuctSealing_ = child_.text
            DuctSealing_ = self.gds_validate_string(DuctSealing_, node, 'DuctSealing')
            self.DuctSealing = DuctSealing_
            # validate type DuctSealingType
            self.validate_DuctSealingType(self.DuctSealing)
        elif nodeName_ == 'DuctInsulationRValue':
            obj_ = DuctInsulationRValueType.factory()
            obj_.build(child_)
            self.DuctInsulationRValue = obj_
            obj_.original_tagname_ = 'DuctInsulationRValue'
        elif nodeName_ == 'DuctSurfaceArea':
            obj_ = DuctSurfaceAreaType.factory()
            obj_.build(child_)
            self.DuctSurfaceArea = obj_
            obj_.original_tagname_ = 'DuctSurfaceArea'
        elif nodeName_ == 'SupplyDuctPercentConditionedSpace':
            obj_ = SupplyDuctPercentConditionedSpaceType.factory()
            obj_.build(child_)
            self.SupplyDuctPercentConditionedSpace = obj_
            obj_.original_tagname_ = 'SupplyDuctPercentConditionedSpace'
        elif nodeName_ == 'ReturnDuctPercentConditionedSpace':
            obj_ = ReturnDuctPercentConditionedSpaceType.factory()
            obj_.build(child_)
            self.ReturnDuctPercentConditionedSpace = obj_
            obj_.original_tagname_ = 'ReturnDuctPercentConditionedSpace'
        elif nodeName_ == 'StaticPressureInstalled':
            obj_ = StaticPressureInstalledType.factory()
            obj_.build(child_)
            self.StaticPressureInstalled = obj_
            obj_.original_tagname_ = 'StaticPressureInstalled'
        elif nodeName_ == 'DuctType':
            DuctType_ = child_.text
            DuctType_ = self.gds_validate_string(DuctType_, node, 'DuctType')
            self.DuctType = DuctType_
            # validate type DuctTypeType
            self.validate_DuctTypeType(self.DuctType)
        elif nodeName_ == 'DuctLeakageTestMethod':
            DuctLeakageTestMethod_ = child_.text
            DuctLeakageTestMethod_ = self.gds_validate_string(DuctLeakageTestMethod_, node, 'DuctLeakageTestMethod')
            self.DuctLeakageTestMethod = DuctLeakageTestMethod_
            # validate type DuctLeakageTestMethodType
            self.validate_DuctLeakageTestMethodType(self.DuctLeakageTestMethod)
        elif nodeName_ == 'DuctPressureTestLeakageRate':
            obj_ = DuctPressureTestLeakageRateType.factory()
            obj_.build(child_)
            self.DuctPressureTestLeakageRate = obj_
            obj_.original_tagname_ = 'DuctPressureTestLeakageRate'
        elif nodeName_ == 'SupplyFractionOfDuctLeakage':
            obj_ = SupplyFractionOfDuctLeakageType.factory()
            obj_.build(child_)
            self.SupplyFractionOfDuctLeakage = obj_
            obj_.original_tagname_ = 'SupplyFractionOfDuctLeakage'
        elif nodeName_ == 'DuctPressureTestLeakagePercentage':
            obj_ = DuctPressureTestLeakagePercentageType.factory()
            obj_.build(child_)
            self.DuctPressureTestLeakagePercentage = obj_
            obj_.original_tagname_ = 'DuctPressureTestLeakagePercentage'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'HeatingDeliveryID':
            obj_ = HeatingDeliveryIDType.factory()
            obj_.build(child_)
            self.HeatingDeliveryID = obj_
            obj_.original_tagname_ = 'HeatingDeliveryID'
        elif nodeName_ == 'CoolingDeliveryID':
            obj_ = CoolingDeliveryIDType.factory()
            obj_.build(child_)
            self.CoolingDeliveryID = obj_
            obj_.original_tagname_ = 'CoolingDeliveryID'
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class DuctSystemType


class CoolingPlantTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, Chiller=None, DistrictChilledWater=None, OtherCombination=None, NoCoolng=None, Unknown=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.Chiller = Chiller
        self.DistrictChilledWater = DistrictChilledWater
        self.OtherCombination = OtherCombination
        self.NoCoolng = NoCoolng
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingPlantTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingPlantTypeType.subclass:
            return CoolingPlantTypeType.subclass(*args_, **kwargs_)
        else:
            return CoolingPlantTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Chiller is not None or
            self.DistrictChilledWater is not None or
            self.OtherCombination is not None or
            self.NoCoolng is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingPlantTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingPlantTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingPlantTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingPlantTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingPlantTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Chiller is not None:
            self.Chiller.export(outfile, level, namespace_, name_='Chiller', pretty_print=pretty_print)
        if self.DistrictChilledWater is not None:
            self.DistrictChilledWater.export(outfile, level, namespace_, name_='DistrictChilledWater', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.NoCoolng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoCoolng>%s</%sNoCoolng>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NoCoolng), input_name='NoCoolng')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Chiller':
            obj_ = ChillerType137.factory()
            obj_.build(child_)
            self.Chiller = obj_
            obj_.original_tagname_ = 'Chiller'
        elif nodeName_ == 'DistrictChilledWater':
            obj_ = DistrictChilledWaterType.factory()
            obj_.build(child_)
            self.DistrictChilledWater = obj_
            obj_.original_tagname_ = 'DistrictChilledWater'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'NoCoolng':
            NoCoolng_ = child_.text
            NoCoolng_ = self.gds_validate_string(NoCoolng_, node, 'NoCoolng')
            self.NoCoolng = NoCoolng_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class CoolingPlantTypeType


class OtherCombination(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherCombination)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherCombination.subclass:
            return OtherCombination.subclass(*args_, **kwargs_)
        else:
            return OtherCombination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherCombination', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherCombination')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherCombination', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherCombination'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherCombination', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OtherCombination


class NoCoolng(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoCoolng)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoCoolng.subclass:
            return NoCoolng.subclass(*args_, **kwargs_)
        else:
            return NoCoolng(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NoCoolng', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoCoolng')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NoCoolng', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NoCoolng'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NoCoolng', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoCoolng


class Unknown(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unknown)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unknown.subclass:
            return Unknown.subclass(*args_, **kwargs_)
        else:
            return Unknown(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Unknown', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Unknown')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Unknown', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Unknown'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Unknown', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Unknown


class CondenserPlantType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, AirCooled=None, WaterCooled=None, GroundSource=None, GlycolCooledDryCooler=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.AirCooled = AirCooled
        self.WaterCooled = WaterCooled
        self.GroundSource = GroundSource
        self.GlycolCooledDryCooler = GlycolCooledDryCooler
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserPlantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserPlantType.subclass:
            return CondenserPlantType.subclass(*args_, **kwargs_)
        else:
            return CondenserPlantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AirCooled is not None or
            self.WaterCooled is not None or
            self.GroundSource is not None or
            self.GlycolCooledDryCooler is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserPlantType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserPlantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserPlantType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserPlantType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserPlantType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirCooled is not None:
            self.AirCooled.export(outfile, level, namespace_, name_='AirCooled', pretty_print=pretty_print)
        if self.WaterCooled is not None:
            self.WaterCooled.export(outfile, level, namespace_, name_='WaterCooled', pretty_print=pretty_print)
        if self.GroundSource is not None:
            self.GroundSource.export(outfile, level, namespace_, name_='GroundSource', pretty_print=pretty_print)
        if self.GlycolCooledDryCooler is not None:
            self.GlycolCooledDryCooler.export(outfile, level, namespace_, name_='GlycolCooledDryCooler', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirCooled':
            obj_ = AirCooledType.factory()
            obj_.build(child_)
            self.AirCooled = obj_
            obj_.original_tagname_ = 'AirCooled'
        elif nodeName_ == 'WaterCooled':
            obj_ = WaterCooledType.factory()
            obj_.build(child_)
            self.WaterCooled = obj_
            obj_.original_tagname_ = 'WaterCooled'
        elif nodeName_ == 'GroundSource':
            obj_ = GroundSourceType152.factory()
            obj_.build(child_)
            self.GroundSource = obj_
            obj_.original_tagname_ = 'GroundSource'
        elif nodeName_ == 'GlycolCooledDryCooler':
            obj_ = GlycolCooledDryCoolerType.factory()
            obj_.build(child_)
            self.GlycolCooledDryCooler = obj_
            obj_.original_tagname_ = 'GlycolCooledDryCooler'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class CondenserPlantType


class Other(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Other)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Other.subclass:
            return Other.subclass(*args_, **kwargs_)
        else:
            return Other(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Other', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Other')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Other', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Other'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Other', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Other


class OtherHVACSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, OtherHVACType=None, Location=None, PrimaryFuel=None, ControlTechnology=None, Manufacturer=None, ModelNumber=None, YearofManufacture=None, YearInstalled=None, LinkedPremises=None, Integration=None, LinkedDeliveryID=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.OtherHVACType = OtherHVACType
        self.Location = Location
        self.validate_Location(self.Location)
        self.PrimaryFuel = PrimaryFuel
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.YearofManufacture = YearofManufacture
        self.YearInstalled = YearInstalled
        self.LinkedPremises = LinkedPremises
        self.Integration = Integration
        self.validate_IntegrationType(self.Integration)
        self.LinkedDeliveryID = LinkedDeliveryID
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherHVACSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherHVACSystemType.subclass:
            return OtherHVACSystemType.subclass(*args_, **kwargs_)
        else:
            return OtherHVACSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_IntegrationType(self, value):
        # Validate type IntegrationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Integrated with central air distribution', 'Integrated with local air distribution', 'Stand-alone', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IntegrationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherHVACType is not None or
            self.Location is not None or
            self.PrimaryFuel is not None or
            self.ControlTechnology is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.YearofManufacture is not None or
            self.YearInstalled is not None or
            self.LinkedPremises is not None or
            self.Integration is not None or
            self.LinkedDeliveryID is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherHVACSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherHVACSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherHVACSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherHVACSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherHVACSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherHVACType is not None:
            self.OtherHVACType.export(outfile, level, namespace_, name_='OtherHVACType', pretty_print=pretty_print)
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.Integration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIntegration>%s</%sIntegration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Integration), input_name='Integration')), namespace_, eol_))
        if self.LinkedDeliveryID is not None:
            self.LinkedDeliveryID.export(outfile, level, namespace_, name_='LinkedDeliveryID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherHVACType':
            obj_ = OtherHVACTypeType.factory()
            obj_.build(child_)
            self.OtherHVACType = obj_
            obj_.original_tagname_ = 'OtherHVACType'
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'Integration':
            Integration_ = child_.text
            Integration_ = self.gds_validate_string(Integration_, node, 'Integration')
            self.Integration = Integration_
            # validate type IntegrationType
            self.validate_IntegrationType(self.Integration)
        elif nodeName_ == 'LinkedDeliveryID':
            obj_ = xs_IDREF.factory()
            obj_.build(child_)
            self.LinkedDeliveryID = obj_
            obj_.original_tagname_ = 'LinkedDeliveryID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class OtherHVACSystemType


class LightingSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, LampType=None, BallastType=None, InputVoltage=None, InstallationType=None, LightingDirection=None, LightingControlTypeOccupancy=None, LightingControlTypeTimer=None, LightingControlTypeDaylighting=None, LightingControlTypeManual=None, DimmingCapability=None, DaylightingControlSteps=None, PercentPremisesServed=None, InstalledPower=None, LampPower=None, NumberOfLampsPerLuminaire=None, NumberOfLampsPerBallast=None, NumberOfBallastsPerLuminaire=None, NumberOfLuminaires=None, OutsideLighting=None, ReflectorType=None, LightingEfficacy=None, WorkPlaneHeight=None, LuminaireHeight=None, FixtureSpacing=None, RatedLampLife=None, ControlTechnology=None, ThirdPartyCertification=None, PrimaryFuel=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.LampType = LampType
        self.BallastType = BallastType
        self.validate_BallastTypeType(self.BallastType)
        self.InputVoltage = InputVoltage
        self.validate_InputVoltageType(self.InputVoltage)
        self.InstallationType = InstallationType
        self.validate_InstallationTypeType(self.InstallationType)
        self.LightingDirection = LightingDirection
        self.validate_LightingDirectionType(self.LightingDirection)
        self.LightingControlTypeOccupancy = LightingControlTypeOccupancy
        self.validate_LightingControlTypeOccupancyType(self.LightingControlTypeOccupancy)
        self.LightingControlTypeTimer = LightingControlTypeTimer
        self.validate_LightingControlTypeTimerType(self.LightingControlTypeTimer)
        self.LightingControlTypeDaylighting = LightingControlTypeDaylighting
        self.validate_LightingControlTypeDaylightingType(self.LightingControlTypeDaylighting)
        self.LightingControlTypeManual = LightingControlTypeManual
        self.validate_LightingControlTypeManualType(self.LightingControlTypeManual)
        self.DimmingCapability = DimmingCapability
        self.DaylightingControlSteps = DaylightingControlSteps
        self.PercentPremisesServed = PercentPremisesServed
        self.InstalledPower = InstalledPower
        self.LampPower = LampPower
        self.NumberOfLampsPerLuminaire = NumberOfLampsPerLuminaire
        self.NumberOfLampsPerBallast = NumberOfLampsPerBallast
        self.NumberOfBallastsPerLuminaire = NumberOfBallastsPerLuminaire
        self.NumberOfLuminaires = NumberOfLuminaires
        self.OutsideLighting = OutsideLighting
        self.ReflectorType = ReflectorType
        self.validate_ReflectorTypeType(self.ReflectorType)
        self.LightingEfficacy = LightingEfficacy
        self.WorkPlaneHeight = WorkPlaneHeight
        self.LuminaireHeight = LuminaireHeight
        self.FixtureSpacing = FixtureSpacing
        self.RatedLampLife = RatedLampLife
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.PrimaryFuel = PrimaryFuel
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightingSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightingSystemType.subclass:
            return LightingSystemType.subclass(*args_, **kwargs_)
        else:
            return LightingSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BallastTypeType(self, value):
        # Validate type BallastTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electromagnetic', 'Electronic', 'Integrated', 'Core and Coil', 'F-Can', 'Other', 'No Ballast']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BallastTypeType' % {"value" : value.encode("utf-8")} )
    def validate_InputVoltageType(self, value):
        # Validate type InputVoltageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['120', '208', '240', '277', '347', '480', '120/277 (dual)', '120-277 (universal)', '347-480 (high voltage)', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InputVoltageType' % {"value" : value.encode("utf-8")} )
    def validate_InstallationTypeType(self, value):
        # Validate type InstallationTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Plug-in', 'Recessed', 'Surface', 'Suspended', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InstallationTypeType' % {"value" : value.encode("utf-8")} )
    def validate_LightingDirectionType(self, value):
        # Validate type LightingDirectionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Direct', 'Indirect', 'Direct-Indirect', 'Spotlight', 'Floodlighting', 'Omnidirectional', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LightingDirectionType' % {"value" : value.encode("utf-8")} )
    def validate_LightingControlTypeOccupancyType(self, value):
        # Validate type LightingControlTypeOccupancyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Occupancy Sensors', 'Vacancy Sensors', 'Other', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LightingControlTypeOccupancyType' % {"value" : value.encode("utf-8")} )
    def validate_LightingControlTypeTimerType(self, value):
        # Validate type LightingControlTypeTimerType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Astronomical', 'Chronological', 'Other', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LightingControlTypeTimerType' % {"value" : value.encode("utf-8")} )
    def validate_LightingControlTypeDaylightingType(self, value):
        # Validate type LightingControlTypeDaylightingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Continuous', 'Continuous Plus Off', 'Stepped Dimming', 'Stepped Switching', 'Other', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LightingControlTypeDaylightingType' % {"value" : value.encode("utf-8")} )
    def validate_LightingControlTypeManualType(self, value):
        # Validate type LightingControlTypeManualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Manual On/Off', 'Manual Dimming', 'Bi-level Control', 'Tri-level Control', 'Other', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LightingControlTypeManualType' % {"value" : value.encode("utf-8")} )
    def validate_ReflectorTypeType(self, value):
        # Validate type ReflectorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Specular Reflector', 'Prismatic Reflector', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReflectorTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.LampType is not None or
            self.BallastType is not None or
            self.InputVoltage is not None or
            self.InstallationType is not None or
            self.LightingDirection is not None or
            self.LightingControlTypeOccupancy is not None or
            self.LightingControlTypeTimer is not None or
            self.LightingControlTypeDaylighting is not None or
            self.LightingControlTypeManual is not None or
            self.DimmingCapability is not None or
            self.DaylightingControlSteps is not None or
            self.PercentPremisesServed is not None or
            self.InstalledPower is not None or
            self.LampPower is not None or
            self.NumberOfLampsPerLuminaire is not None or
            self.NumberOfLampsPerBallast is not None or
            self.NumberOfBallastsPerLuminaire is not None or
            self.NumberOfLuminaires is not None or
            self.OutsideLighting is not None or
            self.ReflectorType is not None or
            self.LightingEfficacy is not None or
            self.WorkPlaneHeight is not None or
            self.LuminaireHeight is not None or
            self.FixtureSpacing is not None or
            self.RatedLampLife is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.PrimaryFuel is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightingSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightingSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightingSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightingSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightingSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampType is not None:
            self.LampType.export(outfile, level, namespace_, name_='LampType', pretty_print=pretty_print)
        if self.BallastType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBallastType>%s</%sBallastType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BallastType), input_name='BallastType')), namespace_, eol_))
        if self.InputVoltage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInputVoltage>%s</%sInputVoltage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InputVoltage), input_name='InputVoltage')), namespace_, eol_))
        if self.InstallationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstallationType>%s</%sInstallationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InstallationType), input_name='InstallationType')), namespace_, eol_))
        if self.LightingDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightingDirection>%s</%sLightingDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LightingDirection), input_name='LightingDirection')), namespace_, eol_))
        if self.LightingControlTypeOccupancy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightingControlTypeOccupancy>%s</%sLightingControlTypeOccupancy>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LightingControlTypeOccupancy), input_name='LightingControlTypeOccupancy')), namespace_, eol_))
        if self.LightingControlTypeTimer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightingControlTypeTimer>%s</%sLightingControlTypeTimer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LightingControlTypeTimer), input_name='LightingControlTypeTimer')), namespace_, eol_))
        if self.LightingControlTypeDaylighting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightingControlTypeDaylighting>%s</%sLightingControlTypeDaylighting>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LightingControlTypeDaylighting), input_name='LightingControlTypeDaylighting')), namespace_, eol_))
        if self.LightingControlTypeManual is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightingControlTypeManual>%s</%sLightingControlTypeManual>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LightingControlTypeManual), input_name='LightingControlTypeManual')), namespace_, eol_))
        if self.DimmingCapability is not None:
            self.DimmingCapability.export(outfile, level, namespace_, name_='DimmingCapability', pretty_print=pretty_print)
        if self.DaylightingControlSteps is not None:
            self.DaylightingControlSteps.export(outfile, level, namespace_, name_='DaylightingControlSteps', pretty_print=pretty_print)
        if self.PercentPremisesServed is not None:
            self.PercentPremisesServed.export(outfile, level, namespace_, name_='PercentPremisesServed', pretty_print=pretty_print)
        if self.InstalledPower is not None:
            self.InstalledPower.export(outfile, level, namespace_, name_='InstalledPower', pretty_print=pretty_print)
        if self.LampPower is not None:
            self.LampPower.export(outfile, level, namespace_, name_='LampPower', pretty_print=pretty_print)
        if self.NumberOfLampsPerLuminaire is not None:
            self.NumberOfLampsPerLuminaire.export(outfile, level, namespace_, name_='NumberOfLampsPerLuminaire', pretty_print=pretty_print)
        if self.NumberOfLampsPerBallast is not None:
            self.NumberOfLampsPerBallast.export(outfile, level, namespace_, name_='NumberOfLampsPerBallast', pretty_print=pretty_print)
        if self.NumberOfBallastsPerLuminaire is not None:
            self.NumberOfBallastsPerLuminaire.export(outfile, level, namespace_, name_='NumberOfBallastsPerLuminaire', pretty_print=pretty_print)
        if self.NumberOfLuminaires is not None:
            self.NumberOfLuminaires.export(outfile, level, namespace_, name_='NumberOfLuminaires', pretty_print=pretty_print)
        if self.OutsideLighting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutsideLighting>%s</%sOutsideLighting>%s' % (namespace_, self.gds_format_boolean(self.OutsideLighting, input_name='OutsideLighting'), namespace_, eol_))
        if self.ReflectorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReflectorType>%s</%sReflectorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReflectorType), input_name='ReflectorType')), namespace_, eol_))
        if self.LightingEfficacy is not None:
            self.LightingEfficacy.export(outfile, level, namespace_, name_='LightingEfficacy', pretty_print=pretty_print)
        if self.WorkPlaneHeight is not None:
            self.WorkPlaneHeight.export(outfile, level, namespace_, name_='WorkPlaneHeight', pretty_print=pretty_print)
        if self.LuminaireHeight is not None:
            self.LuminaireHeight.export(outfile, level, namespace_, name_='LuminaireHeight', pretty_print=pretty_print)
        if self.FixtureSpacing is not None:
            self.FixtureSpacing.export(outfile, level, namespace_, name_='FixtureSpacing', pretty_print=pretty_print)
        if self.RatedLampLife is not None:
            self.RatedLampLife.export(outfile, level, namespace_, name_='RatedLampLife', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampType':
            obj_ = LampTypeType.factory()
            obj_.build(child_)
            self.LampType = obj_
            obj_.original_tagname_ = 'LampType'
        elif nodeName_ == 'BallastType':
            BallastType_ = child_.text
            BallastType_ = self.gds_validate_string(BallastType_, node, 'BallastType')
            self.BallastType = BallastType_
            # validate type BallastTypeType
            self.validate_BallastTypeType(self.BallastType)
        elif nodeName_ == 'InputVoltage':
            InputVoltage_ = child_.text
            InputVoltage_ = self.gds_validate_string(InputVoltage_, node, 'InputVoltage')
            self.InputVoltage = InputVoltage_
            # validate type InputVoltageType
            self.validate_InputVoltageType(self.InputVoltage)
        elif nodeName_ == 'InstallationType':
            InstallationType_ = child_.text
            InstallationType_ = self.gds_validate_string(InstallationType_, node, 'InstallationType')
            self.InstallationType = InstallationType_
            # validate type InstallationTypeType
            self.validate_InstallationTypeType(self.InstallationType)
        elif nodeName_ == 'LightingDirection':
            LightingDirection_ = child_.text
            LightingDirection_ = self.gds_validate_string(LightingDirection_, node, 'LightingDirection')
            self.LightingDirection = LightingDirection_
            # validate type LightingDirectionType
            self.validate_LightingDirectionType(self.LightingDirection)
        elif nodeName_ == 'LightingControlTypeOccupancy':
            LightingControlTypeOccupancy_ = child_.text
            LightingControlTypeOccupancy_ = self.gds_validate_string(LightingControlTypeOccupancy_, node, 'LightingControlTypeOccupancy')
            self.LightingControlTypeOccupancy = LightingControlTypeOccupancy_
            # validate type LightingControlTypeOccupancyType
            self.validate_LightingControlTypeOccupancyType(self.LightingControlTypeOccupancy)
        elif nodeName_ == 'LightingControlTypeTimer':
            LightingControlTypeTimer_ = child_.text
            LightingControlTypeTimer_ = self.gds_validate_string(LightingControlTypeTimer_, node, 'LightingControlTypeTimer')
            self.LightingControlTypeTimer = LightingControlTypeTimer_
            # validate type LightingControlTypeTimerType
            self.validate_LightingControlTypeTimerType(self.LightingControlTypeTimer)
        elif nodeName_ == 'LightingControlTypeDaylighting':
            LightingControlTypeDaylighting_ = child_.text
            LightingControlTypeDaylighting_ = self.gds_validate_string(LightingControlTypeDaylighting_, node, 'LightingControlTypeDaylighting')
            self.LightingControlTypeDaylighting = LightingControlTypeDaylighting_
            # validate type LightingControlTypeDaylightingType
            self.validate_LightingControlTypeDaylightingType(self.LightingControlTypeDaylighting)
        elif nodeName_ == 'LightingControlTypeManual':
            LightingControlTypeManual_ = child_.text
            LightingControlTypeManual_ = self.gds_validate_string(LightingControlTypeManual_, node, 'LightingControlTypeManual')
            self.LightingControlTypeManual = LightingControlTypeManual_
            # validate type LightingControlTypeManualType
            self.validate_LightingControlTypeManualType(self.LightingControlTypeManual)
        elif nodeName_ == 'DimmingCapability':
            obj_ = DimmingCapabilityType.factory()
            obj_.build(child_)
            self.DimmingCapability = obj_
            obj_.original_tagname_ = 'DimmingCapability'
        elif nodeName_ == 'DaylightingControlSteps':
            obj_ = DaylightingControlStepsType.factory()
            obj_.build(child_)
            self.DaylightingControlSteps = obj_
            obj_.original_tagname_ = 'DaylightingControlSteps'
        elif nodeName_ == 'PercentPremisesServed':
            obj_ = PercentPremisesServedType.factory()
            obj_.build(child_)
            self.PercentPremisesServed = obj_
            obj_.original_tagname_ = 'PercentPremisesServed'
        elif nodeName_ == 'InstalledPower':
            obj_ = InstalledPowerType.factory()
            obj_.build(child_)
            self.InstalledPower = obj_
            obj_.original_tagname_ = 'InstalledPower'
        elif nodeName_ == 'LampPower':
            obj_ = LampPowerType.factory()
            obj_.build(child_)
            self.LampPower = obj_
            obj_.original_tagname_ = 'LampPower'
        elif nodeName_ == 'NumberOfLampsPerLuminaire':
            obj_ = NumberOfLampsPerLuminaireType.factory()
            obj_.build(child_)
            self.NumberOfLampsPerLuminaire = obj_
            obj_.original_tagname_ = 'NumberOfLampsPerLuminaire'
        elif nodeName_ == 'NumberOfLampsPerBallast':
            obj_ = NumberOfLampsPerBallastType.factory()
            obj_.build(child_)
            self.NumberOfLampsPerBallast = obj_
            obj_.original_tagname_ = 'NumberOfLampsPerBallast'
        elif nodeName_ == 'NumberOfBallastsPerLuminaire':
            obj_ = NumberOfBallastsPerLuminaireType.factory()
            obj_.build(child_)
            self.NumberOfBallastsPerLuminaire = obj_
            obj_.original_tagname_ = 'NumberOfBallastsPerLuminaire'
        elif nodeName_ == 'NumberOfLuminaires':
            obj_ = NumberOfLuminairesType.factory()
            obj_.build(child_)
            self.NumberOfLuminaires = obj_
            obj_.original_tagname_ = 'NumberOfLuminaires'
        elif nodeName_ == 'OutsideLighting':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'OutsideLighting')
            self.OutsideLighting = ival_
        elif nodeName_ == 'ReflectorType':
            ReflectorType_ = child_.text
            ReflectorType_ = self.gds_validate_string(ReflectorType_, node, 'ReflectorType')
            self.ReflectorType = ReflectorType_
            # validate type ReflectorTypeType
            self.validate_ReflectorTypeType(self.ReflectorType)
        elif nodeName_ == 'LightingEfficacy':
            obj_ = LightingEfficacyType.factory()
            obj_.build(child_)
            self.LightingEfficacy = obj_
            obj_.original_tagname_ = 'LightingEfficacy'
        elif nodeName_ == 'WorkPlaneHeight':
            obj_ = WorkPlaneHeightType.factory()
            obj_.build(child_)
            self.WorkPlaneHeight = obj_
            obj_.original_tagname_ = 'WorkPlaneHeight'
        elif nodeName_ == 'LuminaireHeight':
            obj_ = LuminaireHeightType.factory()
            obj_.build(child_)
            self.LuminaireHeight = obj_
            obj_.original_tagname_ = 'LuminaireHeight'
        elif nodeName_ == 'FixtureSpacing':
            obj_ = FixtureSpacingType.factory()
            obj_.build(child_)
            self.FixtureSpacing = obj_
            obj_.original_tagname_ = 'FixtureSpacing'
        elif nodeName_ == 'RatedLampLife':
            obj_ = RatedLampLifeType.factory()
            obj_.build(child_)
            self.RatedLampLife = obj_
            obj_.original_tagname_ = 'RatedLampLife'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class LightingSystemType


class DomesticHotWaterSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, DomesticHotWaterType=None, Recirculation=None, HotWaterDistributionType=None, WaterHeaterEfficiencyType=None, WaterHeaterEfficiency=None, DailyHotWaterDraw=None, HotWaterSetpointTemperature=None, ParasiticFuelConsumptionRate=None, Capacity=None, CapacityUnits=None, ThirdPartyCertification=None, ControlTechnology=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.DomesticHotWaterType = DomesticHotWaterType
        self.Recirculation = Recirculation
        self.HotWaterDistributionType = HotWaterDistributionType
        self.validate_HotWaterDistributionTypeType(self.HotWaterDistributionType)
        self.WaterHeaterEfficiencyType = WaterHeaterEfficiencyType
        self.validate_WaterHeaterEfficiencyTypeType(self.WaterHeaterEfficiencyType)
        self.WaterHeaterEfficiency = WaterHeaterEfficiency
        self.DailyHotWaterDraw = DailyHotWaterDraw
        self.HotWaterSetpointTemperature = HotWaterSetpointTemperature
        self.ParasiticFuelConsumptionRate = ParasiticFuelConsumptionRate
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomesticHotWaterSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomesticHotWaterSystemType.subclass:
            return DomesticHotWaterSystemType.subclass(*args_, **kwargs_)
        else:
            return DomesticHotWaterSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HotWaterDistributionTypeType(self, value):
        # Validate type HotWaterDistributionTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Looped', 'Distributed', 'Point-of-use', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HotWaterDistributionTypeType' % {"value" : value.encode("utf-8")} )
    def validate_WaterHeaterEfficiencyTypeType(self, value):
        # Validate type WaterHeaterEfficiencyTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Energy Factor', 'Thermal Efficiency']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WaterHeaterEfficiencyTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DomesticHotWaterType is not None or
            self.Recirculation is not None or
            self.HotWaterDistributionType is not None or
            self.WaterHeaterEfficiencyType is not None or
            self.WaterHeaterEfficiency is not None or
            self.DailyHotWaterDraw is not None or
            self.HotWaterSetpointTemperature is not None or
            self.ParasiticFuelConsumptionRate is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.ThirdPartyCertification is not None or
            self.ControlTechnology is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomesticHotWaterSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DomesticHotWaterSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DomesticHotWaterSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DomesticHotWaterType is not None:
            self.DomesticHotWaterType.export(outfile, level, namespace_, name_='DomesticHotWaterType', pretty_print=pretty_print)
        if self.Recirculation is not None:
            self.Recirculation.export(outfile, level, namespace_, name_='Recirculation', pretty_print=pretty_print)
        if self.HotWaterDistributionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHotWaterDistributionType>%s</%sHotWaterDistributionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HotWaterDistributionType), input_name='HotWaterDistributionType')), namespace_, eol_))
        if self.WaterHeaterEfficiencyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterHeaterEfficiencyType>%s</%sWaterHeaterEfficiencyType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterHeaterEfficiencyType), input_name='WaterHeaterEfficiencyType')), namespace_, eol_))
        if self.WaterHeaterEfficiency is not None:
            self.WaterHeaterEfficiency.export(outfile, level, namespace_, name_='WaterHeaterEfficiency', pretty_print=pretty_print)
        if self.DailyHotWaterDraw is not None:
            self.DailyHotWaterDraw.export(outfile, level, namespace_, name_='DailyHotWaterDraw', pretty_print=pretty_print)
        if self.HotWaterSetpointTemperature is not None:
            self.HotWaterSetpointTemperature.export(outfile, level, namespace_, name_='HotWaterSetpointTemperature', pretty_print=pretty_print)
        if self.ParasiticFuelConsumptionRate is not None:
            self.ParasiticFuelConsumptionRate.export(outfile, level, namespace_, name_='ParasiticFuelConsumptionRate', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DomesticHotWaterType':
            obj_ = DomesticHotWaterTypeType.factory()
            obj_.build(child_)
            self.DomesticHotWaterType = obj_
            obj_.original_tagname_ = 'DomesticHotWaterType'
        elif nodeName_ == 'Recirculation':
            obj_ = RecirculationType.factory()
            obj_.build(child_)
            self.Recirculation = obj_
            obj_.original_tagname_ = 'Recirculation'
        elif nodeName_ == 'HotWaterDistributionType':
            HotWaterDistributionType_ = child_.text
            HotWaterDistributionType_ = self.gds_validate_string(HotWaterDistributionType_, node, 'HotWaterDistributionType')
            self.HotWaterDistributionType = HotWaterDistributionType_
            # validate type HotWaterDistributionTypeType
            self.validate_HotWaterDistributionTypeType(self.HotWaterDistributionType)
        elif nodeName_ == 'WaterHeaterEfficiencyType':
            WaterHeaterEfficiencyType_ = child_.text
            WaterHeaterEfficiencyType_ = self.gds_validate_string(WaterHeaterEfficiencyType_, node, 'WaterHeaterEfficiencyType')
            self.WaterHeaterEfficiencyType = WaterHeaterEfficiencyType_
            # validate type WaterHeaterEfficiencyTypeType
            self.validate_WaterHeaterEfficiencyTypeType(self.WaterHeaterEfficiencyType)
        elif nodeName_ == 'WaterHeaterEfficiency':
            obj_ = WaterHeaterEfficiencyType174.factory()
            obj_.build(child_)
            self.WaterHeaterEfficiency = obj_
            obj_.original_tagname_ = 'WaterHeaterEfficiency'
        elif nodeName_ == 'DailyHotWaterDraw':
            obj_ = DailyHotWaterDrawType.factory()
            obj_.build(child_)
            self.DailyHotWaterDraw = obj_
            obj_.original_tagname_ = 'DailyHotWaterDraw'
        elif nodeName_ == 'HotWaterSetpointTemperature':
            obj_ = HotWaterSetpointTemperatureType.factory()
            obj_.build(child_)
            self.HotWaterSetpointTemperature = obj_
            obj_.original_tagname_ = 'HotWaterSetpointTemperature'
        elif nodeName_ == 'ParasiticFuelConsumptionRate':
            obj_ = ParasiticFuelConsumptionRateType.factory()
            obj_.build(child_)
            self.ParasiticFuelConsumptionRate = obj_
            obj_.original_tagname_ = 'ParasiticFuelConsumptionRate'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class DomesticHotWaterSystemType


class CookingSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, TypeOfCookingEquipment=None, NumberOfMeals=None, CookingEnergyPerMeal=None, DailyWaterUse=None, Capacity=None, CapacityUnits=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.TypeOfCookingEquipment = TypeOfCookingEquipment
        self.validate_TypeOfCookingEquipmentType(self.TypeOfCookingEquipment)
        self.NumberOfMeals = NumberOfMeals
        self.CookingEnergyPerMeal = CookingEnergyPerMeal
        self.DailyWaterUse = DailyWaterUse
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CookingSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CookingSystemType.subclass:
            return CookingSystemType.subclass(*args_, **kwargs_)
        else:
            return CookingSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TypeOfCookingEquipmentType(self, value):
        # Validate type TypeOfCookingEquipmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hot top range', 'Open burner range', 'Wok range', 'Braising pan', 'Underfired broiler', 'Overfired broiler', 'Conveyor broiler', 'Salamander broiler', 'Broiler', 'Microwave oven', 'Toaster', 'Standard fryer', 'Large vat fryer', 'Split vat fryer', 'Convection oven', 'Combination oven', 'Standard oven', 'Conveyor oven', 'Slow cook-and-hold oven', 'Deck oven', 'Mini-Rack oven', 'Rack (Roll-In) oven', 'Range oven', 'Rapid cook oven', 'Rotisserie oven', 'Retherm oven', 'Convection toaster oven', 'Steam cooker', 'Steam kettle', 'Drawer warmer', 'Heated transparent merchandising cabinets', 'Cook-and-hold appliance', 'Proofing cabinet', 'Single-sided griddle', 'Double-sided griddle', 'Griddle', 'Fry-top griddle', 'Automatic drip filter coffee maker', 'Single-serve coffee maker', 'Espresso machine', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TypeOfCookingEquipmentType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TypeOfCookingEquipment is not None or
            self.NumberOfMeals is not None or
            self.CookingEnergyPerMeal is not None or
            self.DailyWaterUse is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CookingSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CookingSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CookingSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CookingSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CookingSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TypeOfCookingEquipment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeOfCookingEquipment>%s</%sTypeOfCookingEquipment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TypeOfCookingEquipment), input_name='TypeOfCookingEquipment')), namespace_, eol_))
        if self.NumberOfMeals is not None:
            self.NumberOfMeals.export(outfile, level, namespace_, name_='NumberOfMeals', pretty_print=pretty_print)
        if self.CookingEnergyPerMeal is not None:
            self.CookingEnergyPerMeal.export(outfile, level, namespace_, name_='CookingEnergyPerMeal', pretty_print=pretty_print)
        if self.DailyWaterUse is not None:
            self.DailyWaterUse.export(outfile, level, namespace_, name_='DailyWaterUse', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TypeOfCookingEquipment':
            TypeOfCookingEquipment_ = child_.text
            TypeOfCookingEquipment_ = self.gds_validate_string(TypeOfCookingEquipment_, node, 'TypeOfCookingEquipment')
            self.TypeOfCookingEquipment = TypeOfCookingEquipment_
            # validate type TypeOfCookingEquipmentType
            self.validate_TypeOfCookingEquipmentType(self.TypeOfCookingEquipment)
        elif nodeName_ == 'NumberOfMeals':
            obj_ = NumberOfMealsType.factory()
            obj_.build(child_)
            self.NumberOfMeals = obj_
            obj_.original_tagname_ = 'NumberOfMeals'
        elif nodeName_ == 'CookingEnergyPerMeal':
            obj_ = CookingEnergyPerMealType.factory()
            obj_.build(child_)
            self.CookingEnergyPerMeal = obj_
            obj_.original_tagname_ = 'CookingEnergyPerMeal'
        elif nodeName_ == 'DailyWaterUse':
            obj_ = DailyWaterUseType.factory()
            obj_.build(child_)
            self.DailyWaterUse = obj_
            obj_.original_tagname_ = 'DailyWaterUse'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class CookingSystemType


class RefrigerationSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, RefrigerationSystemCategory=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.RefrigerationSystemCategory = RefrigerationSystemCategory
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationSystemType.subclass:
            return RefrigerationSystemType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RefrigerationSystemCategory is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RefrigerationSystemCategory is not None:
            self.RefrigerationSystemCategory.export(outfile, level, namespace_, name_='RefrigerationSystemCategory', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RefrigerationSystemCategory':
            obj_ = RefrigerationSystemCategoryType.factory()
            obj_.build(child_)
            self.RefrigerationSystemCategory = obj_
            obj_.original_tagname_ = 'RefrigerationSystemCategory'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class RefrigerationSystemType


class DishwasherSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, DishwasherMachineType=None, DishwasherConfiguration=None, DishwasherClassification=None, DishwasherLoadsPerWeek=None, DishwasherEnergyFactor=None, DishwasherHotWaterUse=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.DishwasherMachineType = DishwasherMachineType
        self.validate_DishwasherMachineTypeType(self.DishwasherMachineType)
        self.DishwasherConfiguration = DishwasherConfiguration
        self.validate_DishwasherConfigurationType(self.DishwasherConfiguration)
        self.DishwasherClassification = DishwasherClassification
        self.validate_DishwasherClassificationType(self.DishwasherClassification)
        self.DishwasherLoadsPerWeek = DishwasherLoadsPerWeek
        self.DishwasherEnergyFactor = DishwasherEnergyFactor
        self.DishwasherHotWaterUse = DishwasherHotWaterUse
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DishwasherSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DishwasherSystemType.subclass:
            return DishwasherSystemType.subclass(*args_, **kwargs_)
        else:
            return DishwasherSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DishwasherMachineTypeType(self, value):
        # Validate type DishwasherMachineTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Stationary Rack Machine', 'Conveyor Machine', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DishwasherMachineTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DishwasherConfigurationType(self, value):
        # Validate type DishwasherConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Counter-top', 'Stationary Under Counter', 'Stationary Single Tank Door Type', 'Stationary Pot-pan-utensil', 'Stationary glasswashing', 'Single Tank Conveyor', 'Multiple Tank Conveyor', 'Single Tank Flight Conveyor', 'Multiple Tank Flight Conveyor', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DishwasherConfigurationType' % {"value" : value.encode("utf-8")} )
    def validate_DishwasherClassificationType(self, value):
        # Validate type DishwasherClassificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Industrial', 'Commercial', 'Residential', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DishwasherClassificationType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DishwasherMachineType is not None or
            self.DishwasherConfiguration is not None or
            self.DishwasherClassification is not None or
            self.DishwasherLoadsPerWeek is not None or
            self.DishwasherEnergyFactor is not None or
            self.DishwasherHotWaterUse is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DishwasherSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DishwasherSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DishwasherSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DishwasherSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DishwasherSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DishwasherMachineType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDishwasherMachineType>%s</%sDishwasherMachineType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DishwasherMachineType), input_name='DishwasherMachineType')), namespace_, eol_))
        if self.DishwasherConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDishwasherConfiguration>%s</%sDishwasherConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DishwasherConfiguration), input_name='DishwasherConfiguration')), namespace_, eol_))
        if self.DishwasherClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDishwasherClassification>%s</%sDishwasherClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DishwasherClassification), input_name='DishwasherClassification')), namespace_, eol_))
        if self.DishwasherLoadsPerWeek is not None:
            self.DishwasherLoadsPerWeek.export(outfile, level, namespace_, name_='DishwasherLoadsPerWeek', pretty_print=pretty_print)
        if self.DishwasherEnergyFactor is not None:
            self.DishwasherEnergyFactor.export(outfile, level, namespace_, name_='DishwasherEnergyFactor', pretty_print=pretty_print)
        if self.DishwasherHotWaterUse is not None:
            self.DishwasherHotWaterUse.export(outfile, level, namespace_, name_='DishwasherHotWaterUse', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DishwasherMachineType':
            DishwasherMachineType_ = child_.text
            DishwasherMachineType_ = self.gds_validate_string(DishwasherMachineType_, node, 'DishwasherMachineType')
            self.DishwasherMachineType = DishwasherMachineType_
            # validate type DishwasherMachineTypeType
            self.validate_DishwasherMachineTypeType(self.DishwasherMachineType)
        elif nodeName_ == 'DishwasherConfiguration':
            DishwasherConfiguration_ = child_.text
            DishwasherConfiguration_ = self.gds_validate_string(DishwasherConfiguration_, node, 'DishwasherConfiguration')
            self.DishwasherConfiguration = DishwasherConfiguration_
            # validate type DishwasherConfigurationType
            self.validate_DishwasherConfigurationType(self.DishwasherConfiguration)
        elif nodeName_ == 'DishwasherClassification':
            DishwasherClassification_ = child_.text
            DishwasherClassification_ = self.gds_validate_string(DishwasherClassification_, node, 'DishwasherClassification')
            self.DishwasherClassification = DishwasherClassification_
            # validate type DishwasherClassificationType
            self.validate_DishwasherClassificationType(self.DishwasherClassification)
        elif nodeName_ == 'DishwasherLoadsPerWeek':
            obj_ = DishwasherLoadsPerWeekType.factory()
            obj_.build(child_)
            self.DishwasherLoadsPerWeek = obj_
            obj_.original_tagname_ = 'DishwasherLoadsPerWeek'
        elif nodeName_ == 'DishwasherEnergyFactor':
            obj_ = DishwasherEnergyFactorType.factory()
            obj_.build(child_)
            self.DishwasherEnergyFactor = obj_
            obj_.original_tagname_ = 'DishwasherEnergyFactor'
        elif nodeName_ == 'DishwasherHotWaterUse':
            obj_ = DishwasherHotWaterUseType.factory()
            obj_.build(child_)
            self.DishwasherHotWaterUse = obj_
            obj_.original_tagname_ = 'DishwasherHotWaterUse'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class DishwasherSystemType


class LaundrySystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, LaundryType=None, QuantityOfLaundry=None, LaundryEquipmentUsage=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.LaundryType = LaundryType
        self.QuantityOfLaundry = QuantityOfLaundry
        self.LaundryEquipmentUsage = LaundryEquipmentUsage
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LaundrySystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LaundrySystemType.subclass:
            return LaundrySystemType.subclass(*args_, **kwargs_)
        else:
            return LaundrySystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.LaundryType is not None or
            self.QuantityOfLaundry is not None or
            self.LaundryEquipmentUsage is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LaundrySystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LaundrySystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LaundrySystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LaundrySystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LaundrySystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LaundryType is not None:
            self.LaundryType.export(outfile, level, namespace_, name_='LaundryType', pretty_print=pretty_print)
        if self.QuantityOfLaundry is not None:
            self.QuantityOfLaundry.export(outfile, level, namespace_, name_='QuantityOfLaundry', pretty_print=pretty_print)
        if self.LaundryEquipmentUsage is not None:
            self.LaundryEquipmentUsage.export(outfile, level, namespace_, name_='LaundryEquipmentUsage', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LaundryType':
            obj_ = LaundryTypeType.factory()
            obj_.build(child_)
            self.LaundryType = obj_
            obj_.original_tagname_ = 'LaundryType'
        elif nodeName_ == 'QuantityOfLaundry':
            obj_ = QuantityOfLaundryType.factory()
            obj_.build(child_)
            self.QuantityOfLaundry = obj_
            obj_.original_tagname_ = 'QuantityOfLaundry'
        elif nodeName_ == 'LaundryEquipmentUsage':
            obj_ = LaundryEquipmentUsageType.factory()
            obj_.build(child_)
            self.LaundryEquipmentUsage = obj_
            obj_.original_tagname_ = 'LaundryEquipmentUsage'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class LaundrySystemType


class PumpSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, PumpEfficiency=None, PumpMaximumFlowRate=None, PumpMinimumFlowRate=None, PumpInstalledFlowRate=None, PumpPowerDemand=None, PumpControlType=None, PumpOperation=None, PumpingConfiguration=None, PumpApplication=None, ControlTechnology=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedSystemID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.PumpEfficiency = PumpEfficiency
        self.PumpMaximumFlowRate = PumpMaximumFlowRate
        self.PumpMinimumFlowRate = PumpMinimumFlowRate
        self.PumpInstalledFlowRate = PumpInstalledFlowRate
        self.PumpPowerDemand = PumpPowerDemand
        self.PumpControlType = PumpControlType
        self.validate_PumpControlTypeType(self.PumpControlType)
        self.PumpOperation = PumpOperation
        self.validate_PumpOperationType(self.PumpOperation)
        self.PumpingConfiguration = PumpingConfiguration
        self.validate_PumpingConfigurationType(self.PumpingConfiguration)
        self.PumpApplication = PumpApplication
        self.validate_PumpApplicationType(self.PumpApplication)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        if LinkedSystemID is None:
            self.LinkedSystemID = []
        else:
            self.LinkedSystemID = LinkedSystemID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpSystemType.subclass:
            return PumpSystemType.subclass(*args_, **kwargs_)
        else:
            return PumpSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PumpControlTypeType(self, value):
        # Validate type PumpControlTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Constant Volume', 'Variable Volume', 'VFD', 'Multi-Speed', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PumpControlTypeType' % {"value" : value.encode("utf-8")} )
    def validate_PumpOperationType(self, value):
        # Validate type PumpOperationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['On Demand', 'Standby', 'Schedule', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PumpOperationType' % {"value" : value.encode("utf-8")} )
    def validate_PumpingConfigurationType(self, value):
        # Validate type PumpingConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Primary', 'Secondary', 'Tertiary', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PumpingConfigurationType' % {"value" : value.encode("utf-8")} )
    def validate_PumpApplicationType(self, value):
        # Validate type PumpApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Boiler', 'Chilled Water', 'Domestic Hot Water', 'Solar Hot Water', 'Condenser', 'Cooling Tower', 'Ground Loop', 'Pool', 'Recirculation', 'Process Hot Water', 'Process Cold Water', 'Potable Cold Water', 'Refrigerant', 'Air', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PumpApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PumpEfficiency is not None or
            self.PumpMaximumFlowRate is not None or
            self.PumpMinimumFlowRate is not None or
            self.PumpInstalledFlowRate is not None or
            self.PumpPowerDemand is not None or
            self.PumpControlType is not None or
            self.PumpOperation is not None or
            self.PumpingConfiguration is not None or
            self.PumpApplication is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedSystemID or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PumpEfficiency is not None:
            self.PumpEfficiency.export(outfile, level, namespace_, name_='PumpEfficiency', pretty_print=pretty_print)
        if self.PumpMaximumFlowRate is not None:
            self.PumpMaximumFlowRate.export(outfile, level, namespace_, name_='PumpMaximumFlowRate', pretty_print=pretty_print)
        if self.PumpMinimumFlowRate is not None:
            self.PumpMinimumFlowRate.export(outfile, level, namespace_, name_='PumpMinimumFlowRate', pretty_print=pretty_print)
        if self.PumpInstalledFlowRate is not None:
            self.PumpInstalledFlowRate.export(outfile, level, namespace_, name_='PumpInstalledFlowRate', pretty_print=pretty_print)
        if self.PumpPowerDemand is not None:
            self.PumpPowerDemand.export(outfile, level, namespace_, name_='PumpPowerDemand', pretty_print=pretty_print)
        if self.PumpControlType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpControlType>%s</%sPumpControlType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpControlType), input_name='PumpControlType')), namespace_, eol_))
        if self.PumpOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpOperation>%s</%sPumpOperation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpOperation), input_name='PumpOperation')), namespace_, eol_))
        if self.PumpingConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpingConfiguration>%s</%sPumpingConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpingConfiguration), input_name='PumpingConfiguration')), namespace_, eol_))
        if self.PumpApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPumpApplication>%s</%sPumpApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PumpApplication), input_name='PumpApplication')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        for LinkedSystemID_ in self.LinkedSystemID:
            LinkedSystemID_.export(outfile, level, namespace_, name_='LinkedSystemID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PumpEfficiency':
            obj_ = PumpEfficiencyType.factory()
            obj_.build(child_)
            self.PumpEfficiency = obj_
            obj_.original_tagname_ = 'PumpEfficiency'
        elif nodeName_ == 'PumpMaximumFlowRate':
            obj_ = PumpMaximumFlowRateType.factory()
            obj_.build(child_)
            self.PumpMaximumFlowRate = obj_
            obj_.original_tagname_ = 'PumpMaximumFlowRate'
        elif nodeName_ == 'PumpMinimumFlowRate':
            obj_ = PumpMinimumFlowRateType.factory()
            obj_.build(child_)
            self.PumpMinimumFlowRate = obj_
            obj_.original_tagname_ = 'PumpMinimumFlowRate'
        elif nodeName_ == 'PumpInstalledFlowRate':
            obj_ = PumpInstalledFlowRateType.factory()
            obj_.build(child_)
            self.PumpInstalledFlowRate = obj_
            obj_.original_tagname_ = 'PumpInstalledFlowRate'
        elif nodeName_ == 'PumpPowerDemand':
            obj_ = PumpPowerDemandType.factory()
            obj_.build(child_)
            self.PumpPowerDemand = obj_
            obj_.original_tagname_ = 'PumpPowerDemand'
        elif nodeName_ == 'PumpControlType':
            PumpControlType_ = child_.text
            PumpControlType_ = self.gds_validate_string(PumpControlType_, node, 'PumpControlType')
            self.PumpControlType = PumpControlType_
            # validate type PumpControlTypeType
            self.validate_PumpControlTypeType(self.PumpControlType)
        elif nodeName_ == 'PumpOperation':
            PumpOperation_ = child_.text
            PumpOperation_ = self.gds_validate_string(PumpOperation_, node, 'PumpOperation')
            self.PumpOperation = PumpOperation_
            # validate type PumpOperationType
            self.validate_PumpOperationType(self.PumpOperation)
        elif nodeName_ == 'PumpingConfiguration':
            PumpingConfiguration_ = child_.text
            PumpingConfiguration_ = self.gds_validate_string(PumpingConfiguration_, node, 'PumpingConfiguration')
            self.PumpingConfiguration = PumpingConfiguration_
            # validate type PumpingConfigurationType
            self.validate_PumpingConfigurationType(self.PumpingConfiguration)
        elif nodeName_ == 'PumpApplication':
            PumpApplication_ = child_.text
            PumpApplication_ = self.gds_validate_string(PumpApplication_, node, 'PumpApplication')
            self.PumpApplication = PumpApplication_
            # validate type PumpApplicationType
            self.validate_PumpApplicationType(self.PumpApplication)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedSystemID':
            obj_ = LinkedSystemIDType.factory()
            obj_.build(child_)
            self.LinkedSystemID.append(obj_)
            obj_.original_tagname_ = 'LinkedSystemID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class PumpSystemType


class FanSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, FanEfficiency=None, FanSize=None, InstalledFlowRate=None, MinimumFlowRate=None, MaximumFanPower=None, FanPowerMinimumRatio=None, FanType=None, BeltType=None, FanApplication=None, FanControlType=None, FanPlacement=None, MotorLocationRelativeToAirStream=None, DesignStaticPressure=None, NumberOfDiscreteFanSpeedsCooling=None, NumberOfDiscreteFanSpeedsHeating=None, ControlTechnology=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedSystemID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.FanEfficiency = FanEfficiency
        self.FanSize = FanSize
        self.InstalledFlowRate = InstalledFlowRate
        self.MinimumFlowRate = MinimumFlowRate
        self.MaximumFanPower = MaximumFanPower
        self.FanPowerMinimumRatio = FanPowerMinimumRatio
        self.FanType = FanType
        self.validate_FanTypeType(self.FanType)
        self.BeltType = BeltType
        self.validate_BeltTypeType(self.BeltType)
        self.FanApplication = FanApplication
        self.validate_FanApplicationType(self.FanApplication)
        self.FanControlType = FanControlType
        self.validate_FanControlTypeType(self.FanControlType)
        self.FanPlacement = FanPlacement
        self.validate_FanPlacementType(self.FanPlacement)
        self.MotorLocationRelativeToAirStream = MotorLocationRelativeToAirStream
        self.DesignStaticPressure = DesignStaticPressure
        self.NumberOfDiscreteFanSpeedsCooling = NumberOfDiscreteFanSpeedsCooling
        self.NumberOfDiscreteFanSpeedsHeating = NumberOfDiscreteFanSpeedsHeating
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        if LinkedSystemID is None:
            self.LinkedSystemID = []
        else:
            self.LinkedSystemID = LinkedSystemID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanSystemType.subclass:
            return FanSystemType.subclass(*args_, **kwargs_)
        else:
            return FanSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FanTypeType(self, value):
        # Validate type FanTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Axial', 'Centrifugal', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FanTypeType' % {"value" : value.encode("utf-8")} )
    def validate_BeltTypeType(self, value):
        # Validate type BeltTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Direct drive', 'Standard belt', 'Cogged belt', 'Synchronous belts', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BeltTypeType' % {"value" : value.encode("utf-8")} )
    def validate_FanApplicationType(self, value):
        # Validate type FanApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Supply', 'Return', 'Exhaust', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FanApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_FanControlTypeType(self, value):
        # Validate type FanControlTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Variable Volume', 'Stepped', 'Constant Volume', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FanControlTypeType' % {"value" : value.encode("utf-8")} )
    def validate_FanPlacementType(self, value):
        # Validate type FanPlacementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Series', 'Parallel', 'Draw Through', 'Blow Through', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FanPlacementType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FanEfficiency is not None or
            self.FanSize is not None or
            self.InstalledFlowRate is not None or
            self.MinimumFlowRate is not None or
            self.MaximumFanPower is not None or
            self.FanPowerMinimumRatio is not None or
            self.FanType is not None or
            self.BeltType is not None or
            self.FanApplication is not None or
            self.FanControlType is not None or
            self.FanPlacement is not None or
            self.MotorLocationRelativeToAirStream is not None or
            self.DesignStaticPressure is not None or
            self.NumberOfDiscreteFanSpeedsCooling is not None or
            self.NumberOfDiscreteFanSpeedsHeating is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedSystemID or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FanEfficiency is not None:
            self.FanEfficiency.export(outfile, level, namespace_, name_='FanEfficiency', pretty_print=pretty_print)
        if self.FanSize is not None:
            self.FanSize.export(outfile, level, namespace_, name_='FanSize', pretty_print=pretty_print)
        if self.InstalledFlowRate is not None:
            self.InstalledFlowRate.export(outfile, level, namespace_, name_='InstalledFlowRate', pretty_print=pretty_print)
        if self.MinimumFlowRate is not None:
            self.MinimumFlowRate.export(outfile, level, namespace_, name_='MinimumFlowRate', pretty_print=pretty_print)
        if self.MaximumFanPower is not None:
            self.MaximumFanPower.export(outfile, level, namespace_, name_='MaximumFanPower', pretty_print=pretty_print)
        if self.FanPowerMinimumRatio is not None:
            self.FanPowerMinimumRatio.export(outfile, level, namespace_, name_='FanPowerMinimumRatio', pretty_print=pretty_print)
        if self.FanType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFanType>%s</%sFanType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FanType), input_name='FanType')), namespace_, eol_))
        if self.BeltType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBeltType>%s</%sBeltType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BeltType), input_name='BeltType')), namespace_, eol_))
        if self.FanApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFanApplication>%s</%sFanApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FanApplication), input_name='FanApplication')), namespace_, eol_))
        if self.FanControlType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFanControlType>%s</%sFanControlType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FanControlType), input_name='FanControlType')), namespace_, eol_))
        if self.FanPlacement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFanPlacement>%s</%sFanPlacement>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FanPlacement), input_name='FanPlacement')), namespace_, eol_))
        if self.MotorLocationRelativeToAirStream is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMotorLocationRelativeToAirStream>%s</%sMotorLocationRelativeToAirStream>%s' % (namespace_, self.gds_format_boolean(self.MotorLocationRelativeToAirStream, input_name='MotorLocationRelativeToAirStream'), namespace_, eol_))
        if self.DesignStaticPressure is not None:
            self.DesignStaticPressure.export(outfile, level, namespace_, name_='DesignStaticPressure', pretty_print=pretty_print)
        if self.NumberOfDiscreteFanSpeedsCooling is not None:
            self.NumberOfDiscreteFanSpeedsCooling.export(outfile, level, namespace_, name_='NumberOfDiscreteFanSpeedsCooling', pretty_print=pretty_print)
        if self.NumberOfDiscreteFanSpeedsHeating is not None:
            self.NumberOfDiscreteFanSpeedsHeating.export(outfile, level, namespace_, name_='NumberOfDiscreteFanSpeedsHeating', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        for LinkedSystemID_ in self.LinkedSystemID:
            LinkedSystemID_.export(outfile, level, namespace_, name_='LinkedSystemID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FanEfficiency':
            obj_ = FanEfficiencyType.factory()
            obj_.build(child_)
            self.FanEfficiency = obj_
            obj_.original_tagname_ = 'FanEfficiency'
        elif nodeName_ == 'FanSize':
            obj_ = FanSizeType.factory()
            obj_.build(child_)
            self.FanSize = obj_
            obj_.original_tagname_ = 'FanSize'
        elif nodeName_ == 'InstalledFlowRate':
            obj_ = InstalledFlowRateType.factory()
            obj_.build(child_)
            self.InstalledFlowRate = obj_
            obj_.original_tagname_ = 'InstalledFlowRate'
        elif nodeName_ == 'MinimumFlowRate':
            obj_ = MinimumFlowRateType.factory()
            obj_.build(child_)
            self.MinimumFlowRate = obj_
            obj_.original_tagname_ = 'MinimumFlowRate'
        elif nodeName_ == 'MaximumFanPower':
            obj_ = MaximumFanPowerType.factory()
            obj_.build(child_)
            self.MaximumFanPower = obj_
            obj_.original_tagname_ = 'MaximumFanPower'
        elif nodeName_ == 'FanPowerMinimumRatio':
            obj_ = FanPowerMinimumRatioType.factory()
            obj_.build(child_)
            self.FanPowerMinimumRatio = obj_
            obj_.original_tagname_ = 'FanPowerMinimumRatio'
        elif nodeName_ == 'FanType':
            FanType_ = child_.text
            FanType_ = self.gds_validate_string(FanType_, node, 'FanType')
            self.FanType = FanType_
            # validate type FanTypeType
            self.validate_FanTypeType(self.FanType)
        elif nodeName_ == 'BeltType':
            BeltType_ = child_.text
            BeltType_ = self.gds_validate_string(BeltType_, node, 'BeltType')
            self.BeltType = BeltType_
            # validate type BeltTypeType
            self.validate_BeltTypeType(self.BeltType)
        elif nodeName_ == 'FanApplication':
            FanApplication_ = child_.text
            FanApplication_ = self.gds_validate_string(FanApplication_, node, 'FanApplication')
            self.FanApplication = FanApplication_
            # validate type FanApplicationType
            self.validate_FanApplicationType(self.FanApplication)
        elif nodeName_ == 'FanControlType':
            FanControlType_ = child_.text
            FanControlType_ = self.gds_validate_string(FanControlType_, node, 'FanControlType')
            self.FanControlType = FanControlType_
            # validate type FanControlTypeType
            self.validate_FanControlTypeType(self.FanControlType)
        elif nodeName_ == 'FanPlacement':
            FanPlacement_ = child_.text
            FanPlacement_ = self.gds_validate_string(FanPlacement_, node, 'FanPlacement')
            self.FanPlacement = FanPlacement_
            # validate type FanPlacementType
            self.validate_FanPlacementType(self.FanPlacement)
        elif nodeName_ == 'MotorLocationRelativeToAirStream':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MotorLocationRelativeToAirStream')
            self.MotorLocationRelativeToAirStream = ival_
        elif nodeName_ == 'DesignStaticPressure':
            obj_ = DesignStaticPressureType.factory()
            obj_.build(child_)
            self.DesignStaticPressure = obj_
            obj_.original_tagname_ = 'DesignStaticPressure'
        elif nodeName_ == 'NumberOfDiscreteFanSpeedsCooling':
            obj_ = NumberOfDiscreteFanSpeedsCoolingType.factory()
            obj_.build(child_)
            self.NumberOfDiscreteFanSpeedsCooling = obj_
            obj_.original_tagname_ = 'NumberOfDiscreteFanSpeedsCooling'
        elif nodeName_ == 'NumberOfDiscreteFanSpeedsHeating':
            obj_ = NumberOfDiscreteFanSpeedsHeatingType.factory()
            obj_.build(child_)
            self.NumberOfDiscreteFanSpeedsHeating = obj_
            obj_.original_tagname_ = 'NumberOfDiscreteFanSpeedsHeating'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedSystemID':
            obj_ = LinkedSystemIDType187.factory()
            obj_.build(child_)
            self.LinkedSystemID.append(obj_)
            obj_.original_tagname_ = 'LinkedSystemID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class FanSystemType


class MotorSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, MotorRPM=None, MotorBrakeHP=None, MotorHP=None, MotorEfficiency=None, DriveEfficiency=None, FullLoadAmps=None, MotorPoleCount=None, MotorEnclosureType=None, MotorApplication=None, ControlTechnology=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedSystemID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.MotorRPM = MotorRPM
        self.MotorBrakeHP = MotorBrakeHP
        self.MotorHP = MotorHP
        self.MotorEfficiency = MotorEfficiency
        self.DriveEfficiency = DriveEfficiency
        self.FullLoadAmps = FullLoadAmps
        self.MotorPoleCount = MotorPoleCount
        self.MotorEnclosureType = MotorEnclosureType
        self.validate_MotorEnclosureTypeType(self.MotorEnclosureType)
        self.MotorApplication = MotorApplication
        self.validate_MotorApplicationType(self.MotorApplication)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        if LinkedSystemID is None:
            self.LinkedSystemID = []
        else:
            self.LinkedSystemID = LinkedSystemID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorSystemType.subclass:
            return MotorSystemType.subclass(*args_, **kwargs_)
        else:
            return MotorSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MotorEnclosureTypeType(self, value):
        # Validate type MotorEnclosureTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Open', 'Enclosed', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MotorEnclosureTypeType' % {"value" : value.encode("utf-8")} )
    def validate_MotorApplicationType(self, value):
        # Validate type MotorApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fan', 'Pump', 'Conveyance', 'Plug Load', 'Process Load', 'Compressor', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MotorApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MotorRPM is not None or
            self.MotorBrakeHP is not None or
            self.MotorHP is not None or
            self.MotorEfficiency is not None or
            self.DriveEfficiency is not None or
            self.FullLoadAmps is not None or
            self.MotorPoleCount is not None or
            self.MotorEnclosureType is not None or
            self.MotorApplication is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedSystemID or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MotorRPM is not None:
            self.MotorRPM.export(outfile, level, namespace_, name_='MotorRPM', pretty_print=pretty_print)
        if self.MotorBrakeHP is not None:
            self.MotorBrakeHP.export(outfile, level, namespace_, name_='MotorBrakeHP', pretty_print=pretty_print)
        if self.MotorHP is not None:
            self.MotorHP.export(outfile, level, namespace_, name_='MotorHP', pretty_print=pretty_print)
        if self.MotorEfficiency is not None:
            self.MotorEfficiency.export(outfile, level, namespace_, name_='MotorEfficiency', pretty_print=pretty_print)
        if self.DriveEfficiency is not None:
            self.DriveEfficiency.export(outfile, level, namespace_, name_='DriveEfficiency', pretty_print=pretty_print)
        if self.FullLoadAmps is not None:
            self.FullLoadAmps.export(outfile, level, namespace_, name_='FullLoadAmps', pretty_print=pretty_print)
        if self.MotorPoleCount is not None:
            self.MotorPoleCount.export(outfile, level, namespace_, name_='MotorPoleCount', pretty_print=pretty_print)
        if self.MotorEnclosureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMotorEnclosureType>%s</%sMotorEnclosureType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MotorEnclosureType), input_name='MotorEnclosureType')), namespace_, eol_))
        if self.MotorApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMotorApplication>%s</%sMotorApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MotorApplication), input_name='MotorApplication')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        for LinkedSystemID_ in self.LinkedSystemID:
            LinkedSystemID_.export(outfile, level, namespace_, name_='LinkedSystemID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MotorRPM':
            obj_ = MotorRPMType.factory()
            obj_.build(child_)
            self.MotorRPM = obj_
            obj_.original_tagname_ = 'MotorRPM'
        elif nodeName_ == 'MotorBrakeHP':
            obj_ = MotorBrakeHPType.factory()
            obj_.build(child_)
            self.MotorBrakeHP = obj_
            obj_.original_tagname_ = 'MotorBrakeHP'
        elif nodeName_ == 'MotorHP':
            obj_ = MotorHPType.factory()
            obj_.build(child_)
            self.MotorHP = obj_
            obj_.original_tagname_ = 'MotorHP'
        elif nodeName_ == 'MotorEfficiency':
            obj_ = MotorEfficiencyType.factory()
            obj_.build(child_)
            self.MotorEfficiency = obj_
            obj_.original_tagname_ = 'MotorEfficiency'
        elif nodeName_ == 'DriveEfficiency':
            obj_ = DriveEfficiencyType.factory()
            obj_.build(child_)
            self.DriveEfficiency = obj_
            obj_.original_tagname_ = 'DriveEfficiency'
        elif nodeName_ == 'FullLoadAmps':
            obj_ = FullLoadAmpsType.factory()
            obj_.build(child_)
            self.FullLoadAmps = obj_
            obj_.original_tagname_ = 'FullLoadAmps'
        elif nodeName_ == 'MotorPoleCount':
            obj_ = MotorPoleCountType.factory()
            obj_.build(child_)
            self.MotorPoleCount = obj_
            obj_.original_tagname_ = 'MotorPoleCount'
        elif nodeName_ == 'MotorEnclosureType':
            MotorEnclosureType_ = child_.text
            MotorEnclosureType_ = self.gds_validate_string(MotorEnclosureType_, node, 'MotorEnclosureType')
            self.MotorEnclosureType = MotorEnclosureType_
            # validate type MotorEnclosureTypeType
            self.validate_MotorEnclosureTypeType(self.MotorEnclosureType)
        elif nodeName_ == 'MotorApplication':
            MotorApplication_ = child_.text
            MotorApplication_ = self.gds_validate_string(MotorApplication_, node, 'MotorApplication')
            self.MotorApplication = MotorApplication_
            # validate type MotorApplicationType
            self.validate_MotorApplicationType(self.MotorApplication)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedSystemID':
            obj_ = LinkedSystemIDType188.factory()
            obj_.build(child_)
            self.LinkedSystemID.append(obj_)
            obj_.original_tagname_ = 'LinkedSystemID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class MotorSystemType


class HeatRecoverySystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, HeatRecoveryEfficiency=None, EnergyRecoveryEfficiency=None, HeatRecoveryType=None, SystemIDReceivingHeat=None, SystemIDProvidingHeat=None, ControlTechnology=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Location=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.HeatRecoveryEfficiency = HeatRecoveryEfficiency
        self.EnergyRecoveryEfficiency = EnergyRecoveryEfficiency
        self.HeatRecoveryType = HeatRecoveryType
        self.validate_HeatRecoveryTypeType(self.HeatRecoveryType)
        self.SystemIDReceivingHeat = SystemIDReceivingHeat
        self.SystemIDProvidingHeat = SystemIDProvidingHeat
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatRecoverySystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatRecoverySystemType.subclass:
            return HeatRecoverySystemType.subclass(*args_, **kwargs_)
        else:
            return HeatRecoverySystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HeatRecoveryTypeType(self, value):
        # Validate type HeatRecoveryTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Run-around coil', 'Thermal wheel', 'Heat pipe', 'Air to air heat exchanger', 'Earth to air heat exchanger', 'Earth to water heat exchanger', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeatRecoveryTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.HeatRecoveryEfficiency is not None or
            self.EnergyRecoveryEfficiency is not None or
            self.HeatRecoveryType is not None or
            self.SystemIDReceivingHeat is not None or
            self.SystemIDProvidingHeat is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatRecoverySystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatRecoverySystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatRecoverySystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatRecoverySystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatRecoverySystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeatRecoveryEfficiency is not None:
            self.HeatRecoveryEfficiency.export(outfile, level, namespace_, name_='HeatRecoveryEfficiency', pretty_print=pretty_print)
        if self.EnergyRecoveryEfficiency is not None:
            self.EnergyRecoveryEfficiency.export(outfile, level, namespace_, name_='EnergyRecoveryEfficiency', pretty_print=pretty_print)
        if self.HeatRecoveryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatRecoveryType>%s</%sHeatRecoveryType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatRecoveryType), input_name='HeatRecoveryType')), namespace_, eol_))
        if self.SystemIDReceivingHeat is not None:
            self.SystemIDReceivingHeat.export(outfile, level, namespace_, name_='SystemIDReceivingHeat', pretty_print=pretty_print)
        if self.SystemIDProvidingHeat is not None:
            self.SystemIDProvidingHeat.export(outfile, level, namespace_, name_='SystemIDProvidingHeat', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatRecoveryEfficiency':
            obj_ = HeatRecoveryEfficiencyType.factory()
            obj_.build(child_)
            self.HeatRecoveryEfficiency = obj_
            obj_.original_tagname_ = 'HeatRecoveryEfficiency'
        elif nodeName_ == 'EnergyRecoveryEfficiency':
            obj_ = EnergyRecoveryEfficiencyType.factory()
            obj_.build(child_)
            self.EnergyRecoveryEfficiency = obj_
            obj_.original_tagname_ = 'EnergyRecoveryEfficiency'
        elif nodeName_ == 'HeatRecoveryType':
            HeatRecoveryType_ = child_.text
            HeatRecoveryType_ = self.gds_validate_string(HeatRecoveryType_, node, 'HeatRecoveryType')
            self.HeatRecoveryType = HeatRecoveryType_
            # validate type HeatRecoveryTypeType
            self.validate_HeatRecoveryTypeType(self.HeatRecoveryType)
        elif nodeName_ == 'SystemIDReceivingHeat':
            obj_ = SystemIDReceivingHeatType.factory()
            obj_.build(child_)
            self.SystemIDReceivingHeat = obj_
            obj_.original_tagname_ = 'SystemIDReceivingHeat'
        elif nodeName_ == 'SystemIDProvidingHeat':
            obj_ = SystemIDProvidingHeatType.factory()
            obj_.build(child_)
            self.SystemIDProvidingHeat = obj_
            obj_.original_tagname_ = 'SystemIDProvidingHeat'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class HeatRecoverySystemType


class WallSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, ExteriorWallConstruction=None, ExteriorWallFinish=None, ExteriorWallColor=None, WallInsulation=None, WallRValue=None, WallUFactor=None, WallFramingMaterial=None, WallFramingSpacing=None, WallFramingDepth=None, WallFramingFactor=None, CMUFill=None, WallExteriorSolarAbsorptance=None, WallExteriorThermalAbsorptance=None, InteriorVisibleAbsorptance=None, ExteriorRoughness=None, Quantity=None, YearInstalled=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.ExteriorWallConstruction = ExteriorWallConstruction
        self.validate_EnvelopeConstructionType(self.ExteriorWallConstruction)
        self.ExteriorWallFinish = ExteriorWallFinish
        self.validate_ExteriorWallFinishType(self.ExteriorWallFinish)
        self.ExteriorWallColor = ExteriorWallColor
        self.validate_ExteriorWallColorType(self.ExteriorWallColor)
        if WallInsulation is None:
            self.WallInsulation = []
        else:
            self.WallInsulation = WallInsulation
        self.WallRValue = WallRValue
        self.WallUFactor = WallUFactor
        self.WallFramingMaterial = WallFramingMaterial
        self.validate_WallFramingMaterialType(self.WallFramingMaterial)
        self.WallFramingSpacing = WallFramingSpacing
        self.WallFramingDepth = WallFramingDepth
        self.WallFramingFactor = WallFramingFactor
        self.CMUFill = CMUFill
        self.validate_CMUFillType(self.CMUFill)
        self.WallExteriorSolarAbsorptance = WallExteriorSolarAbsorptance
        self.WallExteriorThermalAbsorptance = WallExteriorThermalAbsorptance
        self.InteriorVisibleAbsorptance = InteriorVisibleAbsorptance
        self.ExteriorRoughness = ExteriorRoughness
        self.validate_ExteriorRoughnessType(self.ExteriorRoughness)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallSystemType.subclass:
            return WallSystemType.subclass(*args_, **kwargs_)
        else:
            return WallSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnvelopeConstructionType(self, value):
        # Validate type EnvelopeConstructionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Masonry', 'Structural brick', 'Stone', 'Concrete masonry unit', 'Concrete-solid', 'Concrete-lightweight', 'Concrete-panels', 'Concrete-poured', 'Concrete-load bearing', 'Concrete-insulated forms', 'Concrete-aerated', 'Steel frame', 'Wood frame', 'Double wood frame', 'Structural insulated panel', 'Log-solid wood', 'Straw bale', 'Built-up', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeConstructionType' % {"value" : value.encode("utf-8")} )
    def validate_ExteriorWallFinishType(self, value):
        # Validate type ExteriorWallFinishType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wood', 'Stone', 'Tile', 'Brick', 'Masonry', 'Concrete', 'Metal', 'Metal panel', 'Metal panel-standing seam', 'Sheet metal', 'EIFS', 'Shingles-asphalt', 'Shingles-composition', 'Shingles-wood', 'Shingles-asbestos', 'Shingles-slate or tile', 'Shakes-wood', 'Carpet', 'Linoleum', 'Asphalt or fiberglass', 'Plastic-rubber-synthetic sheeting', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExteriorWallFinishType' % {"value" : value.encode("utf-8")} )
    def validate_ExteriorWallColorType(self, value):
        # Validate type ExteriorWallColorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['White', 'Light', 'Medium', 'Med-dark', 'Dark', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExteriorWallColorType' % {"value" : value.encode("utf-8")} )
    def validate_WallFramingMaterialType(self, value):
        # Validate type WallFramingMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wood', 'Steel', 'Concrete', 'Brick', 'Masonry', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WallFramingMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_CMUFillType(self, value):
        # Validate type CMUFillType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Empty', 'Insulated', 'Solid', 'Unknown', 'Not Applicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CMUFillType' % {"value" : value.encode("utf-8")} )
    def validate_ExteriorRoughnessType(self, value):
        # Validate type ExteriorRoughnessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Very rough', 'Rough', 'Medium rough', 'Medium smooth', 'Smooth', 'Very smooth', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExteriorRoughnessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ExteriorWallConstruction is not None or
            self.ExteriorWallFinish is not None or
            self.ExteriorWallColor is not None or
            self.WallInsulation or
            self.WallRValue is not None or
            self.WallUFactor is not None or
            self.WallFramingMaterial is not None or
            self.WallFramingSpacing is not None or
            self.WallFramingDepth is not None or
            self.WallFramingFactor is not None or
            self.CMUFill is not None or
            self.WallExteriorSolarAbsorptance is not None or
            self.WallExteriorThermalAbsorptance is not None or
            self.InteriorVisibleAbsorptance is not None or
            self.ExteriorRoughness is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExteriorWallConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorWallConstruction>%s</%sExteriorWallConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorWallConstruction), input_name='ExteriorWallConstruction')), namespace_, eol_))
        if self.ExteriorWallFinish is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorWallFinish>%s</%sExteriorWallFinish>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorWallFinish), input_name='ExteriorWallFinish')), namespace_, eol_))
        if self.ExteriorWallColor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorWallColor>%s</%sExteriorWallColor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorWallColor), input_name='ExteriorWallColor')), namespace_, eol_))
        for WallInsulation_ in self.WallInsulation:
            WallInsulation_.export(outfile, level, namespace_, name_='WallInsulation', pretty_print=pretty_print)
        if self.WallRValue is not None:
            self.WallRValue.export(outfile, level, namespace_, name_='WallRValue', pretty_print=pretty_print)
        if self.WallUFactor is not None:
            self.WallUFactor.export(outfile, level, namespace_, name_='WallUFactor', pretty_print=pretty_print)
        if self.WallFramingMaterial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallFramingMaterial>%s</%sWallFramingMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallFramingMaterial), input_name='WallFramingMaterial')), namespace_, eol_))
        if self.WallFramingSpacing is not None:
            self.WallFramingSpacing.export(outfile, level, namespace_, name_='WallFramingSpacing', pretty_print=pretty_print)
        if self.WallFramingDepth is not None:
            self.WallFramingDepth.export(outfile, level, namespace_, name_='WallFramingDepth', pretty_print=pretty_print)
        if self.WallFramingFactor is not None:
            self.WallFramingFactor.export(outfile, level, namespace_, name_='WallFramingFactor', pretty_print=pretty_print)
        if self.CMUFill is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCMUFill>%s</%sCMUFill>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CMUFill), input_name='CMUFill')), namespace_, eol_))
        if self.WallExteriorSolarAbsorptance is not None:
            self.WallExteriorSolarAbsorptance.export(outfile, level, namespace_, name_='WallExteriorSolarAbsorptance', pretty_print=pretty_print)
        if self.WallExteriorThermalAbsorptance is not None:
            self.WallExteriorThermalAbsorptance.export(outfile, level, namespace_, name_='WallExteriorThermalAbsorptance', pretty_print=pretty_print)
        if self.InteriorVisibleAbsorptance is not None:
            self.InteriorVisibleAbsorptance.export(outfile, level, namespace_, name_='InteriorVisibleAbsorptance', pretty_print=pretty_print)
        if self.ExteriorRoughness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorRoughness>%s</%sExteriorRoughness>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorRoughness), input_name='ExteriorRoughness')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExteriorWallConstruction':
            ExteriorWallConstruction_ = child_.text
            ExteriorWallConstruction_ = self.gds_validate_string(ExteriorWallConstruction_, node, 'ExteriorWallConstruction')
            self.ExteriorWallConstruction = ExteriorWallConstruction_
            # validate type EnvelopeConstructionType
            self.validate_EnvelopeConstructionType(self.ExteriorWallConstruction)
        elif nodeName_ == 'ExteriorWallFinish':
            ExteriorWallFinish_ = child_.text
            ExteriorWallFinish_ = self.gds_validate_string(ExteriorWallFinish_, node, 'ExteriorWallFinish')
            self.ExteriorWallFinish = ExteriorWallFinish_
            # validate type ExteriorWallFinishType
            self.validate_ExteriorWallFinishType(self.ExteriorWallFinish)
        elif nodeName_ == 'ExteriorWallColor':
            ExteriorWallColor_ = child_.text
            ExteriorWallColor_ = self.gds_validate_string(ExteriorWallColor_, node, 'ExteriorWallColor')
            self.ExteriorWallColor = ExteriorWallColor_
            # validate type ExteriorWallColorType
            self.validate_ExteriorWallColorType(self.ExteriorWallColor)
        elif nodeName_ == 'WallInsulation':
            obj_ = WallInsulationType.factory()
            obj_.build(child_)
            self.WallInsulation.append(obj_)
            obj_.original_tagname_ = 'WallInsulation'
        elif nodeName_ == 'WallRValue':
            obj_ = WallRValueType.factory()
            obj_.build(child_)
            self.WallRValue = obj_
            obj_.original_tagname_ = 'WallRValue'
        elif nodeName_ == 'WallUFactor':
            obj_ = WallUFactorType.factory()
            obj_.build(child_)
            self.WallUFactor = obj_
            obj_.original_tagname_ = 'WallUFactor'
        elif nodeName_ == 'WallFramingMaterial':
            WallFramingMaterial_ = child_.text
            WallFramingMaterial_ = self.gds_validate_string(WallFramingMaterial_, node, 'WallFramingMaterial')
            self.WallFramingMaterial = WallFramingMaterial_
            # validate type WallFramingMaterialType
            self.validate_WallFramingMaterialType(self.WallFramingMaterial)
        elif nodeName_ == 'WallFramingSpacing':
            obj_ = WallFramingSpacingType.factory()
            obj_.build(child_)
            self.WallFramingSpacing = obj_
            obj_.original_tagname_ = 'WallFramingSpacing'
        elif nodeName_ == 'WallFramingDepth':
            obj_ = WallFramingDepthType.factory()
            obj_.build(child_)
            self.WallFramingDepth = obj_
            obj_.original_tagname_ = 'WallFramingDepth'
        elif nodeName_ == 'WallFramingFactor':
            obj_ = WallFramingFactorType.factory()
            obj_.build(child_)
            self.WallFramingFactor = obj_
            obj_.original_tagname_ = 'WallFramingFactor'
        elif nodeName_ == 'CMUFill':
            CMUFill_ = child_.text
            CMUFill_ = self.gds_validate_string(CMUFill_, node, 'CMUFill')
            self.CMUFill = CMUFill_
            # validate type CMUFillType
            self.validate_CMUFillType(self.CMUFill)
        elif nodeName_ == 'WallExteriorSolarAbsorptance':
            obj_ = WallExteriorSolarAbsorptanceType.factory()
            obj_.build(child_)
            self.WallExteriorSolarAbsorptance = obj_
            obj_.original_tagname_ = 'WallExteriorSolarAbsorptance'
        elif nodeName_ == 'WallExteriorThermalAbsorptance':
            obj_ = WallExteriorThermalAbsorptanceType.factory()
            obj_.build(child_)
            self.WallExteriorThermalAbsorptance = obj_
            obj_.original_tagname_ = 'WallExteriorThermalAbsorptance'
        elif nodeName_ == 'InteriorVisibleAbsorptance':
            obj_ = InteriorVisibleAbsorptanceType.factory()
            obj_.build(child_)
            self.InteriorVisibleAbsorptance = obj_
            obj_.original_tagname_ = 'InteriorVisibleAbsorptance'
        elif nodeName_ == 'ExteriorRoughness':
            ExteriorRoughness_ = child_.text
            ExteriorRoughness_ = self.gds_validate_string(ExteriorRoughness_, node, 'ExteriorRoughness')
            self.ExteriorRoughness = ExteriorRoughness_
            # validate type ExteriorRoughnessType
            self.validate_ExteriorRoughnessType(self.ExteriorRoughness)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class WallSystemType


class RoofCeilingSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, RoofConstruction=None, SpecialRoofClassification=None, RoofFinish=None, RoofColor=None, RoofInsulation=None, DeckType=None, RoofRValue=None, RoofUFactor=None, RoofFramingMaterial=None, RoofFramingSpacing=None, RoofFramingDepth=None, RoofFramingFactor=None, RoofSlope=None, RadiantBarrier=None, RoofExteriorSolarAbsorptance=None, RoofExteriorThermalAbsorptance=None, CeilingVisibleAbsorptance=None, Quantity=None, YearInstalled=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.RoofConstruction = RoofConstruction
        self.validate_EnvelopeConstructionType(self.RoofConstruction)
        self.SpecialRoofClassification = SpecialRoofClassification
        self.validate_SpecialRoofClassificationType(self.SpecialRoofClassification)
        self.RoofFinish = RoofFinish
        self.validate_RoofFinishType(self.RoofFinish)
        self.RoofColor = RoofColor
        self.validate_RoofColorType(self.RoofColor)
        if RoofInsulation is None:
            self.RoofInsulation = []
        else:
            self.RoofInsulation = RoofInsulation
        self.DeckType = DeckType
        self.validate_DeckTypeType(self.DeckType)
        self.RoofRValue = RoofRValue
        self.RoofUFactor = RoofUFactor
        self.RoofFramingMaterial = RoofFramingMaterial
        self.validate_RoofFramingMaterialType(self.RoofFramingMaterial)
        self.RoofFramingSpacing = RoofFramingSpacing
        self.RoofFramingDepth = RoofFramingDepth
        self.RoofFramingFactor = RoofFramingFactor
        self.RoofSlope = RoofSlope
        self.validate_RoofSlopeType(self.RoofSlope)
        self.RadiantBarrier = RadiantBarrier
        self.RoofExteriorSolarAbsorptance = RoofExteriorSolarAbsorptance
        self.RoofExteriorThermalAbsorptance = RoofExteriorThermalAbsorptance
        self.CeilingVisibleAbsorptance = CeilingVisibleAbsorptance
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofCeilingSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofCeilingSystemType.subclass:
            return RoofCeilingSystemType.subclass(*args_, **kwargs_)
        else:
            return RoofCeilingSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnvelopeConstructionType(self, value):
        # Validate type EnvelopeConstructionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Masonry', 'Structural brick', 'Stone', 'Concrete masonry unit', 'Concrete-solid', 'Concrete-lightweight', 'Concrete-panels', 'Concrete-poured', 'Concrete-load bearing', 'Concrete-insulated forms', 'Concrete-aerated', 'Steel frame', 'Wood frame', 'Double wood frame', 'Structural insulated panel', 'Log-solid wood', 'Straw bale', 'Built-up', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeConstructionType' % {"value" : value.encode("utf-8")} )
    def validate_SpecialRoofClassificationType(self, value):
        # Validate type SpecialRoofClassificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cool roof', 'Green roof', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecialRoofClassificationType' % {"value" : value.encode("utf-8")} )
    def validate_RoofFinishType(self, value):
        # Validate type RoofFinishType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wood', 'Stone', 'Tile', 'Brick', 'Masonry', 'Concrete', 'Metal', 'Metal panel', 'Metal panel-standing seam', 'Sheet metal', 'EIFS', 'Shingles-asphalt', 'Shingles-composition', 'Shingles-wood', 'Shingles-asbestos', 'Shingles-slate or tile', 'Shakes-wood', 'Carpet', 'Linoleum', 'Asphalt or fiberglass', 'Plastic-rubber-synthetic sheeting', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofFinishType' % {"value" : value.encode("utf-8")} )
    def validate_RoofColorType(self, value):
        # Validate type RoofColorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['White', 'Light', 'Medium', 'Med-dark', 'Dark', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofColorType' % {"value" : value.encode("utf-8")} )
    def validate_DeckTypeType(self, value):
        # Validate type DeckTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wood', 'Steel', 'Concrete', 'Brick', 'Masonry', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeckTypeType' % {"value" : value.encode("utf-8")} )
    def validate_RoofFramingMaterialType(self, value):
        # Validate type RoofFramingMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wood', 'Steel', 'Concrete', 'Brick', 'Masonry', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofFramingMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_RoofSlopeType(self, value):
        # Validate type RoofSlopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flat', 'Sloped', '> 2:12', '< 2:12', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofSlopeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RoofConstruction is not None or
            self.SpecialRoofClassification is not None or
            self.RoofFinish is not None or
            self.RoofColor is not None or
            self.RoofInsulation or
            self.DeckType is not None or
            self.RoofRValue is not None or
            self.RoofUFactor is not None or
            self.RoofFramingMaterial is not None or
            self.RoofFramingSpacing is not None or
            self.RoofFramingDepth is not None or
            self.RoofFramingFactor is not None or
            self.RoofSlope is not None or
            self.RadiantBarrier is not None or
            self.RoofExteriorSolarAbsorptance is not None or
            self.RoofExteriorThermalAbsorptance is not None or
            self.CeilingVisibleAbsorptance is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofCeilingSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofCeilingSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofCeilingSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofCeilingSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofCeilingSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RoofConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofConstruction>%s</%sRoofConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofConstruction), input_name='RoofConstruction')), namespace_, eol_))
        if self.SpecialRoofClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialRoofClassification>%s</%sSpecialRoofClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpecialRoofClassification), input_name='SpecialRoofClassification')), namespace_, eol_))
        if self.RoofFinish is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofFinish>%s</%sRoofFinish>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofFinish), input_name='RoofFinish')), namespace_, eol_))
        if self.RoofColor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofColor>%s</%sRoofColor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofColor), input_name='RoofColor')), namespace_, eol_))
        for RoofInsulation_ in self.RoofInsulation:
            RoofInsulation_.export(outfile, level, namespace_, name_='RoofInsulation', pretty_print=pretty_print)
        if self.DeckType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeckType>%s</%sDeckType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DeckType), input_name='DeckType')), namespace_, eol_))
        if self.RoofRValue is not None:
            self.RoofRValue.export(outfile, level, namespace_, name_='RoofRValue', pretty_print=pretty_print)
        if self.RoofUFactor is not None:
            self.RoofUFactor.export(outfile, level, namespace_, name_='RoofUFactor', pretty_print=pretty_print)
        if self.RoofFramingMaterial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofFramingMaterial>%s</%sRoofFramingMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofFramingMaterial), input_name='RoofFramingMaterial')), namespace_, eol_))
        if self.RoofFramingSpacing is not None:
            self.RoofFramingSpacing.export(outfile, level, namespace_, name_='RoofFramingSpacing', pretty_print=pretty_print)
        if self.RoofFramingDepth is not None:
            self.RoofFramingDepth.export(outfile, level, namespace_, name_='RoofFramingDepth', pretty_print=pretty_print)
        if self.RoofFramingFactor is not None:
            self.RoofFramingFactor.export(outfile, level, namespace_, name_='RoofFramingFactor', pretty_print=pretty_print)
        if self.RoofSlope is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofSlope>%s</%sRoofSlope>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofSlope), input_name='RoofSlope')), namespace_, eol_))
        if self.RadiantBarrier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRadiantBarrier>%s</%sRadiantBarrier>%s' % (namespace_, self.gds_format_boolean(self.RadiantBarrier, input_name='RadiantBarrier'), namespace_, eol_))
        if self.RoofExteriorSolarAbsorptance is not None:
            self.RoofExteriorSolarAbsorptance.export(outfile, level, namespace_, name_='RoofExteriorSolarAbsorptance', pretty_print=pretty_print)
        if self.RoofExteriorThermalAbsorptance is not None:
            self.RoofExteriorThermalAbsorptance.export(outfile, level, namespace_, name_='RoofExteriorThermalAbsorptance', pretty_print=pretty_print)
        if self.CeilingVisibleAbsorptance is not None:
            self.CeilingVisibleAbsorptance.export(outfile, level, namespace_, name_='CeilingVisibleAbsorptance', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RoofConstruction':
            RoofConstruction_ = child_.text
            RoofConstruction_ = self.gds_validate_string(RoofConstruction_, node, 'RoofConstruction')
            self.RoofConstruction = RoofConstruction_
            # validate type EnvelopeConstructionType
            self.validate_EnvelopeConstructionType(self.RoofConstruction)
        elif nodeName_ == 'SpecialRoofClassification':
            SpecialRoofClassification_ = child_.text
            SpecialRoofClassification_ = self.gds_validate_string(SpecialRoofClassification_, node, 'SpecialRoofClassification')
            self.SpecialRoofClassification = SpecialRoofClassification_
            # validate type SpecialRoofClassificationType
            self.validate_SpecialRoofClassificationType(self.SpecialRoofClassification)
        elif nodeName_ == 'RoofFinish':
            RoofFinish_ = child_.text
            RoofFinish_ = self.gds_validate_string(RoofFinish_, node, 'RoofFinish')
            self.RoofFinish = RoofFinish_
            # validate type RoofFinishType
            self.validate_RoofFinishType(self.RoofFinish)
        elif nodeName_ == 'RoofColor':
            RoofColor_ = child_.text
            RoofColor_ = self.gds_validate_string(RoofColor_, node, 'RoofColor')
            self.RoofColor = RoofColor_
            # validate type RoofColorType
            self.validate_RoofColorType(self.RoofColor)
        elif nodeName_ == 'RoofInsulation':
            obj_ = RoofInsulationType.factory()
            obj_.build(child_)
            self.RoofInsulation.append(obj_)
            obj_.original_tagname_ = 'RoofInsulation'
        elif nodeName_ == 'DeckType':
            DeckType_ = child_.text
            DeckType_ = self.gds_validate_string(DeckType_, node, 'DeckType')
            self.DeckType = DeckType_
            # validate type DeckTypeType
            self.validate_DeckTypeType(self.DeckType)
        elif nodeName_ == 'RoofRValue':
            obj_ = RoofRValueType.factory()
            obj_.build(child_)
            self.RoofRValue = obj_
            obj_.original_tagname_ = 'RoofRValue'
        elif nodeName_ == 'RoofUFactor':
            obj_ = RoofUFactorType.factory()
            obj_.build(child_)
            self.RoofUFactor = obj_
            obj_.original_tagname_ = 'RoofUFactor'
        elif nodeName_ == 'RoofFramingMaterial':
            RoofFramingMaterial_ = child_.text
            RoofFramingMaterial_ = self.gds_validate_string(RoofFramingMaterial_, node, 'RoofFramingMaterial')
            self.RoofFramingMaterial = RoofFramingMaterial_
            # validate type RoofFramingMaterialType
            self.validate_RoofFramingMaterialType(self.RoofFramingMaterial)
        elif nodeName_ == 'RoofFramingSpacing':
            obj_ = RoofFramingSpacingType.factory()
            obj_.build(child_)
            self.RoofFramingSpacing = obj_
            obj_.original_tagname_ = 'RoofFramingSpacing'
        elif nodeName_ == 'RoofFramingDepth':
            obj_ = RoofFramingDepthType.factory()
            obj_.build(child_)
            self.RoofFramingDepth = obj_
            obj_.original_tagname_ = 'RoofFramingDepth'
        elif nodeName_ == 'RoofFramingFactor':
            obj_ = RoofFramingFactorType.factory()
            obj_.build(child_)
            self.RoofFramingFactor = obj_
            obj_.original_tagname_ = 'RoofFramingFactor'
        elif nodeName_ == 'RoofSlope':
            RoofSlope_ = child_.text
            RoofSlope_ = self.gds_validate_string(RoofSlope_, node, 'RoofSlope')
            self.RoofSlope = RoofSlope_
            # validate type RoofSlopeType
            self.validate_RoofSlopeType(self.RoofSlope)
        elif nodeName_ == 'RadiantBarrier':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RadiantBarrier')
            self.RadiantBarrier = ival_
        elif nodeName_ == 'RoofExteriorSolarAbsorptance':
            obj_ = RoofExteriorSolarAbsorptanceType.factory()
            obj_.build(child_)
            self.RoofExteriorSolarAbsorptance = obj_
            obj_.original_tagname_ = 'RoofExteriorSolarAbsorptance'
        elif nodeName_ == 'RoofExteriorThermalAbsorptance':
            obj_ = RoofExteriorThermalAbsorptanceType.factory()
            obj_.build(child_)
            self.RoofExteriorThermalAbsorptance = obj_
            obj_.original_tagname_ = 'RoofExteriorThermalAbsorptance'
        elif nodeName_ == 'CeilingVisibleAbsorptance':
            obj_ = CeilingVisibleAbsorptanceType.factory()
            obj_.build(child_)
            self.CeilingVisibleAbsorptance = obj_
            obj_.original_tagname_ = 'CeilingVisibleAbsorptance'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class RoofCeilingSystemType


class FenestrationSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, FenestrationType=None, FenestrationFrameMaterial=None, FenestrationOperation=None, Weatherstripped=None, TightnessFitCondition=None, GlassType=None, FenestrationGasFill=None, FenestrationGlassLayers=None, FenestrationRValue=None, FenestrationUFactor=None, SolarHeatGainCoefficient=None, VisibleTransmittance=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, Manufacturer=None, ModelNumber=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.FenestrationType = FenestrationType
        self.FenestrationFrameMaterial = FenestrationFrameMaterial
        self.validate_FenestrationFrameMaterialType(self.FenestrationFrameMaterial)
        self.FenestrationOperation = FenestrationOperation
        self.Weatherstripped = Weatherstripped
        self.TightnessFitCondition = TightnessFitCondition
        self.validate_TightnessFitConditionType(self.TightnessFitCondition)
        self.GlassType = GlassType
        self.validate_GlassTypeType(self.GlassType)
        self.FenestrationGasFill = FenestrationGasFill
        self.validate_FenestrationGasFillType(self.FenestrationGasFill)
        self.FenestrationGlassLayers = FenestrationGlassLayers
        self.validate_FenestrationGlassLayersType(self.FenestrationGlassLayers)
        self.FenestrationRValue = FenestrationRValue
        self.FenestrationUFactor = FenestrationUFactor
        self.SolarHeatGainCoefficient = SolarHeatGainCoefficient
        self.VisibleTransmittance = VisibleTransmittance
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationSystemType.subclass:
            return FenestrationSystemType.subclass(*args_, **kwargs_)
        else:
            return FenestrationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FenestrationFrameMaterialType(self, value):
        # Validate type FenestrationFrameMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Aluminum-uncategorized', 'Aluminum-no thermal break', 'Aluminum-thermal break', 'Clad', 'Composite', 'Fiberglass', 'Steel', 'Vinyl', 'Wood', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FenestrationFrameMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_TightnessFitConditionType(self, value):
        # Validate type TightnessFitConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Tight', 'Average', 'Loose', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TightnessFitConditionType' % {"value" : value.encode("utf-8")} )
    def validate_GlassTypeType(self, value):
        # Validate type GlassTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Clear uncoated', 'Low-e', 'Tinted', 'Tinted + low-e', 'Reflective', 'Reflective on tint', 'High performance tint', 'Sunbelt low-E (low SHGC)', 'Suspended film', 'Plastic', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GlassTypeType' % {"value" : value.encode("utf-8")} )
    def validate_FenestrationGasFillType(self, value):
        # Validate type FenestrationGasFillType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Argon', 'Krypton', 'Other Insulating Gas', 'Air', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FenestrationGasFillType' % {"value" : value.encode("utf-8")} )
    def validate_FenestrationGlassLayersType(self, value):
        # Validate type FenestrationGlassLayersType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Single-pane', 'Double-pane', 'Triple-pane', 'Single-paned with storm panel', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FenestrationGlassLayersType' % {"value" : value.encode("utf-8")} )
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FenestrationType is not None or
            self.FenestrationFrameMaterial is not None or
            self.FenestrationOperation is not None or
            self.Weatherstripped is not None or
            self.TightnessFitCondition is not None or
            self.GlassType is not None or
            self.FenestrationGasFill is not None or
            self.FenestrationGlassLayers is not None or
            self.FenestrationRValue is not None or
            self.FenestrationUFactor is not None or
            self.SolarHeatGainCoefficient is not None or
            self.VisibleTransmittance is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FenestrationType is not None:
            self.FenestrationType.export(outfile, level, namespace_, name_='FenestrationType', pretty_print=pretty_print)
        if self.FenestrationFrameMaterial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenestrationFrameMaterial>%s</%sFenestrationFrameMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FenestrationFrameMaterial), input_name='FenestrationFrameMaterial')), namespace_, eol_))
        if self.FenestrationOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenestrationOperation>%s</%sFenestrationOperation>%s' % (namespace_, self.gds_format_boolean(self.FenestrationOperation, input_name='FenestrationOperation'), namespace_, eol_))
        if self.Weatherstripped is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherstripped>%s</%sWeatherstripped>%s' % (namespace_, self.gds_format_boolean(self.Weatherstripped, input_name='Weatherstripped'), namespace_, eol_))
        if self.TightnessFitCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTightnessFitCondition>%s</%sTightnessFitCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TightnessFitCondition), input_name='TightnessFitCondition')), namespace_, eol_))
        if self.GlassType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGlassType>%s</%sGlassType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.GlassType), input_name='GlassType')), namespace_, eol_))
        if self.FenestrationGasFill is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenestrationGasFill>%s</%sFenestrationGasFill>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FenestrationGasFill), input_name='FenestrationGasFill')), namespace_, eol_))
        if self.FenestrationGlassLayers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenestrationGlassLayers>%s</%sFenestrationGlassLayers>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FenestrationGlassLayers), input_name='FenestrationGlassLayers')), namespace_, eol_))
        if self.FenestrationRValue is not None:
            self.FenestrationRValue.export(outfile, level, namespace_, name_='FenestrationRValue', pretty_print=pretty_print)
        if self.FenestrationUFactor is not None:
            self.FenestrationUFactor.export(outfile, level, namespace_, name_='FenestrationUFactor', pretty_print=pretty_print)
        if self.SolarHeatGainCoefficient is not None:
            self.SolarHeatGainCoefficient.export(outfile, level, namespace_, name_='SolarHeatGainCoefficient', pretty_print=pretty_print)
        if self.VisibleTransmittance is not None:
            self.VisibleTransmittance.export(outfile, level, namespace_, name_='VisibleTransmittance', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FenestrationType':
            obj_ = FenestrationTypeType.factory()
            obj_.build(child_)
            self.FenestrationType = obj_
            obj_.original_tagname_ = 'FenestrationType'
        elif nodeName_ == 'FenestrationFrameMaterial':
            FenestrationFrameMaterial_ = child_.text
            FenestrationFrameMaterial_ = self.gds_validate_string(FenestrationFrameMaterial_, node, 'FenestrationFrameMaterial')
            self.FenestrationFrameMaterial = FenestrationFrameMaterial_
            # validate type FenestrationFrameMaterialType
            self.validate_FenestrationFrameMaterialType(self.FenestrationFrameMaterial)
        elif nodeName_ == 'FenestrationOperation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'FenestrationOperation')
            self.FenestrationOperation = ival_
        elif nodeName_ == 'Weatherstripped':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Weatherstripped')
            self.Weatherstripped = ival_
        elif nodeName_ == 'TightnessFitCondition':
            TightnessFitCondition_ = child_.text
            TightnessFitCondition_ = self.gds_validate_string(TightnessFitCondition_, node, 'TightnessFitCondition')
            self.TightnessFitCondition = TightnessFitCondition_
            # validate type TightnessFitConditionType
            self.validate_TightnessFitConditionType(self.TightnessFitCondition)
        elif nodeName_ == 'GlassType':
            GlassType_ = child_.text
            GlassType_ = self.gds_validate_string(GlassType_, node, 'GlassType')
            self.GlassType = GlassType_
            # validate type GlassTypeType
            self.validate_GlassTypeType(self.GlassType)
        elif nodeName_ == 'FenestrationGasFill':
            FenestrationGasFill_ = child_.text
            FenestrationGasFill_ = self.gds_validate_string(FenestrationGasFill_, node, 'FenestrationGasFill')
            self.FenestrationGasFill = FenestrationGasFill_
            # validate type FenestrationGasFillType
            self.validate_FenestrationGasFillType(self.FenestrationGasFill)
        elif nodeName_ == 'FenestrationGlassLayers':
            FenestrationGlassLayers_ = child_.text
            FenestrationGlassLayers_ = self.gds_validate_string(FenestrationGlassLayers_, node, 'FenestrationGlassLayers')
            self.FenestrationGlassLayers = FenestrationGlassLayers_
            # validate type FenestrationGlassLayersType
            self.validate_FenestrationGlassLayersType(self.FenestrationGlassLayers)
        elif nodeName_ == 'FenestrationRValue':
            obj_ = FenestrationRValueType.factory()
            obj_.build(child_)
            self.FenestrationRValue = obj_
            obj_.original_tagname_ = 'FenestrationRValue'
        elif nodeName_ == 'FenestrationUFactor':
            obj_ = FenestrationUFactorType.factory()
            obj_.build(child_)
            self.FenestrationUFactor = obj_
            obj_.original_tagname_ = 'FenestrationUFactor'
        elif nodeName_ == 'SolarHeatGainCoefficient':
            obj_ = SolarHeatGainCoefficientType.factory()
            obj_.build(child_)
            self.SolarHeatGainCoefficient = obj_
            obj_.original_tagname_ = 'SolarHeatGainCoefficient'
        elif nodeName_ == 'VisibleTransmittance':
            obj_ = VisibleTransmittanceType.factory()
            obj_.build(child_)
            self.VisibleTransmittance = obj_
            obj_.original_tagname_ = 'VisibleTransmittance'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class FenestrationSystemType


class FoundationSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, GroundCoupling=None, FloorCovering=None, PlumbingPenetrationSealing=None, YearInstalled=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        if GroundCoupling is None:
            self.GroundCoupling = []
        else:
            self.GroundCoupling = GroundCoupling
        self.FloorCovering = FloorCovering
        self.validate_FloorCoveringType(self.FloorCovering)
        self.PlumbingPenetrationSealing = PlumbingPenetrationSealing
        self.validate_PlumbingPenetrationSealingType(self.PlumbingPenetrationSealing)
        self.YearInstalled = YearInstalled
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationSystemType.subclass:
            return FoundationSystemType.subclass(*args_, **kwargs_)
        else:
            return FoundationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FloorCoveringType(self, value):
        # Validate type FloorCoveringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Carpet', 'Tile', 'Hardwood', 'Vinyl', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FloorCoveringType' % {"value" : value.encode("utf-8")} )
    def validate_PlumbingPenetrationSealingType(self, value):
        # Validate type PlumbingPenetrationSealingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Flashing', 'Fitting', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PlumbingPenetrationSealingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.GroundCoupling or
            self.FloorCovering is not None or
            self.PlumbingPenetrationSealing is not None or
            self.YearInstalled is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GroundCoupling_ in self.GroundCoupling:
            GroundCoupling_.export(outfile, level, namespace_, name_='GroundCoupling', pretty_print=pretty_print)
        if self.FloorCovering is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFloorCovering>%s</%sFloorCovering>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FloorCovering), input_name='FloorCovering')), namespace_, eol_))
        if self.PlumbingPenetrationSealing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlumbingPenetrationSealing>%s</%sPlumbingPenetrationSealing>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlumbingPenetrationSealing), input_name='PlumbingPenetrationSealing')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GroundCoupling':
            obj_ = GroundCouplingType.factory()
            obj_.build(child_)
            self.GroundCoupling.append(obj_)
            obj_.original_tagname_ = 'GroundCoupling'
        elif nodeName_ == 'FloorCovering':
            FloorCovering_ = child_.text
            FloorCovering_ = self.gds_validate_string(FloorCovering_, node, 'FloorCovering')
            self.FloorCovering = FloorCovering_
            # validate type FloorCoveringType
            self.validate_FloorCoveringType(self.FloorCovering)
        elif nodeName_ == 'PlumbingPenetrationSealing':
            PlumbingPenetrationSealing_ = child_.text
            PlumbingPenetrationSealing_ = self.gds_validate_string(PlumbingPenetrationSealing_, node, 'PlumbingPenetrationSealing')
            self.PlumbingPenetrationSealing = PlumbingPenetrationSealing_
            # validate type PlumbingPenetrationSealingType
            self.validate_PlumbingPenetrationSealingType(self.PlumbingPenetrationSealing)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class FoundationSystemType


class CriticalITSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, ITSystemType=None, ITPeakPower=None, ITStandbyPower=None, ITNominalPower=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.ITSystemType = ITSystemType
        self.validate_ITSystemTypeType(self.ITSystemType)
        self.ITPeakPower = ITPeakPower
        self.ITStandbyPower = ITStandbyPower
        self.ITNominalPower = ITNominalPower
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CriticalITSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CriticalITSystemType.subclass:
            return CriticalITSystemType.subclass(*args_, **kwargs_)
        else:
            return CriticalITSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ITSystemTypeType(self, value):
        # Validate type ITSystemTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Server', 'Networking', 'Security', 'Telephoning', 'UPS', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ITSystemTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ITSystemType is not None or
            self.ITPeakPower is not None or
            self.ITStandbyPower is not None or
            self.ITNominalPower is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CriticalITSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CriticalITSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CriticalITSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CriticalITSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CriticalITSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ITSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sITSystemType>%s</%sITSystemType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ITSystemType), input_name='ITSystemType')), namespace_, eol_))
        if self.ITPeakPower is not None:
            self.ITPeakPower.export(outfile, level, namespace_, name_='ITPeakPower', pretty_print=pretty_print)
        if self.ITStandbyPower is not None:
            self.ITStandbyPower.export(outfile, level, namespace_, name_='ITStandbyPower', pretty_print=pretty_print)
        if self.ITNominalPower is not None:
            self.ITNominalPower.export(outfile, level, namespace_, name_='ITNominalPower', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ITSystemType':
            ITSystemType_ = child_.text
            ITSystemType_ = self.gds_validate_string(ITSystemType_, node, 'ITSystemType')
            self.ITSystemType = ITSystemType_
            # validate type ITSystemTypeType
            self.validate_ITSystemTypeType(self.ITSystemType)
        elif nodeName_ == 'ITPeakPower':
            obj_ = ITPeakPowerType.factory()
            obj_.build(child_)
            self.ITPeakPower = obj_
            obj_.original_tagname_ = 'ITPeakPower'
        elif nodeName_ == 'ITStandbyPower':
            obj_ = ITStandbyPowerType.factory()
            obj_.build(child_)
            self.ITStandbyPower = obj_
            obj_.original_tagname_ = 'ITStandbyPower'
        elif nodeName_ == 'ITNominalPower':
            obj_ = ITNominalPowerType.factory()
            obj_.build(child_)
            self.ITNominalPower = obj_
            obj_.original_tagname_ = 'ITNominalPower'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class CriticalITSystemType


class PlugLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, PlugLoadType_member=None, PlugLoadPeakPower=None, PlugLoadStandbyPower=None, PlugLoadNominalPower=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.PlugLoadType = PlugLoadType_member
        self.validate_PlugLoadTypeType(self.PlugLoadType)
        self.PlugLoadPeakPower = PlugLoadPeakPower
        self.PlugLoadStandbyPower = PlugLoadStandbyPower
        self.PlugLoadNominalPower = PlugLoadNominalPower
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadType.subclass:
            return PlugLoadType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PlugLoadTypeType(self, value):
        # Validate type PlugLoadTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Personal Computer', 'Task Lighting', 'Printing', 'Cash Register', 'Audio', 'Display', 'Set Top', 'Business Equipment', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PlugLoadTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PlugLoadType is not None or
            self.PlugLoadPeakPower is not None or
            self.PlugLoadStandbyPower is not None or
            self.PlugLoadNominalPower is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PlugLoadType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlugLoadType>%s</%sPlugLoadType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PlugLoadType), input_name='PlugLoadType')), namespace_, eol_))
        if self.PlugLoadPeakPower is not None:
            self.PlugLoadPeakPower.export(outfile, level, namespace_, name_='PlugLoadPeakPower', pretty_print=pretty_print)
        if self.PlugLoadStandbyPower is not None:
            self.PlugLoadStandbyPower.export(outfile, level, namespace_, name_='PlugLoadStandbyPower', pretty_print=pretty_print)
        if self.PlugLoadNominalPower is not None:
            self.PlugLoadNominalPower.export(outfile, level, namespace_, name_='PlugLoadNominalPower', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PlugLoadType':
            PlugLoadType_ = child_.text
            PlugLoadType_ = self.gds_validate_string(PlugLoadType_, node, 'PlugLoadType')
            self.PlugLoadType = PlugLoadType_
            # validate type PlugLoadTypeType
            self.validate_PlugLoadTypeType(self.PlugLoadType)
        elif nodeName_ == 'PlugLoadPeakPower':
            obj_ = PlugLoadPeakPowerType.factory()
            obj_.build(child_)
            self.PlugLoadPeakPower = obj_
            obj_.original_tagname_ = 'PlugLoadPeakPower'
        elif nodeName_ == 'PlugLoadStandbyPower':
            obj_ = PlugLoadStandbyPowerType.factory()
            obj_.build(child_)
            self.PlugLoadStandbyPower = obj_
            obj_.original_tagname_ = 'PlugLoadStandbyPower'
        elif nodeName_ == 'PlugLoadNominalPower':
            obj_ = PlugLoadNominalPowerType.factory()
            obj_.build(child_)
            self.PlugLoadNominalPower = obj_
            obj_.original_tagname_ = 'PlugLoadNominalPower'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class PlugLoadType


class ProcessLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, ProcessLoadType_member=None, ProcessLoadPeakPower=None, ProcessLoadStandbyPower=None, HeatGainFraction=None, DutyCycle=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.ProcessLoadType = ProcessLoadType_member
        self.validate_ProcessLoadTypeType(self.ProcessLoadType)
        self.ProcessLoadPeakPower = ProcessLoadPeakPower
        self.ProcessLoadStandbyPower = ProcessLoadStandbyPower
        self.HeatGainFraction = HeatGainFraction
        self.DutyCycle = DutyCycle
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessLoadType.subclass:
            return ProcessLoadType.subclass(*args_, **kwargs_)
        else:
            return ProcessLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ProcessLoadTypeType(self, value):
        # Validate type ProcessLoadTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Medical Equipment', 'Laboratory Equipment', 'Machinery', 'Motor', 'Air Compressor', 'Fume Hood', 'Appliance', 'Gaming/Hobby/Leisure', 'Infrastructure', 'Electric Vehicle Charging', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProcessLoadTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ProcessLoadType is not None or
            self.ProcessLoadPeakPower is not None or
            self.ProcessLoadStandbyPower is not None or
            self.HeatGainFraction is not None or
            self.DutyCycle is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ProcessLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessLoadType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ProcessLoadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ProcessLoadType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ProcessLoadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProcessLoadType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessLoadType>%s</%sProcessLoadType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ProcessLoadType), input_name='ProcessLoadType')), namespace_, eol_))
        if self.ProcessLoadPeakPower is not None:
            self.ProcessLoadPeakPower.export(outfile, level, namespace_, name_='ProcessLoadPeakPower', pretty_print=pretty_print)
        if self.ProcessLoadStandbyPower is not None:
            self.ProcessLoadStandbyPower.export(outfile, level, namespace_, name_='ProcessLoadStandbyPower', pretty_print=pretty_print)
        if self.HeatGainFraction is not None:
            self.HeatGainFraction.export(outfile, level, namespace_, name_='HeatGainFraction', pretty_print=pretty_print)
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_, name_='DutyCycle', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProcessLoadType':
            ProcessLoadType_ = child_.text
            ProcessLoadType_ = self.gds_validate_string(ProcessLoadType_, node, 'ProcessLoadType')
            self.ProcessLoadType = ProcessLoadType_
            # validate type ProcessLoadTypeType
            self.validate_ProcessLoadTypeType(self.ProcessLoadType)
        elif nodeName_ == 'ProcessLoadPeakPower':
            obj_ = ProcessLoadPeakPowerType.factory()
            obj_.build(child_)
            self.ProcessLoadPeakPower = obj_
            obj_.original_tagname_ = 'ProcessLoadPeakPower'
        elif nodeName_ == 'ProcessLoadStandbyPower':
            obj_ = ProcessLoadStandbyPowerType.factory()
            obj_.build(child_)
            self.ProcessLoadStandbyPower = obj_
            obj_.original_tagname_ = 'ProcessLoadStandbyPower'
        elif nodeName_ == 'HeatGainFraction':
            obj_ = HeatGainFractionType.factory()
            obj_.build(child_)
            self.HeatGainFraction = obj_
            obj_.original_tagname_ = 'HeatGainFraction'
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycleType.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class ProcessLoadType


class ConveyanceSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, ConveyanceSystemType_member=None, ConveyanceLoadType=None, ConveyancePeakPower=None, ConveyanceStandbyPower=None, ControlTechnology=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, YearofManufacture=None, PrimaryFuel=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.ConveyanceSystemType = ConveyanceSystemType_member
        self.validate_ConveyanceSystemTypeType(self.ConveyanceSystemType)
        self.ConveyanceLoadType = ConveyanceLoadType
        self.validate_ConveyanceLoadTypeType(self.ConveyanceLoadType)
        self.ConveyancePeakPower = ConveyancePeakPower
        self.ConveyanceStandbyPower = ConveyanceStandbyPower
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.PrimaryFuel = PrimaryFuel
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConveyanceSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConveyanceSystemType.subclass:
            return ConveyanceSystemType.subclass(*args_, **kwargs_)
        else:
            return ConveyanceSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ConveyanceSystemTypeType(self, value):
        # Validate type ConveyanceSystemTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Escalator', 'Elevator', 'Conveyor Belt', 'Overhead Conveyor', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ConveyanceSystemTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ConveyanceLoadTypeType(self, value):
        # Validate type ConveyanceLoadTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['People', 'Freight', 'Goods', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ConveyanceLoadTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ConveyanceSystemType is not None or
            self.ConveyanceLoadType is not None or
            self.ConveyancePeakPower is not None or
            self.ConveyanceStandbyPower is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.PrimaryFuel is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConveyanceSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConveyanceSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConveyanceSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConveyanceSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConveyanceSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConveyanceSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConveyanceSystemType>%s</%sConveyanceSystemType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConveyanceSystemType), input_name='ConveyanceSystemType')), namespace_, eol_))
        if self.ConveyanceLoadType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConveyanceLoadType>%s</%sConveyanceLoadType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConveyanceLoadType), input_name='ConveyanceLoadType')), namespace_, eol_))
        if self.ConveyancePeakPower is not None:
            self.ConveyancePeakPower.export(outfile, level, namespace_, name_='ConveyancePeakPower', pretty_print=pretty_print)
        if self.ConveyanceStandbyPower is not None:
            self.ConveyanceStandbyPower.export(outfile, level, namespace_, name_='ConveyanceStandbyPower', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConveyanceSystemType':
            ConveyanceSystemType_ = child_.text
            ConveyanceSystemType_ = self.gds_validate_string(ConveyanceSystemType_, node, 'ConveyanceSystemType')
            self.ConveyanceSystemType = ConveyanceSystemType_
            # validate type ConveyanceSystemTypeType
            self.validate_ConveyanceSystemTypeType(self.ConveyanceSystemType)
        elif nodeName_ == 'ConveyanceLoadType':
            ConveyanceLoadType_ = child_.text
            ConveyanceLoadType_ = self.gds_validate_string(ConveyanceLoadType_, node, 'ConveyanceLoadType')
            self.ConveyanceLoadType = ConveyanceLoadType_
            # validate type ConveyanceLoadTypeType
            self.validate_ConveyanceLoadTypeType(self.ConveyanceLoadType)
        elif nodeName_ == 'ConveyancePeakPower':
            obj_ = ConveyancePeakPowerType.factory()
            obj_.build(child_)
            self.ConveyancePeakPower = obj_
            obj_.original_tagname_ = 'ConveyancePeakPower'
        elif nodeName_ == 'ConveyanceStandbyPower':
            obj_ = ConveyanceStandbyPowerType.factory()
            obj_.build(child_)
            self.ConveyanceStandbyPower = obj_
            obj_.original_tagname_ = 'ConveyanceStandbyPower'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ConveyanceSystemType


class OnSiteStorageTransmissionGenerationSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, EnergyConversionType=None, BackupGenerator=None, DemandReduction=None, Capacity=None, CapacityUnits=None, ControlTechnology=None, ThirdPartyCertification=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.EnergyConversionType = EnergyConversionType
        self.BackupGenerator = BackupGenerator
        self.DemandReduction = DemandReduction
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnSiteStorageTransmissionGenerationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnSiteStorageTransmissionGenerationSystemType.subclass:
            return OnSiteStorageTransmissionGenerationSystemType.subclass(*args_, **kwargs_)
        else:
            return OnSiteStorageTransmissionGenerationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.EnergyConversionType is not None or
            self.BackupGenerator is not None or
            self.DemandReduction is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.ControlTechnology is not None or
            self.ThirdPartyCertification is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnSiteStorageTransmissionGenerationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyConversionType is not None:
            self.EnergyConversionType.export(outfile, level, namespace_, name_='EnergyConversionType', pretty_print=pretty_print)
        if self.BackupGenerator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackupGenerator>%s</%sBackupGenerator>%s' % (namespace_, self.gds_format_boolean(self.BackupGenerator, input_name='BackupGenerator'), namespace_, eol_))
        if self.DemandReduction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDemandReduction>%s</%sDemandReduction>%s' % (namespace_, self.gds_format_boolean(self.DemandReduction, input_name='DemandReduction'), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyConversionType':
            obj_ = EnergyConversionTypeType.factory()
            obj_.build(child_)
            self.EnergyConversionType = obj_
            obj_.original_tagname_ = 'EnergyConversionType'
        elif nodeName_ == 'BackupGenerator':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BackupGenerator')
            self.BackupGenerator = ival_
        elif nodeName_ == 'DemandReduction':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DemandReduction')
            self.DemandReduction = ival_
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class OnSiteStorageTransmissionGenerationSystemType


class PoolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, PoolType_member=None, PoolSizeCategory=None, PoolArea=None, PoolVolume=None, PumpDutyCycle=None, Heated=None, ThirdPartyCertification=None, Quantity=None, YearInstalled=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.PoolType = PoolType_member
        self.validate_PoolTypeType(self.PoolType)
        self.PoolSizeCategory = PoolSizeCategory
        self.validate_PoolSizeCategoryType(self.PoolSizeCategory)
        self.PoolArea = PoolArea
        self.PoolVolume = PoolVolume
        self.PumpDutyCycle = PumpDutyCycle
        self.Heated = Heated
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoolType.subclass:
            return PoolType.subclass(*args_, **kwargs_)
        else:
            return PoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PoolTypeType(self, value):
        # Validate type PoolTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hot Tub', 'Pool', 'Fountain', 'Water Fall', 'Stream', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PoolTypeType' % {"value" : value.encode("utf-8")} )
    def validate_PoolSizeCategoryType(self, value):
        # Validate type PoolSizeCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Olympic', 'Recreational', 'Short Course', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PoolSizeCategoryType' % {"value" : value.encode("utf-8")} )
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PoolType is not None or
            self.PoolSizeCategory is not None or
            self.PoolArea is not None or
            self.PoolVolume is not None or
            self.PumpDutyCycle is not None or
            self.Heated is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PoolType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PoolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PoolType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PoolType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPoolType>%s</%sPoolType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PoolType), input_name='PoolType')), namespace_, eol_))
        if self.PoolSizeCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPoolSizeCategory>%s</%sPoolSizeCategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PoolSizeCategory), input_name='PoolSizeCategory')), namespace_, eol_))
        if self.PoolArea is not None:
            self.PoolArea.export(outfile, level, namespace_, name_='PoolArea', pretty_print=pretty_print)
        if self.PoolVolume is not None:
            self.PoolVolume.export(outfile, level, namespace_, name_='PoolVolume', pretty_print=pretty_print)
        if self.PumpDutyCycle is not None:
            self.PumpDutyCycle.export(outfile, level, namespace_, name_='PumpDutyCycle', pretty_print=pretty_print)
        if self.Heated is not None:
            self.Heated.export(outfile, level, namespace_, name_='Heated', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PoolType':
            PoolType_ = child_.text
            PoolType_ = self.gds_validate_string(PoolType_, node, 'PoolType')
            self.PoolType = PoolType_
            # validate type PoolTypeType
            self.validate_PoolTypeType(self.PoolType)
        elif nodeName_ == 'PoolSizeCategory':
            PoolSizeCategory_ = child_.text
            PoolSizeCategory_ = self.gds_validate_string(PoolSizeCategory_, node, 'PoolSizeCategory')
            self.PoolSizeCategory = PoolSizeCategory_
            # validate type PoolSizeCategoryType
            self.validate_PoolSizeCategoryType(self.PoolSizeCategory)
        elif nodeName_ == 'PoolArea':
            obj_ = PoolAreaType.factory()
            obj_.build(child_)
            self.PoolArea = obj_
            obj_.original_tagname_ = 'PoolArea'
        elif nodeName_ == 'PoolVolume':
            obj_ = PoolVolumeType.factory()
            obj_.build(child_)
            self.PoolVolume = obj_
            obj_.original_tagname_ = 'PoolVolume'
        elif nodeName_ == 'PumpDutyCycle':
            obj_ = PumpDutyCycleType.factory()
            obj_.build(child_)
            self.PumpDutyCycle = obj_
            obj_.original_tagname_ = 'PumpDutyCycle'
        elif nodeName_ == 'Heated':
            obj_ = HeatedType.factory()
            obj_.build(child_)
            self.Heated = obj_
            obj_.original_tagname_ = 'Heated'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class PoolType


class WaterUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, WaterUseType_member=None, WaterResource=None, LowFlowFixtures=None, WaterFixtureRatedFlowRate=None, WaterFixtureVolumePerCycle=None, WaterFixtureCyclesPerDay=None, WaterFixtureFractionHotWater=None, ThirdPartyCertification=None, ControlTechnology=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Location=None, LinkedPremises=None, UserDefinedFields=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.WaterUseType = WaterUseType_member
        self.validate_WaterUseTypeType(self.WaterUseType)
        self.WaterResource = WaterResource
        self.validate_WaterResource(self.WaterResource)
        self.LowFlowFixtures = LowFlowFixtures
        self.WaterFixtureRatedFlowRate = WaterFixtureRatedFlowRate
        self.WaterFixtureVolumePerCycle = WaterFixtureVolumePerCycle
        self.WaterFixtureCyclesPerDay = WaterFixtureCyclesPerDay
        self.WaterFixtureFractionHotWater = WaterFixtureFractionHotWater
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterUseType.subclass:
            return WaterUseType.subclass(*args_, **kwargs_)
        else:
            return WaterUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WaterUseTypeType(self, value):
        # Validate type WaterUseTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Restroom Sink Use', 'Restroom Toilet/Urinal Water Use', 'Kitchen Water Use', 'Shower Facility Water Use', 'Drinking Fountain Water Use', 'Janitorial Water Use', 'Laundry Water Use', 'Indoor Washdown Water Use (if indoor)', 'Outdoor Landscape Water Use', 'Outdoor Non-Landscape Water Use', 'Outdoor Washdown Water Use (if outdoor)', 'Cooling Tower Make-up Water Use', 'Hydronic Loop Make-up Water Use', 'Evaporative Cooling System Water Use', 'Pre-Treatment Process Water Use', 'Captured Rain Water', 'Recycled Greywater', 'Condensate Recovery', 'Stormwater Sewer Production', 'Stormwater Discharge', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WaterUseTypeType' % {"value" : value.encode("utf-8")} )
    def validate_WaterResource(self, value):
        # Validate type WaterResource, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.WaterUseType is not None or
            self.WaterResource is not None or
            self.LowFlowFixtures is not None or
            self.WaterFixtureRatedFlowRate is not None or
            self.WaterFixtureVolumePerCycle is not None or
            self.WaterFixtureCyclesPerDay is not None or
            self.WaterFixtureFractionHotWater is not None or
            self.ThirdPartyCertification is not None or
            self.ControlTechnology is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterUseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterUseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterUseType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterUseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WaterUseType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterUseType>%s</%sWaterUseType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterUseType), input_name='WaterUseType')), namespace_, eol_))
        if self.WaterResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterResource>%s</%sWaterResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterResource), input_name='WaterResource')), namespace_, eol_))
        if self.LowFlowFixtures is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLowFlowFixtures>%s</%sLowFlowFixtures>%s' % (namespace_, self.gds_format_boolean(self.LowFlowFixtures, input_name='LowFlowFixtures'), namespace_, eol_))
        if self.WaterFixtureRatedFlowRate is not None:
            self.WaterFixtureRatedFlowRate.export(outfile, level, namespace_, name_='WaterFixtureRatedFlowRate', pretty_print=pretty_print)
        if self.WaterFixtureVolumePerCycle is not None:
            self.WaterFixtureVolumePerCycle.export(outfile, level, namespace_, name_='WaterFixtureVolumePerCycle', pretty_print=pretty_print)
        if self.WaterFixtureCyclesPerDay is not None:
            self.WaterFixtureCyclesPerDay.export(outfile, level, namespace_, name_='WaterFixtureCyclesPerDay', pretty_print=pretty_print)
        if self.WaterFixtureFractionHotWater is not None:
            self.WaterFixtureFractionHotWater.export(outfile, level, namespace_, name_='WaterFixtureFractionHotWater', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterUseType':
            WaterUseType_ = child_.text
            WaterUseType_ = self.gds_validate_string(WaterUseType_, node, 'WaterUseType')
            self.WaterUseType = WaterUseType_
            # validate type WaterUseTypeType
            self.validate_WaterUseTypeType(self.WaterUseType)
        elif nodeName_ == 'WaterResource':
            WaterResource_ = child_.text
            WaterResource_ = self.gds_validate_string(WaterResource_, node, 'WaterResource')
            self.WaterResource = WaterResource_
            # validate type WaterResource
            self.validate_WaterResource(self.WaterResource)
        elif nodeName_ == 'LowFlowFixtures':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LowFlowFixtures')
            self.LowFlowFixtures = ival_
        elif nodeName_ == 'WaterFixtureRatedFlowRate':
            obj_ = WaterFixtureRatedFlowRateType.factory()
            obj_.build(child_)
            self.WaterFixtureRatedFlowRate = obj_
            obj_.original_tagname_ = 'WaterFixtureRatedFlowRate'
        elif nodeName_ == 'WaterFixtureVolumePerCycle':
            obj_ = WaterFixtureVolumePerCycleType.factory()
            obj_.build(child_)
            self.WaterFixtureVolumePerCycle = obj_
            obj_.original_tagname_ = 'WaterFixtureVolumePerCycle'
        elif nodeName_ == 'WaterFixtureCyclesPerDay':
            obj_ = WaterFixtureCyclesPerDayType.factory()
            obj_.build(child_)
            self.WaterFixtureCyclesPerDay = obj_
            obj_.original_tagname_ = 'WaterFixtureCyclesPerDay'
        elif nodeName_ == 'WaterFixtureFractionHotWater':
            obj_ = WaterFixtureFractionHotWaterType.factory()
            obj_.build(child_)
            self.WaterFixtureFractionHotWater = obj_
            obj_.original_tagname_ = 'WaterFixtureFractionHotWater'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class WaterUseType


class CalculationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Simulated=None, Measured=None, Estimated=None, Other=None):
        self.original_tagname_ = None
        self.Simulated = Simulated
        self.Measured = Measured
        self.Estimated = Estimated
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalculationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalculationMethodType.subclass:
            return CalculationMethodType.subclass(*args_, **kwargs_)
        else:
            return CalculationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Simulated is not None or
            self.Measured is not None or
            self.Estimated is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CalculationMethodType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalculationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CalculationMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CalculationMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CalculationMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Simulated is not None:
            self.Simulated.export(outfile, level, namespace_, name_='Simulated', pretty_print=pretty_print)
        if self.Measured is not None:
            self.Measured.export(outfile, level, namespace_, name_='Measured', pretty_print=pretty_print)
        if self.Estimated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEstimated>%s</%sEstimated>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Estimated), input_name='Estimated')), namespace_, eol_))
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Simulated':
            obj_ = SimulatedType.factory()
            obj_.build(child_)
            self.Simulated = obj_
            obj_.original_tagname_ = 'Simulated'
        elif nodeName_ == 'Measured':
            obj_ = MeasuredType.factory()
            obj_.build(child_)
            self.Measured = obj_
            obj_.original_tagname_ = 'Measured'
        elif nodeName_ == 'Estimated':
            Estimated_ = child_.text
            Estimated_ = self.gds_validate_string(Estimated_, node, 'Estimated')
            self.Estimated = Estimated_
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class CalculationMethodType


class Estimated(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Estimated)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Estimated.subclass:
            return Estimated.subclass(*args_, **kwargs_)
        else:
            return Estimated(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Estimated', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Estimated')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Estimated', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Estimated'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Estimated', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Estimated


class Quantity(GeneratedsSuper):
    """Number of systems of this type."""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quantity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quantity.subclass:
            return Quantity.subclass(*args_, **kwargs_)
        else:
            return Quantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Quantity', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quantity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Quantity'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Quantity', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Quantity


class Location(GeneratedsSuper):
    """Location of system."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Location', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Location', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Location'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Location', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Location


class Capacity(GeneratedsSuper):
    """Capacity of the system at rated conditions."""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Capacity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Capacity.subclass:
            return Capacity.subclass(*args_, **kwargs_)
        else:
            return Capacity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Capacity', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Capacity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Capacity'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Capacity', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Capacity


class CapacityUnits(GeneratedsSuper):
    """Units used to measure capacity."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CapacityUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CapacityUnits.subclass:
            return CapacityUnits.subclass(*args_, **kwargs_)
        else:
            return CapacityUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CapacityUnits', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityUnits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CapacityUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CapacityUnits'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CapacityUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CapacityUnits


class ControlTechnology(GeneratedsSuper):
    """Type of system operation control."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlTechnology)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlTechnology.subclass:
            return ControlTechnology.subclass(*args_, **kwargs_)
        else:
            return ControlTechnology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ControlTechnology', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlTechnology')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ControlTechnology', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ControlTechnology'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ControlTechnology', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ControlTechnology


class Refrigerant(GeneratedsSuper):
    """The type of refrigerant used in the system."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Refrigerant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Refrigerant.subclass:
            return Refrigerant.subclass(*args_, **kwargs_)
        else:
            return Refrigerant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Refrigerant', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Refrigerant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Refrigerant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Refrigerant'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Refrigerant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Refrigerant


class LinkedPremises(GeneratedsSuper):
    """Establishes whether the system applies to one or more entire
    buildings, blocks, spaces, or zones within buildings. Power
    consuming system loads should be distributed in proportion to
    the floor areas of linked premises. Envelope systems should be
    distributed in proportion to the exterior surface areas of
    linked premises."""
    subclass = None
    superclass = None
    def __init__(self, Site=None, Facility=None, Block=None, Zone=None, Space=None):
        self.original_tagname_ = None
        self.Site = Site
        self.Facility = Facility
        self.Block = Block
        self.Zone = Zone
        self.Space = Space
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedPremises)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedPremises.subclass:
            return LinkedPremises.subclass(*args_, **kwargs_)
        else:
            return LinkedPremises(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Site is not None or
            self.Facility is not None or
            self.Block is not None or
            self.Zone is not None or
            self.Space is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedPremises', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedPremises')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedPremises'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedPremises', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Site is not None:
            self.Site.export(outfile, level, namespace_, name_='Site', pretty_print=pretty_print)
        if self.Facility is not None:
            self.Facility.export(outfile, level, namespace_, name_='Facility', pretty_print=pretty_print)
        if self.Block is not None:
            self.Block.export(outfile, level, namespace_, name_='Block', pretty_print=pretty_print)
        if self.Zone is not None:
            self.Zone.export(outfile, level, namespace_, name_='Zone', pretty_print=pretty_print)
        if self.Space is not None:
            self.Space.export(outfile, level, namespace_, name_='Space', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Site':
            obj_ = SiteType198.factory()
            obj_.build(child_)
            self.Site = obj_
            obj_.original_tagname_ = 'Site'
        elif nodeName_ == 'Facility':
            obj_ = FacilityType.factory()
            obj_.build(child_)
            self.Facility = obj_
            obj_.original_tagname_ = 'Facility'
        elif nodeName_ == 'Block':
            obj_ = BlockType200.factory()
            obj_.build(child_)
            self.Block = obj_
            obj_.original_tagname_ = 'Block'
        elif nodeName_ == 'Zone':
            obj_ = ZoneType202.factory()
            obj_.build(child_)
            self.Zone = obj_
            obj_.original_tagname_ = 'Zone'
        elif nodeName_ == 'Space':
            obj_ = SpaceType204.factory()
            obj_.build(child_)
            self.Space = obj_
            obj_.original_tagname_ = 'Space'
# end class LinkedPremises


class Address(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StreetAddressDetail=None, City=None, State=None, PostalCode=None, PostalCodePlus4=None, County=None):
        self.original_tagname_ = None
        self.StreetAddressDetail = StreetAddressDetail
        self.City = City
        self.State = State
        self.validate_State(self.State)
        self.PostalCode = PostalCode
        self.PostalCodePlus4 = PostalCodePlus4
        self.County = County
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_State(self, value):
        # Validate type State, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AA', 'AE', 'AL', 'AK', 'AP', 'AS', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'DC', 'FM', 'FL', 'GA', 'GU', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MH', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'MP', 'OH', 'OK', 'OR', 'PW', 'PA', 'PR', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VI', 'VA', 'WA', 'WV', 'WI', 'WY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on State' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.StreetAddressDetail is not None or
            self.City is not None or
            self.State is not None or
            self.PostalCode is not None or
            self.PostalCodePlus4 is not None or
            self.County is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Address', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetAddressDetail is not None:
            self.StreetAddressDetail.export(outfile, level, namespace_, name_='StreetAddressDetail', pretty_print=pretty_print)
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), namespace_, eol_))
        if self.State is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sState>%s</%sState>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.State), input_name='State')), namespace_, eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostalCode>%s</%sPostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), namespace_, eol_))
        if self.PostalCodePlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostalCodePlus4>%s</%sPostalCodePlus4>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PostalCodePlus4), input_name='PostalCodePlus4')), namespace_, eol_))
        if self.County is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCounty>%s</%sCounty>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.County), input_name='County')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetAddressDetail':
            obj_ = StreetAddressDetailType.factory()
            obj_.build(child_)
            self.StreetAddressDetail = obj_
            obj_.original_tagname_ = 'StreetAddressDetail'
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'State':
            State_ = child_.text
            State_ = self.gds_validate_string(State_, node, 'State')
            self.State = State_
            # validate type State
            self.validate_State(self.State)
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'PostalCodePlus4':
            PostalCodePlus4_ = child_.text
            PostalCodePlus4_ = self.gds_validate_string(PostalCodePlus4_, node, 'PostalCodePlus4')
            self.PostalCodePlus4 = PostalCodePlus4_
        elif nodeName_ == 'County':
            County_ = child_.text
            County_ = self.gds_validate_string(County_, node, 'County')
            self.County = County_
# end class Address


class ThirdPartyCertification(GeneratedsSuper):
    """Independent organization has verified that product or appliance
    meets or exceeds the standard in question (ENERGY STAR, CEE, or
    other)."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThirdPartyCertification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThirdPartyCertification.subclass:
            return ThirdPartyCertification.subclass(*args_, **kwargs_)
        else:
            return ThirdPartyCertification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ThirdPartyCertification', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThirdPartyCertification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ThirdPartyCertification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ThirdPartyCertification'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ThirdPartyCertification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThirdPartyCertification


class Ownership(GeneratedsSuper):
    """The type of organization, association, business, etc. that owns the
    premises"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ownership)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ownership.subclass:
            return Ownership.subclass(*args_, **kwargs_)
        else:
            return Ownership(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Ownership', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ownership')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Ownership', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Ownership'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Ownership', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Ownership


class OwnershipStatus(GeneratedsSuper):
    """Ownership status of the premises with respect to the occupant"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OwnershipStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OwnershipStatus.subclass:
            return OwnershipStatus.subclass(*args_, **kwargs_)
        else:
            return OwnershipStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OwnershipStatus', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OwnershipStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OwnershipStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OwnershipStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OwnershipStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OwnershipStatus


class IdentifierLabel(GeneratedsSuper):
    """Identifier used in a specific program or dataset. There can be
    multiple instances of Identifier Types within a dataset, such as
    a Listing ID, a Tax Map Number ID, and a Custom ID."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifierLabel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifierLabel.subclass:
            return IdentifierLabel.subclass(*args_, **kwargs_)
        else:
            return IdentifierLabel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IdentifierLabel', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierLabel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IdentifierLabel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IdentifierLabel'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IdentifierLabel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifierLabel


class PremisesIdentifiers(GeneratedsSuper):
    """Identifier used in a specific program or dataset. There can be
    multiple instances of Identifier Types within a dataset."""
    subclass = None
    superclass = None
    def __init__(self, IdentifierLabel=None, IdentifierCustomName=None, IdentifierValue=None):
        self.original_tagname_ = None
        self.IdentifierLabel = IdentifierLabel
        self.validate_IdentifierLabel(self.IdentifierLabel)
        self.IdentifierCustomName = IdentifierCustomName
        self.IdentifierValue = IdentifierValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PremisesIdentifiers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PremisesIdentifiers.subclass:
            return PremisesIdentifiers.subclass(*args_, **kwargs_)
        else:
            return PremisesIdentifiers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_IdentifierLabel(self, value):
        # Validate type IdentifierLabel, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IdentifierLabel is not None or
            self.IdentifierCustomName is not None or
            self.IdentifierValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PremisesIdentifiers', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PremisesIdentifiers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PremisesIdentifiers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PremisesIdentifiers'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PremisesIdentifiers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IdentifierLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifierLabel>%s</%sIdentifierLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IdentifierLabel), input_name='IdentifierLabel')), namespace_, eol_))
        if self.IdentifierCustomName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifierCustomName>%s</%sIdentifierCustomName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IdentifierCustomName), input_name='IdentifierCustomName')), namespace_, eol_))
        if self.IdentifierValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifierValue>%s</%sIdentifierValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IdentifierValue), input_name='IdentifierValue')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentifierLabel':
            IdentifierLabel_ = child_.text
            IdentifierLabel_ = self.gds_validate_string(IdentifierLabel_, node, 'IdentifierLabel')
            self.IdentifierLabel = IdentifierLabel_
            # validate type IdentifierLabel
            self.validate_IdentifierLabel(self.IdentifierLabel)
        elif nodeName_ == 'IdentifierCustomName':
            IdentifierCustomName_ = child_.text
            IdentifierCustomName_ = self.gds_validate_string(IdentifierCustomName_, node, 'IdentifierCustomName')
            self.IdentifierCustomName = IdentifierCustomName_
        elif nodeName_ == 'IdentifierValue':
            IdentifierValue_ = child_.text
            IdentifierValue_ = self.gds_validate_string(IdentifierValue_, node, 'IdentifierValue')
            self.IdentifierValue = IdentifierValue_
# end class PremisesIdentifiers


class OccupancyClassification(GeneratedsSuper):
    """Classification of the space (complex, whole building, or subsection)
    tasks by building occupants."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OccupancyClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OccupancyClassification.subclass:
            return OccupancyClassification.subclass(*args_, **kwargs_)
        else:
            return OccupancyClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OccupancyClassification', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupancyClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OccupancyClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OccupancyClassification'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OccupancyClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OccupancyClassification


class UserDefinedFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UserDefinedField=None):
        self.original_tagname_ = None
        if UserDefinedField is None:
            self.UserDefinedField = []
        else:
            self.UserDefinedField = UserDefinedField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UserDefinedFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UserDefinedFields.subclass:
            return UserDefinedFields.subclass(*args_, **kwargs_)
        else:
            return UserDefinedFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.UserDefinedField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UserDefinedFields', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UserDefinedFields'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UserDefinedFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UserDefinedField_ in self.UserDefinedField:
            UserDefinedField_.export(outfile, level, namespace_, name_='UserDefinedField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UserDefinedField':
            obj_ = UserDefinedFieldType.factory()
            obj_.build(child_)
            self.UserDefinedField.append(obj_)
            obj_.original_tagname_ = 'UserDefinedField'
# end class UserDefinedFields


class PrimaryContactID(GeneratedsSuper):
    """Primary contact ID number for the premises."""
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryContactID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryContactID.subclass:
            return PrimaryContactID.subclass(*args_, **kwargs_)
        else:
            return PrimaryContactID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PrimaryContactID', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimaryContactID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PrimaryContactID', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PrimaryContactID'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PrimaryContactID', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PrimaryContactID


class FloorAreas(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FloorArea=None):
        self.original_tagname_ = None
        if FloorArea is None:
            self.FloorArea = []
        else:
            self.FloorArea = FloorArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorAreas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorAreas.subclass:
            return FloorAreas.subclass(*args_, **kwargs_)
        else:
            return FloorAreas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FloorArea
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorAreas', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorAreas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorAreas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorAreas'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorAreas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FloorArea_ in self.FloorArea:
            FloorArea_.export(outfile, level, namespace_, name_='FloorArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FloorArea':
            obj_ = FloorAreaType206.factory()
            obj_.build(child_)
            self.FloorArea.append(obj_)
            obj_.original_tagname_ = 'FloorArea'
# end class FloorAreas


class OccupancyLevels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OccupancyLevel=None):
        self.original_tagname_ = None
        if OccupancyLevel is None:
            self.OccupancyLevel = []
        else:
            self.OccupancyLevel = OccupancyLevel
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OccupancyLevels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OccupancyLevels.subclass:
            return OccupancyLevels.subclass(*args_, **kwargs_)
        else:
            return OccupancyLevels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.OccupancyLevel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OccupancyLevels', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupancyLevels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OccupancyLevels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OccupancyLevels'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OccupancyLevels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OccupancyLevel_ in self.OccupancyLevel:
            OccupancyLevel_.export(outfile, level, namespace_, name_='OccupancyLevel', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OccupancyLevel':
            obj_ = OccupancyLevelType.factory()
            obj_.build(child_)
            self.OccupancyLevel.append(obj_)
            obj_.original_tagname_ = 'OccupancyLevel'
# end class OccupancyLevels


class EnergyResource(GeneratedsSuper):
    """Type of energy resource fuel. This can be applied at the premises or
    individual system or equipment level."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyResource.subclass:
            return EnergyResource.subclass(*args_, **kwargs_)
        else:
            return EnergyResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyResource', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyResource'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyResource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyResource


class ResourceUnits(GeneratedsSuper):
    """Units for resource consumption or generation"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceUnits.subclass:
            return ResourceUnits.subclass(*args_, **kwargs_)
        else:
            return ResourceUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResourceUnits', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceUnits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResourceUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResourceUnits'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResourceUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceUnits


class DutyCycle(GeneratedsSuper):
    """Percent of time the system operates (0-1) (%)"""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DutyCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DutyCycle.subclass:
            return DutyCycle.subclass(*args_, **kwargs_)
        else:
            return DutyCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DutyCycle', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DutyCycle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DutyCycle'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DutyCycle', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DutyCycle


class SystemPerformanceRatio(GeneratedsSuper):
    """Ratio of annual system load to the annual system energy consumption
    (similar to a whole system COP). A higher value indicates less
    heating and/or cooling energy use to meet the loads, and
    therefore represents a more efficient HVAC system. SPR can be
    used to describe the heating, cooling, and overall HVAC systems."""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SystemPerformanceRatio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SystemPerformanceRatio.subclass:
            return SystemPerformanceRatio.subclass(*args_, **kwargs_)
        else:
            return SystemPerformanceRatio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SystemPerformanceRatio')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SystemPerformanceRatio'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SystemPerformanceRatio


class EnergyUseByFuelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PrimaryFuel=None, EnergyUse=None):
        self.original_tagname_ = None
        self.PrimaryFuel = PrimaryFuel
        self.validate_FuelTypes(self.PrimaryFuel)
        self.EnergyUse = EnergyUse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyUseByFuelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyUseByFuelType.subclass:
            return EnergyUseByFuelType.subclass(*args_, **kwargs_)
        else:
            return EnergyUseByFuelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PrimaryFuel is not None or
            self.EnergyUse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyUseByFuelType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyUseByFuelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyUseByFuelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyUseByFuelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyUseByFuelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % ('auc:', self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), 'auc:', eol_))
        if self.EnergyUse is not None:
            self.EnergyUse.export(outfile, level, namespace_, name_='EnergyUse', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.PrimaryFuel)
        elif nodeName_ == 'EnergyUse':
            obj_ = EnergyUseType.factory()
            obj_.build(child_)
            self.EnergyUse = obj_
            obj_.original_tagname_ = 'EnergyUse'
# end class EnergyUseByFuelType


class AssetScoreData(GeneratedsSuper):
    """A facility's Commercial Building Energy Asset Score, and optional
    Site/Source energy use by fuel type."""
    subclass = None
    superclass = None
    def __init__(self, Score=None, SiteEnergyUse=None, SourceEnergyUse=None):
        self.original_tagname_ = None
        self.Score = Score
        self.SiteEnergyUse = SiteEnergyUse
        self.SourceEnergyUse = SourceEnergyUse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetScoreData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetScoreData.subclass:
            return AssetScoreData.subclass(*args_, **kwargs_)
        else:
            return AssetScoreData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Score is not None or
            self.SiteEnergyUse is not None or
            self.SourceEnergyUse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AssetScoreData', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetScoreData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AssetScoreData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AssetScoreData'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AssetScoreData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Score is not None:
            self.Score.export(outfile, level, namespace_, name_='Score', pretty_print=pretty_print)
        if self.SiteEnergyUse is not None:
            self.SiteEnergyUse.export(outfile, level, namespace_, name_='SiteEnergyUse', pretty_print=pretty_print)
        if self.SourceEnergyUse is not None:
            self.SourceEnergyUse.export(outfile, level, namespace_, name_='SourceEnergyUse', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Score':
            obj_ = ScoreType.factory()
            obj_.build(child_)
            self.Score = obj_
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'SiteEnergyUse':
            obj_ = SiteEnergyUseType208.factory()
            obj_.build(child_)
            self.SiteEnergyUse = obj_
            obj_.original_tagname_ = 'SiteEnergyUse'
        elif nodeName_ == 'SourceEnergyUse':
            obj_ = SourceEnergyUseType209.factory()
            obj_.build(child_)
            self.SourceEnergyUse = obj_
            obj_.original_tagname_ = 'SourceEnergyUse'
# end class AssetScoreData


class AssetScore(GeneratedsSuper):
    """A facility's Commercial Building Energy Asset Score Data."""
    subclass = None
    superclass = None
    def __init__(self, WholeBuilding=None, UseType=None):
        self.original_tagname_ = None
        self.WholeBuilding = WholeBuilding
        if UseType is None:
            self.UseType = []
        else:
            self.UseType = UseType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssetScore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssetScore.subclass:
            return AssetScore.subclass(*args_, **kwargs_)
        else:
            return AssetScore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.WholeBuilding is not None or
            self.UseType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AssetScore', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssetScore')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AssetScore', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AssetScore'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AssetScore', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WholeBuilding is not None:
            self.WholeBuilding.export(outfile, level, namespace_, name_='WholeBuilding', pretty_print=pretty_print)
        for UseType_ in self.UseType:
            UseType_.export(outfile, level, namespace_, name_='UseType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WholeBuilding':
            obj_ = WholeBuildingType.factory()
            obj_.build(child_)
            self.WholeBuilding = obj_
            obj_.original_tagname_ = 'WholeBuilding'
        elif nodeName_ == 'UseType':
            obj_ = UseTypeType.factory()
            obj_.build(child_)
            self.UseType.append(obj_)
            obj_.original_tagname_ = 'UseType'
# end class AssetScore


class ENERGYSTARScore(GeneratedsSuper):
    """The ENERGY STAR Score is a measure of how well the property is
    performing relative to similar properties. The ENERGY STAR
    scores are based on data from national building energy
    consumption surveys, and allows Portfolio Manager to control for
    key variables affecting a building's energy performance,
    including climate, hours of operation, and building size."""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENERGYSTARScore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENERGYSTARScore.subclass:
            return ENERGYSTARScore.subclass(*args_, **kwargs_)
        else:
            return ENERGYSTARScore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ENERGYSTARScore', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENERGYSTARScore')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ENERGYSTARScore', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ENERGYSTARScore'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ENERGYSTARScore', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ENERGYSTARScore


class ReferenceCase(GeneratedsSuper):
    """ID number for scenario that serves as the reference case for
    calculating energy savings, simple payback, etc."""
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceCase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceCase.subclass:
            return ReferenceCase.subclass(*args_, **kwargs_)
        else:
            return ReferenceCase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ReferenceCase', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceCase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ReferenceCase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ReferenceCase'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ReferenceCase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferenceCase


class WeatherDataSource(GeneratedsSuper):
    """Method for determining weather data associated with the time series"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherDataSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherDataSource.subclass:
            return WeatherDataSource.subclass(*args_, **kwargs_)
        else:
            return WeatherDataSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WeatherDataSource', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherDataSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WeatherDataSource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WeatherDataSource'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WeatherDataSource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeatherDataSource


class CostEffectivenessScreeningMethod(GeneratedsSuper):
    """Method for calculating cost-effectiveness for measures or project."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CostEffectivenessScreeningMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CostEffectivenessScreeningMethod.subclass:
            return CostEffectivenessScreeningMethod.subclass(*args_, **kwargs_)
        else:
            return CostEffectivenessScreeningMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CostEffectivenessScreeningMethod', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CostEffectivenessScreeningMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CostEffectivenessScreeningMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CostEffectivenessScreeningMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CostEffectivenessScreeningMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CostEffectivenessScreeningMethod


class AnnualHeatingEfficiencyUnit(GeneratedsSuper):
    """The measure used to quantify efficiency"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingEfficiencyUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingEfficiencyUnit.subclass:
            return AnnualHeatingEfficiencyUnit.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingEfficiencyUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyUnit', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingEfficiencyUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingEfficiencyUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingEfficiencyUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingEfficiencyUnit


class BurnerType(GeneratedsSuper):
    """Type of burner on boiler or furnace, if applicable."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BurnerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BurnerType.subclass:
            return BurnerType.subclass(*args_, **kwargs_)
        else:
            return BurnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BurnerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BurnerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BurnerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BurnerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BurnerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BurnerType


class IgnitionType(GeneratedsSuper):
    """Ignition mechanism in gas heating equipment. Either pilot light or
    an intermittent ignition device (IID)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IgnitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IgnitionType.subclass:
            return IgnitionType.subclass(*args_, **kwargs_)
        else:
            return IgnitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IgnitionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IgnitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IgnitionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IgnitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IgnitionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IgnitionType


class DraftType(GeneratedsSuper):
    """Draft mechanism used for drawing air through the boiler or furnace."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DraftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DraftType.subclass:
            return DraftType.subclass(*args_, **kwargs_)
        else:
            return DraftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DraftType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DraftType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DraftType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DraftType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DraftType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DraftType


class HeatingStaging(GeneratedsSuper):
    """The method of heating staging used by the unit. Select "Single
    Stage" for units with single stage (on/off) control. Select
    "Multiple, Discrete Stages" for units with multiple discrete
    stages (low-fire / high-fire). Select "Modulating" for units
    which contain modulating burners."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingStaging)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingStaging.subclass:
            return HeatingStaging.subclass(*args_, **kwargs_)
        else:
            return HeatingStaging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingStaging', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingStaging')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingStaging', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingStaging'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingStaging', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingStaging


class Priority(GeneratedsSuper):
    """Order of precedence relative to other applicable systems. Enter
    Primary if this is the only system."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Priority)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Priority.subclass:
            return Priority.subclass(*args_, **kwargs_)
        else:
            return Priority(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Priority', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Priority')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Priority', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Priority'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Priority', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Priority


class CompressorStaging(GeneratedsSuper):
    """The compressor staging for the unit. Select "Single Stage" for units
    with single stage (on/off) control. Select "Multiple, Discrete
    Stages" for units with multiple compressors, discrete unloading
    stages, or compressors with stepped speed motors that are
    controlled to operate at discrete stages. Select "Variable" for
    compressors that operate at variable speeds or with modulating
    unloading."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompressorStaging)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompressorStaging.subclass:
            return CompressorStaging.subclass(*args_, **kwargs_)
        else:
            return CompressorStaging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CompressorStaging', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompressorStaging')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CompressorStaging', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CompressorStaging'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CompressorStaging', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompressorStaging


class AnnualCoolingEfficiencyUnits(GeneratedsSuper):
    """The measure used to quantify efficiency"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualCoolingEfficiencyUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualCoolingEfficiencyUnits.subclass:
            return AnnualCoolingEfficiencyUnits.subclass(*args_, **kwargs_)
        else:
            return AnnualCoolingEfficiencyUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyUnits', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualCoolingEfficiencyUnits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualCoolingEfficiencyUnits', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualCoolingEfficiencyUnits'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyUnits', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualCoolingEfficiencyUnits


class WaterCooledCondenserFlowControl(GeneratedsSuper):
    """Describes water flow control for a water-cooled condenser."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterCooledCondenserFlowControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterCooledCondenserFlowControl.subclass:
            return WaterCooledCondenserFlowControl.subclass(*args_, **kwargs_)
        else:
            return WaterCooledCondenserFlowControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterCooledCondenserFlowControl', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterCooledCondenserFlowControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterCooledCondenserFlowControl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterCooledCondenserFlowControl'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterCooledCondenserFlowControl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterCooledCondenserFlowControl


class WaterSideEconomizerType(GeneratedsSuper):
    """Describes water flow control for a water-cooled condenser."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerType.subclass:
            return WaterSideEconomizerType.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerType


class VentilationControlMethod(GeneratedsSuper):
    """The method used to control the rate of outside air ventilation."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VentilationControlMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VentilationControlMethod.subclass:
            return VentilationControlMethod.subclass(*args_, **kwargs_)
        else:
            return VentilationControlMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VentilationControlMethod', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VentilationControlMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VentilationControlMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VentilationControlMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VentilationControlMethod', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VentilationControlMethod


class FluorescentStartType(GeneratedsSuper):
    """Start technology used with fluorescent ballasts"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FluorescentStartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FluorescentStartType.subclass:
            return FluorescentStartType.subclass(*args_, **kwargs_)
        else:
            return FluorescentStartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FluorescentStartType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FluorescentStartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FluorescentStartType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FluorescentStartType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FluorescentStartType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FluorescentStartType


class ClothesWasherClassification(GeneratedsSuper):
    """The sector where clothes washer is commonly used."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherClassification.subclass:
            return ClothesWasherClassification.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherClassification', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherClassification', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherClassification'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherClassification', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherClassification


class ClothesWasherLoaderType(GeneratedsSuper):
    """The type of configuration of a laundry appliance. Such as front and
    top loading clothes washers."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherLoaderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherLoaderType.subclass:
            return ClothesWasherLoaderType.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherLoaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherLoaderType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherLoaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherLoaderType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherLoaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherLoaderType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherLoaderType


class DryerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerType.subclass:
            return DryerType.subclass(*args_, **kwargs_)
        else:
            return DryerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DryerType


class FoundationWallInsulationContinuity(GeneratedsSuper):
    """Insulation installation type."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationWallInsulationContinuity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationWallInsulationContinuity.subclass:
            return FoundationWallInsulationContinuity.subclass(*args_, **kwargs_)
        else:
            return FoundationWallInsulationContinuity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationContinuity', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationWallInsulationContinuity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationWallInsulationContinuity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationWallInsulationContinuity'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationContinuity', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationWallInsulationContinuity


class FoundationWallInsulationCondition(GeneratedsSuper):
    """Assessed condition of installed insulation."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationWallInsulationCondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationWallInsulationCondition.subclass:
            return FoundationWallInsulationCondition.subclass(*args_, **kwargs_)
        else:
            return FoundationWallInsulationCondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationCondition', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationWallInsulationCondition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationWallInsulationCondition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationWallInsulationCondition'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationCondition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationWallInsulationCondition


class SlabInsulationOrientation(GeneratedsSuper):
    """The location and extent of slab-on-grade floor insulation"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabInsulationOrientation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabInsulationOrientation.subclass:
            return SlabInsulationOrientation.subclass(*args_, **kwargs_)
        else:
            return SlabInsulationOrientation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabInsulationOrientation', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabInsulationOrientation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabInsulationOrientation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabInsulationOrientation'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabInsulationOrientation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabInsulationOrientation


class SlabInsulationCondition(GeneratedsSuper):
    """Assessed condition of installed insulation."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabInsulationCondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabInsulationCondition.subclass:
            return SlabInsulationCondition.subclass(*args_, **kwargs_)
        else:
            return SlabInsulationCondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabInsulationCondition', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabInsulationCondition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabInsulationCondition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabInsulationCondition'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabInsulationCondition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabInsulationCondition


class SlabHeating(GeneratedsSuper):
    """The classifications for floors in contact with the ground."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabHeating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabHeating.subclass:
            return SlabHeating.subclass(*args_, **kwargs_)
        else:
            return SlabHeating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabHeating', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabHeating')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabHeating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabHeating'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabHeating', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabHeating


class ResourceBoundary(GeneratedsSuper):
    """The boundary that encompases the measured resource."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceBoundary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceBoundary.subclass:
            return ResourceBoundary.subclass(*args_, **kwargs_)
        else:
            return ResourceBoundary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResourceBoundary', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceBoundary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResourceBoundary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResourceBoundary'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResourceBoundary', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceBoundary


class WaterResource(GeneratedsSuper):
    """Water type used as a resource on the premises."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterResource.subclass:
            return WaterResource.subclass(*args_, **kwargs_)
        else:
            return WaterResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterResource', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterResource'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterResource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterResource


class TemporalStatus(GeneratedsSuper):
    """Temporal characteristic of this measurement."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalStatus.subclass:
            return TemporalStatus.subclass(*args_, **kwargs_)
        else:
            return TemporalStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TemporalStatus', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TemporalStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TemporalStatus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TemporalStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TemporalStatus', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TemporalStatus


class AuditType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Sites=None, Systems=None, Schedules=None, Measures=None, Report=None, Contacts=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Sites = Sites
        self.Systems = Systems
        self.Schedules = Schedules
        self.Measures = Measures
        self.Report = Report
        self.Contacts = Contacts
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuditType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuditType.subclass:
            return AuditType.subclass(*args_, **kwargs_)
        else:
            return AuditType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Sites is not None or
            self.Systems is not None or
            self.Schedules is not None or
            self.Measures is not None or
            self.Report is not None or
            self.Contacts is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AuditType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuditType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AuditType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AuditType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AuditType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sites is not None:
            self.Sites.export(outfile, level, namespace_, name_='Sites', pretty_print=pretty_print)
        if self.Systems is not None:
            self.Systems.export(outfile, level, namespace_, name_='Systems', pretty_print=pretty_print)
        if self.Schedules is not None:
            self.Schedules.export(outfile, level, namespace_, name_='Schedules', pretty_print=pretty_print)
        if self.Measures is not None:
            self.Measures.export(outfile, level, namespace_, name_='Measures', pretty_print=pretty_print)
        if self.Report is not None:
            self.Report.export(outfile, level, namespace_, name_='Report', pretty_print=pretty_print)
        if self.Contacts is not None:
            self.Contacts.export(outfile, level, namespace_, name_='Contacts', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sites':
            obj_ = SitesType.factory()
            obj_.build(child_)
            self.Sites = obj_
            obj_.original_tagname_ = 'Sites'
        elif nodeName_ == 'Systems':
            obj_ = SystemsType1.factory()
            obj_.build(child_)
            self.Systems = obj_
            obj_.original_tagname_ = 'Systems'
        elif nodeName_ == 'Schedules':
            obj_ = SchedulesType.factory()
            obj_.build(child_)
            self.Schedules = obj_
            obj_.original_tagname_ = 'Schedules'
        elif nodeName_ == 'Measures':
            obj_ = MeasuresType.factory()
            obj_.build(child_)
            self.Measures = obj_
            obj_.original_tagname_ = 'Measures'
        elif nodeName_ == 'Report':
            obj_ = ReportType.factory()
            obj_.build(child_)
            self.Report = obj_
            obj_.original_tagname_ = 'Report'
        elif nodeName_ == 'Contacts':
            obj_ = ContactsType.factory()
            obj_.build(child_)
            self.Contacts = obj_
            obj_.original_tagname_ = 'Contacts'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class AuditType


class SitesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Site=None):
        self.original_tagname_ = None
        if Site is None:
            self.Site = []
        else:
            self.Site = Site
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SitesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SitesType.subclass:
            return SitesType.subclass(*args_, **kwargs_)
        else:
            return SitesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Site
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SitesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SitesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SitesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SitesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SitesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Site_ in self.Site:
            Site_.export(outfile, level, namespace_, name_='Site', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Site':
            obj_ = SiteType.factory()
            obj_.build(child_)
            self.Site.append(obj_)
            obj_.original_tagname_ = 'Site'
# end class SitesType


class SystemsType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HVACSystems=None, LightingSystems=None, DomesticHotWaterSystems=None, CookingSystems=None, RefrigerationSystems=None, DishwasherSystems=None, LaundrySystems=None, PumpSystems=None, FanSystems=None, MotorSystems=None, HeatRecoverySystems=None, WallSystems=None, RoofCeilingSystems=None, FenestrationSystems=None, FoundationSystems=None, CriticalITSystems=None, PlugLoads=None, ProcessLoads=None, ConveyanceSystems=None, OnSiteStorageTransmissionGenerationSystems=None, Pools=None, WaterUses=None, InfiltrationIntrusion=None):
        self.original_tagname_ = None
        self.HVACSystems = HVACSystems
        self.LightingSystems = LightingSystems
        self.DomesticHotWaterSystems = DomesticHotWaterSystems
        self.CookingSystems = CookingSystems
        self.RefrigerationSystems = RefrigerationSystems
        self.DishwasherSystems = DishwasherSystems
        self.LaundrySystems = LaundrySystems
        self.PumpSystems = PumpSystems
        self.FanSystems = FanSystems
        self.MotorSystems = MotorSystems
        self.HeatRecoverySystems = HeatRecoverySystems
        self.WallSystems = WallSystems
        self.RoofCeilingSystems = RoofCeilingSystems
        self.FenestrationSystems = FenestrationSystems
        self.FoundationSystems = FoundationSystems
        self.CriticalITSystems = CriticalITSystems
        self.PlugLoads = PlugLoads
        self.ProcessLoads = ProcessLoads
        self.ConveyanceSystems = ConveyanceSystems
        self.OnSiteStorageTransmissionGenerationSystems = OnSiteStorageTransmissionGenerationSystems
        self.Pools = Pools
        self.WaterUses = WaterUses
        if InfiltrationIntrusion is None:
            self.InfiltrationIntrusion = []
        else:
            self.InfiltrationIntrusion = InfiltrationIntrusion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SystemsType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SystemsType1.subclass:
            return SystemsType1.subclass(*args_, **kwargs_)
        else:
            return SystemsType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HVACSystems is not None or
            self.LightingSystems is not None or
            self.DomesticHotWaterSystems is not None or
            self.CookingSystems is not None or
            self.RefrigerationSystems is not None or
            self.DishwasherSystems is not None or
            self.LaundrySystems is not None or
            self.PumpSystems is not None or
            self.FanSystems is not None or
            self.MotorSystems is not None or
            self.HeatRecoverySystems is not None or
            self.WallSystems is not None or
            self.RoofCeilingSystems is not None or
            self.FenestrationSystems is not None or
            self.FoundationSystems is not None or
            self.CriticalITSystems is not None or
            self.PlugLoads is not None or
            self.ProcessLoads is not None or
            self.ConveyanceSystems is not None or
            self.OnSiteStorageTransmissionGenerationSystems is not None or
            self.Pools is not None or
            self.WaterUses is not None or
            self.InfiltrationIntrusion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SystemsType1', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SystemsType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SystemsType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SystemsType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SystemsType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HVACSystems is not None:
            self.HVACSystems.export(outfile, level, namespace_, name_='HVACSystems', pretty_print=pretty_print)
        if self.LightingSystems is not None:
            self.LightingSystems.export(outfile, level, namespace_, name_='LightingSystems', pretty_print=pretty_print)
        if self.DomesticHotWaterSystems is not None:
            self.DomesticHotWaterSystems.export(outfile, level, namespace_, name_='DomesticHotWaterSystems', pretty_print=pretty_print)
        if self.CookingSystems is not None:
            self.CookingSystems.export(outfile, level, namespace_, name_='CookingSystems', pretty_print=pretty_print)
        if self.RefrigerationSystems is not None:
            self.RefrigerationSystems.export(outfile, level, namespace_, name_='RefrigerationSystems', pretty_print=pretty_print)
        if self.DishwasherSystems is not None:
            self.DishwasherSystems.export(outfile, level, namespace_, name_='DishwasherSystems', pretty_print=pretty_print)
        if self.LaundrySystems is not None:
            self.LaundrySystems.export(outfile, level, namespace_, name_='LaundrySystems', pretty_print=pretty_print)
        if self.PumpSystems is not None:
            self.PumpSystems.export(outfile, level, namespace_, name_='PumpSystems', pretty_print=pretty_print)
        if self.FanSystems is not None:
            self.FanSystems.export(outfile, level, namespace_, name_='FanSystems', pretty_print=pretty_print)
        if self.MotorSystems is not None:
            self.MotorSystems.export(outfile, level, namespace_, name_='MotorSystems', pretty_print=pretty_print)
        if self.HeatRecoverySystems is not None:
            self.HeatRecoverySystems.export(outfile, level, namespace_, name_='HeatRecoverySystems', pretty_print=pretty_print)
        if self.WallSystems is not None:
            self.WallSystems.export(outfile, level, namespace_, name_='WallSystems', pretty_print=pretty_print)
        if self.RoofCeilingSystems is not None:
            self.RoofCeilingSystems.export(outfile, level, namespace_, name_='RoofCeilingSystems', pretty_print=pretty_print)
        if self.FenestrationSystems is not None:
            self.FenestrationSystems.export(outfile, level, namespace_, name_='FenestrationSystems', pretty_print=pretty_print)
        if self.FoundationSystems is not None:
            self.FoundationSystems.export(outfile, level, namespace_, name_='FoundationSystems', pretty_print=pretty_print)
        if self.CriticalITSystems is not None:
            self.CriticalITSystems.export(outfile, level, namespace_, name_='CriticalITSystems', pretty_print=pretty_print)
        if self.PlugLoads is not None:
            self.PlugLoads.export(outfile, level, namespace_, name_='PlugLoads', pretty_print=pretty_print)
        if self.ProcessLoads is not None:
            self.ProcessLoads.export(outfile, level, namespace_, name_='ProcessLoads', pretty_print=pretty_print)
        if self.ConveyanceSystems is not None:
            self.ConveyanceSystems.export(outfile, level, namespace_, name_='ConveyanceSystems', pretty_print=pretty_print)
        if self.OnSiteStorageTransmissionGenerationSystems is not None:
            self.OnSiteStorageTransmissionGenerationSystems.export(outfile, level, namespace_, name_='OnSiteStorageTransmissionGenerationSystems', pretty_print=pretty_print)
        if self.Pools is not None:
            self.Pools.export(outfile, level, namespace_, name_='Pools', pretty_print=pretty_print)
        if self.WaterUses is not None:
            self.WaterUses.export(outfile, level, namespace_, name_='WaterUses', pretty_print=pretty_print)
        for InfiltrationIntrusion_ in self.InfiltrationIntrusion:
            InfiltrationIntrusion_.export(outfile, level, namespace_, name_='InfiltrationIntrusion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HVACSystems':
            obj_ = HVACSystemsType.factory()
            obj_.build(child_)
            self.HVACSystems = obj_
            obj_.original_tagname_ = 'HVACSystems'
        elif nodeName_ == 'LightingSystems':
            obj_ = LightingSystemsType.factory()
            obj_.build(child_)
            self.LightingSystems = obj_
            obj_.original_tagname_ = 'LightingSystems'
        elif nodeName_ == 'DomesticHotWaterSystems':
            obj_ = DomesticHotWaterSystemsType.factory()
            obj_.build(child_)
            self.DomesticHotWaterSystems = obj_
            obj_.original_tagname_ = 'DomesticHotWaterSystems'
        elif nodeName_ == 'CookingSystems':
            obj_ = CookingSystemsType.factory()
            obj_.build(child_)
            self.CookingSystems = obj_
            obj_.original_tagname_ = 'CookingSystems'
        elif nodeName_ == 'RefrigerationSystems':
            obj_ = RefrigerationSystemsType.factory()
            obj_.build(child_)
            self.RefrigerationSystems = obj_
            obj_.original_tagname_ = 'RefrigerationSystems'
        elif nodeName_ == 'DishwasherSystems':
            obj_ = DishwasherSystemsType.factory()
            obj_.build(child_)
            self.DishwasherSystems = obj_
            obj_.original_tagname_ = 'DishwasherSystems'
        elif nodeName_ == 'LaundrySystems':
            obj_ = LaundrySystemsType.factory()
            obj_.build(child_)
            self.LaundrySystems = obj_
            obj_.original_tagname_ = 'LaundrySystems'
        elif nodeName_ == 'PumpSystems':
            obj_ = PumpSystemsType.factory()
            obj_.build(child_)
            self.PumpSystems = obj_
            obj_.original_tagname_ = 'PumpSystems'
        elif nodeName_ == 'FanSystems':
            obj_ = FanSystemsType.factory()
            obj_.build(child_)
            self.FanSystems = obj_
            obj_.original_tagname_ = 'FanSystems'
        elif nodeName_ == 'MotorSystems':
            obj_ = MotorSystemsType.factory()
            obj_.build(child_)
            self.MotorSystems = obj_
            obj_.original_tagname_ = 'MotorSystems'
        elif nodeName_ == 'HeatRecoverySystems':
            obj_ = HeatRecoverySystemsType.factory()
            obj_.build(child_)
            self.HeatRecoverySystems = obj_
            obj_.original_tagname_ = 'HeatRecoverySystems'
        elif nodeName_ == 'WallSystems':
            obj_ = WallSystemsType.factory()
            obj_.build(child_)
            self.WallSystems = obj_
            obj_.original_tagname_ = 'WallSystems'
        elif nodeName_ == 'RoofCeilingSystems':
            obj_ = RoofCeilingSystemsType.factory()
            obj_.build(child_)
            self.RoofCeilingSystems = obj_
            obj_.original_tagname_ = 'RoofCeilingSystems'
        elif nodeName_ == 'FenestrationSystems':
            obj_ = FenestrationSystemsType.factory()
            obj_.build(child_)
            self.FenestrationSystems = obj_
            obj_.original_tagname_ = 'FenestrationSystems'
        elif nodeName_ == 'FoundationSystems':
            obj_ = FoundationSystemsType.factory()
            obj_.build(child_)
            self.FoundationSystems = obj_
            obj_.original_tagname_ = 'FoundationSystems'
        elif nodeName_ == 'CriticalITSystems':
            obj_ = CriticalITSystemsType.factory()
            obj_.build(child_)
            self.CriticalITSystems = obj_
            obj_.original_tagname_ = 'CriticalITSystems'
        elif nodeName_ == 'PlugLoads':
            obj_ = PlugLoadsType.factory()
            obj_.build(child_)
            self.PlugLoads = obj_
            obj_.original_tagname_ = 'PlugLoads'
        elif nodeName_ == 'ProcessLoads':
            obj_ = ProcessLoadsType.factory()
            obj_.build(child_)
            self.ProcessLoads = obj_
            obj_.original_tagname_ = 'ProcessLoads'
        elif nodeName_ == 'ConveyanceSystems':
            obj_ = ConveyanceSystemsType.factory()
            obj_.build(child_)
            self.ConveyanceSystems = obj_
            obj_.original_tagname_ = 'ConveyanceSystems'
        elif nodeName_ == 'OnSiteStorageTransmissionGenerationSystems':
            obj_ = OnSiteStorageTransmissionGenerationSystemsType.factory()
            obj_.build(child_)
            self.OnSiteStorageTransmissionGenerationSystems = obj_
            obj_.original_tagname_ = 'OnSiteStorageTransmissionGenerationSystems'
        elif nodeName_ == 'Pools':
            obj_ = PoolsType.factory()
            obj_.build(child_)
            self.Pools = obj_
            obj_.original_tagname_ = 'Pools'
        elif nodeName_ == 'WaterUses':
            obj_ = WaterUsesType.factory()
            obj_.build(child_)
            self.WaterUses = obj_
            obj_.original_tagname_ = 'WaterUses'
        elif nodeName_ == 'InfiltrationIntrusion':
            obj_ = InfiltrationIntrusionType.factory()
            obj_.build(child_)
            self.InfiltrationIntrusion.append(obj_)
            obj_.original_tagname_ = 'InfiltrationIntrusion'
# end class SystemsType1


class HVACSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HVACSystem=None):
        self.original_tagname_ = None
        if HVACSystem is None:
            self.HVACSystem = []
        else:
            self.HVACSystem = HVACSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HVACSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HVACSystemsType.subclass:
            return HVACSystemsType.subclass(*args_, **kwargs_)
        else:
            return HVACSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HVACSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HVACSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HVACSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HVACSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HVACSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HVACSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HVACSystem_ in self.HVACSystem:
            HVACSystem_.export(outfile, level, namespace_, name_='HVACSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HVACSystem':
            obj_ = HVACSystemType.factory()
            obj_.build(child_)
            self.HVACSystem.append(obj_)
            obj_.original_tagname_ = 'HVACSystem'
# end class HVACSystemsType


class LightingSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LightingSystem=None):
        self.original_tagname_ = None
        if LightingSystem is None:
            self.LightingSystem = []
        else:
            self.LightingSystem = LightingSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightingSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightingSystemsType.subclass:
            return LightingSystemsType.subclass(*args_, **kwargs_)
        else:
            return LightingSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LightingSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightingSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightingSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightingSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightingSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightingSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LightingSystem_ in self.LightingSystem:
            LightingSystem_.export(outfile, level, namespace_, name_='LightingSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LightingSystem':
            obj_ = LightingSystemType.factory()
            obj_.build(child_)
            self.LightingSystem.append(obj_)
            obj_.original_tagname_ = 'LightingSystem'
# end class LightingSystemsType


class DomesticHotWaterSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DomesticHotWaterSystem=None):
        self.original_tagname_ = None
        if DomesticHotWaterSystem is None:
            self.DomesticHotWaterSystem = []
        else:
            self.DomesticHotWaterSystem = DomesticHotWaterSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomesticHotWaterSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomesticHotWaterSystemsType.subclass:
            return DomesticHotWaterSystemsType.subclass(*args_, **kwargs_)
        else:
            return DomesticHotWaterSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.DomesticHotWaterSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomesticHotWaterSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DomesticHotWaterSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DomesticHotWaterSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DomesticHotWaterSystem_ in self.DomesticHotWaterSystem:
            DomesticHotWaterSystem_.export(outfile, level, namespace_, name_='DomesticHotWaterSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DomesticHotWaterSystem':
            obj_ = DomesticHotWaterSystemType.factory()
            obj_.build(child_)
            self.DomesticHotWaterSystem.append(obj_)
            obj_.original_tagname_ = 'DomesticHotWaterSystem'
# end class DomesticHotWaterSystemsType


class CookingSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CookingSystem=None):
        self.original_tagname_ = None
        if CookingSystem is None:
            self.CookingSystem = []
        else:
            self.CookingSystem = CookingSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CookingSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CookingSystemsType.subclass:
            return CookingSystemsType.subclass(*args_, **kwargs_)
        else:
            return CookingSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CookingSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CookingSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CookingSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CookingSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CookingSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CookingSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CookingSystem_ in self.CookingSystem:
            CookingSystem_.export(outfile, level, namespace_, name_='CookingSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CookingSystem':
            obj_ = CookingSystemType.factory()
            obj_.build(child_)
            self.CookingSystem.append(obj_)
            obj_.original_tagname_ = 'CookingSystem'
# end class CookingSystemsType


class RefrigerationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RefrigerationSystem=None):
        self.original_tagname_ = None
        if RefrigerationSystem is None:
            self.RefrigerationSystem = []
        else:
            self.RefrigerationSystem = RefrigerationSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationSystemsType.subclass:
            return RefrigerationSystemsType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RefrigerationSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RefrigerationSystem_ in self.RefrigerationSystem:
            RefrigerationSystem_.export(outfile, level, namespace_, name_='RefrigerationSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RefrigerationSystem':
            obj_ = RefrigerationSystemType.factory()
            obj_.build(child_)
            self.RefrigerationSystem.append(obj_)
            obj_.original_tagname_ = 'RefrigerationSystem'
# end class RefrigerationSystemsType


class DishwasherSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DishwasherSystem=None):
        self.original_tagname_ = None
        if DishwasherSystem is None:
            self.DishwasherSystem = []
        else:
            self.DishwasherSystem = DishwasherSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DishwasherSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DishwasherSystemsType.subclass:
            return DishwasherSystemsType.subclass(*args_, **kwargs_)
        else:
            return DishwasherSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.DishwasherSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DishwasherSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DishwasherSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DishwasherSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DishwasherSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DishwasherSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DishwasherSystem_ in self.DishwasherSystem:
            DishwasherSystem_.export(outfile, level, namespace_, name_='DishwasherSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DishwasherSystem':
            obj_ = DishwasherSystemType.factory()
            obj_.build(child_)
            self.DishwasherSystem.append(obj_)
            obj_.original_tagname_ = 'DishwasherSystem'
# end class DishwasherSystemsType


class LaundrySystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LaundrySystem=None):
        self.original_tagname_ = None
        if LaundrySystem is None:
            self.LaundrySystem = []
        else:
            self.LaundrySystem = LaundrySystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LaundrySystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LaundrySystemsType.subclass:
            return LaundrySystemsType.subclass(*args_, **kwargs_)
        else:
            return LaundrySystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LaundrySystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LaundrySystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LaundrySystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LaundrySystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LaundrySystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LaundrySystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LaundrySystem_ in self.LaundrySystem:
            LaundrySystem_.export(outfile, level, namespace_, name_='LaundrySystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LaundrySystem':
            obj_ = LaundrySystemType.factory()
            obj_.build(child_)
            self.LaundrySystem.append(obj_)
            obj_.original_tagname_ = 'LaundrySystem'
# end class LaundrySystemsType


class PumpSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PumpSystem=None):
        self.original_tagname_ = None
        if PumpSystem is None:
            self.PumpSystem = []
        else:
            self.PumpSystem = PumpSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpSystemsType.subclass:
            return PumpSystemsType.subclass(*args_, **kwargs_)
        else:
            return PumpSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PumpSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PumpSystem_ in self.PumpSystem:
            PumpSystem_.export(outfile, level, namespace_, name_='PumpSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PumpSystem':
            obj_ = PumpSystemType.factory()
            obj_.build(child_)
            self.PumpSystem.append(obj_)
            obj_.original_tagname_ = 'PumpSystem'
# end class PumpSystemsType


class FanSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FanSystem=None):
        self.original_tagname_ = None
        if FanSystem is None:
            self.FanSystem = []
        else:
            self.FanSystem = FanSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanSystemsType.subclass:
            return FanSystemsType.subclass(*args_, **kwargs_)
        else:
            return FanSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FanSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FanSystem_ in self.FanSystem:
            FanSystem_.export(outfile, level, namespace_, name_='FanSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FanSystem':
            obj_ = FanSystemType.factory()
            obj_.build(child_)
            self.FanSystem.append(obj_)
            obj_.original_tagname_ = 'FanSystem'
# end class FanSystemsType


class MotorSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MotorSystem=None):
        self.original_tagname_ = None
        if MotorSystem is None:
            self.MotorSystem = []
        else:
            self.MotorSystem = MotorSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorSystemsType.subclass:
            return MotorSystemsType.subclass(*args_, **kwargs_)
        else:
            return MotorSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MotorSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MotorSystem_ in self.MotorSystem:
            MotorSystem_.export(outfile, level, namespace_, name_='MotorSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MotorSystem':
            obj_ = MotorSystemType.factory()
            obj_.build(child_)
            self.MotorSystem.append(obj_)
            obj_.original_tagname_ = 'MotorSystem'
# end class MotorSystemsType


class HeatRecoverySystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HeatRecoverySystem=None):
        self.original_tagname_ = None
        if HeatRecoverySystem is None:
            self.HeatRecoverySystem = []
        else:
            self.HeatRecoverySystem = HeatRecoverySystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatRecoverySystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatRecoverySystemsType.subclass:
            return HeatRecoverySystemsType.subclass(*args_, **kwargs_)
        else:
            return HeatRecoverySystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HeatRecoverySystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatRecoverySystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatRecoverySystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatRecoverySystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatRecoverySystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatRecoverySystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HeatRecoverySystem_ in self.HeatRecoverySystem:
            HeatRecoverySystem_.export(outfile, level, namespace_, name_='HeatRecoverySystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatRecoverySystem':
            obj_ = HeatRecoverySystemType.factory()
            obj_.build(child_)
            self.HeatRecoverySystem.append(obj_)
            obj_.original_tagname_ = 'HeatRecoverySystem'
# end class HeatRecoverySystemsType


class WallSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WallSystem=None):
        self.original_tagname_ = None
        if WallSystem is None:
            self.WallSystem = []
        else:
            self.WallSystem = WallSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallSystemsType.subclass:
            return WallSystemsType.subclass(*args_, **kwargs_)
        else:
            return WallSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.WallSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WallSystem_ in self.WallSystem:
            WallSystem_.export(outfile, level, namespace_, name_='WallSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WallSystem':
            obj_ = WallSystemType.factory()
            obj_.build(child_)
            self.WallSystem.append(obj_)
            obj_.original_tagname_ = 'WallSystem'
# end class WallSystemsType


class RoofCeilingSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RoofCeilingSystem=None):
        self.original_tagname_ = None
        if RoofCeilingSystem is None:
            self.RoofCeilingSystem = []
        else:
            self.RoofCeilingSystem = RoofCeilingSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofCeilingSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofCeilingSystemsType.subclass:
            return RoofCeilingSystemsType.subclass(*args_, **kwargs_)
        else:
            return RoofCeilingSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RoofCeilingSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofCeilingSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofCeilingSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofCeilingSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofCeilingSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofCeilingSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RoofCeilingSystem_ in self.RoofCeilingSystem:
            RoofCeilingSystem_.export(outfile, level, namespace_, name_='RoofCeilingSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RoofCeilingSystem':
            obj_ = RoofCeilingSystemType.factory()
            obj_.build(child_)
            self.RoofCeilingSystem.append(obj_)
            obj_.original_tagname_ = 'RoofCeilingSystem'
# end class RoofCeilingSystemsType


class FenestrationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FenestrationSystem=None):
        self.original_tagname_ = None
        if FenestrationSystem is None:
            self.FenestrationSystem = []
        else:
            self.FenestrationSystem = FenestrationSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationSystemsType.subclass:
            return FenestrationSystemsType.subclass(*args_, **kwargs_)
        else:
            return FenestrationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FenestrationSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FenestrationSystem_ in self.FenestrationSystem:
            FenestrationSystem_.export(outfile, level, namespace_, name_='FenestrationSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FenestrationSystem':
            obj_ = FenestrationSystemType.factory()
            obj_.build(child_)
            self.FenestrationSystem.append(obj_)
            obj_.original_tagname_ = 'FenestrationSystem'
# end class FenestrationSystemsType


class FoundationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FoundationSystem=None):
        self.original_tagname_ = None
        if FoundationSystem is None:
            self.FoundationSystem = []
        else:
            self.FoundationSystem = FoundationSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationSystemsType.subclass:
            return FoundationSystemsType.subclass(*args_, **kwargs_)
        else:
            return FoundationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FoundationSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FoundationSystem_ in self.FoundationSystem:
            FoundationSystem_.export(outfile, level, namespace_, name_='FoundationSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FoundationSystem':
            obj_ = FoundationSystemType.factory()
            obj_.build(child_)
            self.FoundationSystem.append(obj_)
            obj_.original_tagname_ = 'FoundationSystem'
# end class FoundationSystemsType


class CriticalITSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CriticalITSystem=None):
        self.original_tagname_ = None
        if CriticalITSystem is None:
            self.CriticalITSystem = []
        else:
            self.CriticalITSystem = CriticalITSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CriticalITSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CriticalITSystemsType.subclass:
            return CriticalITSystemsType.subclass(*args_, **kwargs_)
        else:
            return CriticalITSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CriticalITSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CriticalITSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CriticalITSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CriticalITSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CriticalITSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CriticalITSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CriticalITSystem_ in self.CriticalITSystem:
            CriticalITSystem_.export(outfile, level, namespace_, name_='CriticalITSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CriticalITSystem':
            obj_ = CriticalITSystemType.factory()
            obj_.build(child_)
            self.CriticalITSystem.append(obj_)
            obj_.original_tagname_ = 'CriticalITSystem'
# end class CriticalITSystemsType


class PlugLoadsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PlugLoad=None, MiscellaneousElectricLoad=None):
        self.original_tagname_ = None
        if PlugLoad is None:
            self.PlugLoad = []
        else:
            self.PlugLoad = PlugLoad
        self.MiscellaneousElectricLoad = MiscellaneousElectricLoad
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadsType.subclass:
            return PlugLoadsType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PlugLoad or
            self.MiscellaneousElectricLoad is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PlugLoad_ in self.PlugLoad:
            PlugLoad_.export(outfile, level, namespace_, name_='PlugLoad', pretty_print=pretty_print)
        if self.MiscellaneousElectricLoad is not None:
            self.MiscellaneousElectricLoad.export(outfile, level, namespace_, name_='MiscellaneousElectricLoad', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PlugLoad':
            obj_ = PlugLoadType.factory()
            obj_.build(child_)
            self.PlugLoad.append(obj_)
            obj_.original_tagname_ = 'PlugLoad'
        elif nodeName_ == 'MiscellaneousElectricLoad':
            obj_ = MiscellaneousElectricLoadType.factory()
            obj_.build(child_)
            self.MiscellaneousElectricLoad = obj_
            obj_.original_tagname_ = 'MiscellaneousElectricLoad'
# end class PlugLoadsType


class MiscellaneousElectricLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiscellaneousElectricLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiscellaneousElectricLoadType.subclass:
            return MiscellaneousElectricLoadType.subclass(*args_, **kwargs_)
        else:
            return MiscellaneousElectricLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MiscellaneousElectricLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiscellaneousElectricLoadType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MiscellaneousElectricLoadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MiscellaneousElectricLoadType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MiscellaneousElectricLoadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MiscellaneousElectricLoadType


class ProcessLoadsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ProcessLoad=None, MiscellaneousGasLoad=None):
        self.original_tagname_ = None
        if ProcessLoad is None:
            self.ProcessLoad = []
        else:
            self.ProcessLoad = ProcessLoad
        self.MiscellaneousGasLoad = MiscellaneousGasLoad
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessLoadsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessLoadsType.subclass:
            return ProcessLoadsType.subclass(*args_, **kwargs_)
        else:
            return ProcessLoadsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ProcessLoad or
            self.MiscellaneousGasLoad is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ProcessLoadsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessLoadsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ProcessLoadsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ProcessLoadsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ProcessLoadsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProcessLoad_ in self.ProcessLoad:
            ProcessLoad_.export(outfile, level, namespace_, name_='ProcessLoad', pretty_print=pretty_print)
        if self.MiscellaneousGasLoad is not None:
            self.MiscellaneousGasLoad.export(outfile, level, namespace_, name_='MiscellaneousGasLoad', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProcessLoad':
            obj_ = ProcessLoadType.factory()
            obj_.build(child_)
            self.ProcessLoad.append(obj_)
            obj_.original_tagname_ = 'ProcessLoad'
        elif nodeName_ == 'MiscellaneousGasLoad':
            obj_ = MiscellaneousGasLoadType.factory()
            obj_.build(child_)
            self.MiscellaneousGasLoad = obj_
            obj_.original_tagname_ = 'MiscellaneousGasLoad'
# end class ProcessLoadsType


class MiscellaneousGasLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiscellaneousGasLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiscellaneousGasLoadType.subclass:
            return MiscellaneousGasLoadType.subclass(*args_, **kwargs_)
        else:
            return MiscellaneousGasLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MiscellaneousGasLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiscellaneousGasLoadType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MiscellaneousGasLoadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MiscellaneousGasLoadType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MiscellaneousGasLoadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MiscellaneousGasLoadType


class ConveyanceSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConveyanceSystem=None):
        self.original_tagname_ = None
        if ConveyanceSystem is None:
            self.ConveyanceSystem = []
        else:
            self.ConveyanceSystem = ConveyanceSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConveyanceSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConveyanceSystemsType.subclass:
            return ConveyanceSystemsType.subclass(*args_, **kwargs_)
        else:
            return ConveyanceSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ConveyanceSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConveyanceSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConveyanceSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConveyanceSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConveyanceSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConveyanceSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConveyanceSystem_ in self.ConveyanceSystem:
            ConveyanceSystem_.export(outfile, level, namespace_, name_='ConveyanceSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConveyanceSystem':
            obj_ = ConveyanceSystemType.factory()
            obj_.build(child_)
            self.ConveyanceSystem.append(obj_)
            obj_.original_tagname_ = 'ConveyanceSystem'
# end class ConveyanceSystemsType


class OnSiteStorageTransmissionGenerationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OnSiteStorageTransmissionGenerationSystem=None):
        self.original_tagname_ = None
        if OnSiteStorageTransmissionGenerationSystem is None:
            self.OnSiteStorageTransmissionGenerationSystem = []
        else:
            self.OnSiteStorageTransmissionGenerationSystem = OnSiteStorageTransmissionGenerationSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnSiteStorageTransmissionGenerationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnSiteStorageTransmissionGenerationSystemsType.subclass:
            return OnSiteStorageTransmissionGenerationSystemsType.subclass(*args_, **kwargs_)
        else:
            return OnSiteStorageTransmissionGenerationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.OnSiteStorageTransmissionGenerationSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnSiteStorageTransmissionGenerationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OnSiteStorageTransmissionGenerationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OnSiteStorageTransmissionGenerationSystem_ in self.OnSiteStorageTransmissionGenerationSystem:
            OnSiteStorageTransmissionGenerationSystem_.export(outfile, level, namespace_, name_='OnSiteStorageTransmissionGenerationSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OnSiteStorageTransmissionGenerationSystem':
            obj_ = OnSiteStorageTransmissionGenerationSystemType.factory()
            obj_.build(child_)
            self.OnSiteStorageTransmissionGenerationSystem.append(obj_)
            obj_.original_tagname_ = 'OnSiteStorageTransmissionGenerationSystem'
# end class OnSiteStorageTransmissionGenerationSystemsType


class PoolsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Pool=None):
        self.original_tagname_ = None
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoolsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoolsType.subclass:
            return PoolsType.subclass(*args_, **kwargs_)
        else:
            return PoolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Pool
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PoolsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PoolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PoolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PoolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = PoolType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
# end class PoolsType


class WaterUsesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WaterUse=None):
        self.original_tagname_ = None
        if WaterUse is None:
            self.WaterUse = []
        else:
            self.WaterUse = WaterUse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterUsesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterUsesType.subclass:
            return WaterUsesType.subclass(*args_, **kwargs_)
        else:
            return WaterUsesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.WaterUse
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterUsesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterUsesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterUsesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterUsesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterUsesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WaterUse_ in self.WaterUse:
            WaterUse_.export(outfile, level, namespace_, name_='WaterUse', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterUse':
            obj_ = WaterUseType.factory()
            obj_.build(child_)
            self.WaterUse.append(obj_)
            obj_.original_tagname_ = 'WaterUse'
# end class WaterUsesType


class InfiltrationIntrusionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tightness=None, AirInfiltrationValue=None, AirInfiltrationValueUnits=None, AirInfiltrationTest=None, LocationsOfExteriorWaterIntrusionDamage=None, LocationsOfInteriorWaterIntrusionDamage=None, LinkedPremises=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.Tightness = Tightness
        self.validate_TightnessType(self.Tightness)
        self.AirInfiltrationValue = AirInfiltrationValue
        self.AirInfiltrationValueUnits = AirInfiltrationValueUnits
        self.validate_AirInfiltrationValueUnitsType(self.AirInfiltrationValueUnits)
        self.AirInfiltrationTest = AirInfiltrationTest
        self.validate_AirInfiltrationTestType(self.AirInfiltrationTest)
        if LocationsOfExteriorWaterIntrusionDamage is None:
            self.LocationsOfExteriorWaterIntrusionDamage = []
        else:
            self.LocationsOfExteriorWaterIntrusionDamage = LocationsOfExteriorWaterIntrusionDamage
        if LocationsOfInteriorWaterIntrusionDamage is None:
            self.LocationsOfInteriorWaterIntrusionDamage = []
        else:
            self.LocationsOfInteriorWaterIntrusionDamage = LocationsOfInteriorWaterIntrusionDamage
        self.LinkedPremises = LinkedPremises
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InfiltrationIntrusionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InfiltrationIntrusionType.subclass:
            return InfiltrationIntrusionType.subclass(*args_, **kwargs_)
        else:
            return InfiltrationIntrusionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TightnessType(self, value):
        # Validate type TightnessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Very Tight', 'Tight', 'Average', 'Leaky', 'Very Leaky', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TightnessType' % {"value" : value.encode("utf-8")} )
    def validate_AirInfiltrationValueUnitsType(self, value):
        # Validate type AirInfiltrationValueUnitsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CFM25', 'CFM50', 'CFM75', 'CFMnatural', 'ACH50', 'ACHnatural', 'Effective Leakage Area (in2)', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AirInfiltrationValueUnitsType' % {"value" : value.encode("utf-8")} )
    def validate_AirInfiltrationTestType(self, value):
        # Validate type AirInfiltrationTestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Blower door', 'Tracer gas', 'Checklist', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AirInfiltrationTestType' % {"value" : value.encode("utf-8")} )
    def validate_LocationsOfExteriorWaterIntrusionDamageType(self, value):
        # Validate type LocationsOfExteriorWaterIntrusionDamageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Roof', 'Interior ceiling', 'Foundation', 'Basement', 'Crawlspace', 'Walls', 'Around windows', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LocationsOfExteriorWaterIntrusionDamageType' % {"value" : value.encode("utf-8")} )
    def validate_LocationsOfInteriorWaterIntrusionDamageType(self, value):
        # Validate type LocationsOfInteriorWaterIntrusionDamageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Kitchen', 'Bathroom', 'Basement', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LocationsOfInteriorWaterIntrusionDamageType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Tightness is not None or
            self.AirInfiltrationValue is not None or
            self.AirInfiltrationValueUnits is not None or
            self.AirInfiltrationTest is not None or
            self.LocationsOfExteriorWaterIntrusionDamage or
            self.LocationsOfInteriorWaterIntrusionDamage or
            self.LinkedPremises is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InfiltrationIntrusionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InfiltrationIntrusionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InfiltrationIntrusionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InfiltrationIntrusionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InfiltrationIntrusionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tightness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTightness>%s</%sTightness>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Tightness), input_name='Tightness')), namespace_, eol_))
        if self.AirInfiltrationValue is not None:
            self.AirInfiltrationValue.export(outfile, level, namespace_, name_='AirInfiltrationValue', pretty_print=pretty_print)
        if self.AirInfiltrationValueUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAirInfiltrationValueUnits>%s</%sAirInfiltrationValueUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AirInfiltrationValueUnits), input_name='AirInfiltrationValueUnits')), namespace_, eol_))
        if self.AirInfiltrationTest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAirInfiltrationTest>%s</%sAirInfiltrationTest>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AirInfiltrationTest), input_name='AirInfiltrationTest')), namespace_, eol_))
        for LocationsOfExteriorWaterIntrusionDamage_ in self.LocationsOfExteriorWaterIntrusionDamage:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationsOfExteriorWaterIntrusionDamage>%s</%sLocationsOfExteriorWaterIntrusionDamage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(LocationsOfExteriorWaterIntrusionDamage_), input_name='LocationsOfExteriorWaterIntrusionDamage')), namespace_, eol_))
        for LocationsOfInteriorWaterIntrusionDamage_ in self.LocationsOfInteriorWaterIntrusionDamage:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationsOfInteriorWaterIntrusionDamage>%s</%sLocationsOfInteriorWaterIntrusionDamage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(LocationsOfInteriorWaterIntrusionDamage_), input_name='LocationsOfInteriorWaterIntrusionDamage')), namespace_, eol_))
        if self.LinkedPremises is not None:
            self.LinkedPremises.export(outfile, level, namespace_='auc:', name_='LinkedPremises', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tightness':
            Tightness_ = child_.text
            Tightness_ = self.gds_validate_string(Tightness_, node, 'Tightness')
            self.Tightness = Tightness_
            # validate type TightnessType
            self.validate_TightnessType(self.Tightness)
        elif nodeName_ == 'AirInfiltrationValue':
            obj_ = AirInfiltrationValueType.factory()
            obj_.build(child_)
            self.AirInfiltrationValue = obj_
            obj_.original_tagname_ = 'AirInfiltrationValue'
        elif nodeName_ == 'AirInfiltrationValueUnits':
            AirInfiltrationValueUnits_ = child_.text
            AirInfiltrationValueUnits_ = self.gds_validate_string(AirInfiltrationValueUnits_, node, 'AirInfiltrationValueUnits')
            self.AirInfiltrationValueUnits = AirInfiltrationValueUnits_
            # validate type AirInfiltrationValueUnitsType
            self.validate_AirInfiltrationValueUnitsType(self.AirInfiltrationValueUnits)
        elif nodeName_ == 'AirInfiltrationTest':
            AirInfiltrationTest_ = child_.text
            AirInfiltrationTest_ = self.gds_validate_string(AirInfiltrationTest_, node, 'AirInfiltrationTest')
            self.AirInfiltrationTest = AirInfiltrationTest_
            # validate type AirInfiltrationTestType
            self.validate_AirInfiltrationTestType(self.AirInfiltrationTest)
        elif nodeName_ == 'LocationsOfExteriorWaterIntrusionDamage':
            LocationsOfExteriorWaterIntrusionDamage_ = child_.text
            LocationsOfExteriorWaterIntrusionDamage_ = self.gds_validate_string(LocationsOfExteriorWaterIntrusionDamage_, node, 'LocationsOfExteriorWaterIntrusionDamage')
            self.LocationsOfExteriorWaterIntrusionDamage.append(LocationsOfExteriorWaterIntrusionDamage_)
            # validate type LocationsOfExteriorWaterIntrusionDamageType
            self.validate_LocationsOfExteriorWaterIntrusionDamageType(self.LocationsOfExteriorWaterIntrusionDamage[-1])
        elif nodeName_ == 'LocationsOfInteriorWaterIntrusionDamage':
            LocationsOfInteriorWaterIntrusionDamage_ = child_.text
            LocationsOfInteriorWaterIntrusionDamage_ = self.gds_validate_string(LocationsOfInteriorWaterIntrusionDamage_, node, 'LocationsOfInteriorWaterIntrusionDamage')
            self.LocationsOfInteriorWaterIntrusionDamage.append(LocationsOfInteriorWaterIntrusionDamage_)
            # validate type LocationsOfInteriorWaterIntrusionDamageType
            self.validate_LocationsOfInteriorWaterIntrusionDamageType(self.LocationsOfInteriorWaterIntrusionDamage[-1])
        elif nodeName_ == 'LinkedPremises':
            obj_ = LinkedPremises.factory()
            obj_.build(child_)
            self.LinkedPremises = obj_
            obj_.original_tagname_ = 'LinkedPremises'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class InfiltrationIntrusionType


class AirInfiltrationValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirInfiltrationValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirInfiltrationValueType.subclass:
            return AirInfiltrationValueType.subclass(*args_, **kwargs_)
        else:
            return AirInfiltrationValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AirInfiltrationValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AirInfiltrationValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AirInfiltrationValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AirInfiltrationValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AirInfiltrationValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AirInfiltrationValueType


class SchedulesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Schedule=None):
        self.original_tagname_ = None
        if Schedule is None:
            self.Schedule = []
        else:
            self.Schedule = Schedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulesType.subclass:
            return SchedulesType.subclass(*args_, **kwargs_)
        else:
            return SchedulesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Schedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SchedulesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SchedulesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SchedulesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SchedulesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SchedulesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Schedule_ in self.Schedule:
            Schedule_.export(outfile, level, namespace_, name_='Schedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Schedule':
            obj_ = ScheduleType.factory()
            obj_.build(child_)
            self.Schedule.append(obj_)
            obj_.original_tagname_ = 'Schedule'
# end class SchedulesType


class MeasuresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Measure=None):
        self.original_tagname_ = None
        if Measure is None:
            self.Measure = []
        else:
            self.Measure = Measure
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuresType.subclass:
            return MeasuresType.subclass(*args_, **kwargs_)
        else:
            return MeasuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Measure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasuresType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasuresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasuresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasuresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Measure_ in self.Measure:
            Measure_.export(outfile, level, namespace_, name_='Measure', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measure':
            obj_ = MeasureType.factory()
            obj_.build(child_)
            self.Measure.append(obj_)
            obj_.original_tagname_ = 'Measure'
# end class MeasuresType


class ReportType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Scenarios=None, AuditDate=None, ASHRAEAuditLevel=None, RetrocommissioningAudit=None, AuditCost=None, DiscountFactor=None, AnalysisPeriod=None, GasPriceEscalationRate=None, ElectricityPriceEscalationRate=None, WaterPriceEscalationRate=None, OtherEscalationRates=None, InflationRate=None, Qualifications=None, AuditExemption=None, AuditorContactID=None, UserDefinedFields=None):
        self.original_tagname_ = None
        self.Scenarios = Scenarios
        if isinstance(AuditDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AuditDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AuditDate
        self.AuditDate = initvalue_
        self.ASHRAEAuditLevel = ASHRAEAuditLevel
        self.validate_ASHRAEAuditLevelType(self.ASHRAEAuditLevel)
        self.RetrocommissioningAudit = RetrocommissioningAudit
        self.AuditCost = AuditCost
        self.DiscountFactor = DiscountFactor
        self.AnalysisPeriod = AnalysisPeriod
        self.GasPriceEscalationRate = GasPriceEscalationRate
        self.ElectricityPriceEscalationRate = ElectricityPriceEscalationRate
        self.WaterPriceEscalationRate = WaterPriceEscalationRate
        if OtherEscalationRates is None:
            self.OtherEscalationRates = []
        else:
            self.OtherEscalationRates = OtherEscalationRates
        self.InflationRate = InflationRate
        if Qualifications is None:
            self.Qualifications = []
        else:
            self.Qualifications = Qualifications
        self.AuditExemption = AuditExemption
        self.validate_AuditExemptionType(self.AuditExemption)
        self.AuditorContactID = AuditorContactID
        self.UserDefinedFields = UserDefinedFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportType.subclass:
            return ReportType.subclass(*args_, **kwargs_)
        else:
            return ReportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ASHRAEAuditLevelType(self, value):
        # Validate type ASHRAEAuditLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Preliminary Energy-Use Analysis', 'Level 1: Walk-through', 'Level 2: Energy Survey and Analysis', 'Level 3: Detailed Survey and Analysis']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ASHRAEAuditLevelType' % {"value" : value.encode("utf-8")} )
    def validate_AuditExemptionType(self, value):
        # Validate type AuditExemptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EPA ENERGY STAR certified', 'LEED certified', 'Simple building', 'Class 1 building', 'Other', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AuditExemptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Scenarios is not None or
            self.AuditDate is not None or
            self.ASHRAEAuditLevel is not None or
            self.RetrocommissioningAudit is not None or
            self.AuditCost is not None or
            self.DiscountFactor is not None or
            self.AnalysisPeriod is not None or
            self.GasPriceEscalationRate is not None or
            self.ElectricityPriceEscalationRate is not None or
            self.WaterPriceEscalationRate is not None or
            self.OtherEscalationRates or
            self.InflationRate is not None or
            self.Qualifications or
            self.AuditExemption is not None or
            self.AuditorContactID is not None or
            self.UserDefinedFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ReportType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ReportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ReportType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ReportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Scenarios is not None:
            self.Scenarios.export(outfile, level, namespace_, name_='Scenarios', pretty_print=pretty_print)
        if self.AuditDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditDate>%s</%sAuditDate>%s' % (namespace_, self.gds_format_date(self.AuditDate, input_name='AuditDate'), namespace_, eol_))
        if self.ASHRAEAuditLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sASHRAEAuditLevel>%s</%sASHRAEAuditLevel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ASHRAEAuditLevel), input_name='ASHRAEAuditLevel')), namespace_, eol_))
        if self.RetrocommissioningAudit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRetrocommissioningAudit>%s</%sRetrocommissioningAudit>%s' % (namespace_, self.gds_format_boolean(self.RetrocommissioningAudit, input_name='RetrocommissioningAudit'), namespace_, eol_))
        if self.AuditCost is not None:
            self.AuditCost.export(outfile, level, namespace_, name_='AuditCost', pretty_print=pretty_print)
        if self.DiscountFactor is not None:
            self.DiscountFactor.export(outfile, level, namespace_, name_='DiscountFactor', pretty_print=pretty_print)
        if self.AnalysisPeriod is not None:
            self.AnalysisPeriod.export(outfile, level, namespace_, name_='AnalysisPeriod', pretty_print=pretty_print)
        if self.GasPriceEscalationRate is not None:
            self.GasPriceEscalationRate.export(outfile, level, namespace_, name_='GasPriceEscalationRate', pretty_print=pretty_print)
        if self.ElectricityPriceEscalationRate is not None:
            self.ElectricityPriceEscalationRate.export(outfile, level, namespace_, name_='ElectricityPriceEscalationRate', pretty_print=pretty_print)
        if self.WaterPriceEscalationRate is not None:
            self.WaterPriceEscalationRate.export(outfile, level, namespace_, name_='WaterPriceEscalationRate', pretty_print=pretty_print)
        for OtherEscalationRates_ in self.OtherEscalationRates:
            OtherEscalationRates_.export(outfile, level, namespace_, name_='OtherEscalationRates', pretty_print=pretty_print)
        if self.InflationRate is not None:
            self.InflationRate.export(outfile, level, namespace_, name_='InflationRate', pretty_print=pretty_print)
        for Qualifications_ in self.Qualifications:
            Qualifications_.export(outfile, level, namespace_, name_='Qualifications', pretty_print=pretty_print)
        if self.AuditExemption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditExemption>%s</%sAuditExemption>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AuditExemption), input_name='AuditExemption')), namespace_, eol_))
        if self.AuditorContactID is not None:
            self.AuditorContactID.export(outfile, level, namespace_, name_='AuditorContactID', pretty_print=pretty_print)
        if self.UserDefinedFields is not None:
            self.UserDefinedFields.export(outfile, level, namespace_='auc:', name_='UserDefinedFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scenarios':
            obj_ = ScenariosType.factory()
            obj_.build(child_)
            self.Scenarios = obj_
            obj_.original_tagname_ = 'Scenarios'
        elif nodeName_ == 'AuditDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AuditDate = dval_
        elif nodeName_ == 'ASHRAEAuditLevel':
            ASHRAEAuditLevel_ = child_.text
            ASHRAEAuditLevel_ = self.gds_validate_string(ASHRAEAuditLevel_, node, 'ASHRAEAuditLevel')
            self.ASHRAEAuditLevel = ASHRAEAuditLevel_
            # validate type ASHRAEAuditLevelType
            self.validate_ASHRAEAuditLevelType(self.ASHRAEAuditLevel)
        elif nodeName_ == 'RetrocommissioningAudit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RetrocommissioningAudit')
            self.RetrocommissioningAudit = ival_
        elif nodeName_ == 'AuditCost':
            obj_ = AuditCostType.factory()
            obj_.build(child_)
            self.AuditCost = obj_
            obj_.original_tagname_ = 'AuditCost'
        elif nodeName_ == 'DiscountFactor':
            obj_ = DiscountFactorType.factory()
            obj_.build(child_)
            self.DiscountFactor = obj_
            obj_.original_tagname_ = 'DiscountFactor'
        elif nodeName_ == 'AnalysisPeriod':
            obj_ = AnalysisPeriodType.factory()
            obj_.build(child_)
            self.AnalysisPeriod = obj_
            obj_.original_tagname_ = 'AnalysisPeriod'
        elif nodeName_ == 'GasPriceEscalationRate':
            obj_ = GasPriceEscalationRateType.factory()
            obj_.build(child_)
            self.GasPriceEscalationRate = obj_
            obj_.original_tagname_ = 'GasPriceEscalationRate'
        elif nodeName_ == 'ElectricityPriceEscalationRate':
            obj_ = ElectricityPriceEscalationRateType.factory()
            obj_.build(child_)
            self.ElectricityPriceEscalationRate = obj_
            obj_.original_tagname_ = 'ElectricityPriceEscalationRate'
        elif nodeName_ == 'WaterPriceEscalationRate':
            obj_ = WaterPriceEscalationRateType.factory()
            obj_.build(child_)
            self.WaterPriceEscalationRate = obj_
            obj_.original_tagname_ = 'WaterPriceEscalationRate'
        elif nodeName_ == 'OtherEscalationRates':
            obj_ = OtherEscalationRatesType.factory()
            obj_.build(child_)
            self.OtherEscalationRates.append(obj_)
            obj_.original_tagname_ = 'OtherEscalationRates'
        elif nodeName_ == 'InflationRate':
            obj_ = InflationRateType.factory()
            obj_.build(child_)
            self.InflationRate = obj_
            obj_.original_tagname_ = 'InflationRate'
        elif nodeName_ == 'Qualifications':
            obj_ = QualificationsType.factory()
            obj_.build(child_)
            self.Qualifications.append(obj_)
            obj_.original_tagname_ = 'Qualifications'
        elif nodeName_ == 'AuditExemption':
            AuditExemption_ = child_.text
            AuditExemption_ = self.gds_validate_string(AuditExemption_, node, 'AuditExemption')
            self.AuditExemption = AuditExemption_
            # validate type AuditExemptionType
            self.validate_AuditExemptionType(self.AuditExemption)
        elif nodeName_ == 'AuditorContactID':
            obj_ = AuditorContactIDType.factory()
            obj_.build(child_)
            self.AuditorContactID = obj_
            obj_.original_tagname_ = 'AuditorContactID'
        elif nodeName_ == 'UserDefinedFields':
            obj_ = UserDefinedFields.factory()
            obj_.build(child_)
            self.UserDefinedFields = obj_
            obj_.original_tagname_ = 'UserDefinedFields'
# end class ReportType


class ScenariosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Scenario=None):
        self.original_tagname_ = None
        if Scenario is None:
            self.Scenario = []
        else:
            self.Scenario = Scenario
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScenariosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScenariosType.subclass:
            return ScenariosType.subclass(*args_, **kwargs_)
        else:
            return ScenariosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Scenario
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScenariosType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScenariosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScenariosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScenariosType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScenariosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Scenario_ in self.Scenario:
            Scenario_.export(outfile, level, namespace_, name_='Scenario', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scenario':
            obj_ = ScenarioType.factory()
            obj_.build(child_)
            self.Scenario.append(obj_)
            obj_.original_tagname_ = 'Scenario'
# end class ScenariosType


class AuditCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuditCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuditCostType.subclass:
            return AuditCostType.subclass(*args_, **kwargs_)
        else:
            return AuditCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AuditCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuditCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AuditCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AuditCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AuditCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AuditCostType


class DiscountFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscountFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscountFactorType.subclass:
            return DiscountFactorType.subclass(*args_, **kwargs_)
        else:
            return DiscountFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DiscountFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscountFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DiscountFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DiscountFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DiscountFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DiscountFactorType


class AnalysisPeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnalysisPeriodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnalysisPeriodType.subclass:
            return AnalysisPeriodType.subclass(*args_, **kwargs_)
        else:
            return AnalysisPeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnalysisPeriodType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisPeriodType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnalysisPeriodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnalysisPeriodType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnalysisPeriodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnalysisPeriodType


class GasPriceEscalationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasPriceEscalationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasPriceEscalationRateType.subclass:
            return GasPriceEscalationRateType.subclass(*args_, **kwargs_)
        else:
            return GasPriceEscalationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GasPriceEscalationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GasPriceEscalationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GasPriceEscalationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GasPriceEscalationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GasPriceEscalationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GasPriceEscalationRateType


class ElectricityPriceEscalationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityPriceEscalationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityPriceEscalationRateType.subclass:
            return ElectricityPriceEscalationRateType.subclass(*args_, **kwargs_)
        else:
            return ElectricityPriceEscalationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricityPriceEscalationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricityPriceEscalationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricityPriceEscalationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricityPriceEscalationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricityPriceEscalationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricityPriceEscalationRateType


class WaterPriceEscalationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterPriceEscalationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterPriceEscalationRateType.subclass:
            return WaterPriceEscalationRateType.subclass(*args_, **kwargs_)
        else:
            return WaterPriceEscalationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterPriceEscalationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterPriceEscalationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterPriceEscalationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterPriceEscalationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterPriceEscalationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterPriceEscalationRateType


class OtherEscalationRatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, EnergyResource=None, EscalationRate=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.EnergyResource = EnergyResource
        self.validate_EnergyResource(self.EnergyResource)
        self.EscalationRate = EscalationRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherEscalationRatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherEscalationRatesType.subclass:
            return OtherEscalationRatesType.subclass(*args_, **kwargs_)
        else:
            return OtherEscalationRatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnergyResource(self, value):
        # Validate type EnergyResource, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.EnergyResource is not None or
            self.EscalationRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherEscalationRatesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherEscalationRatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherEscalationRatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherEscalationRatesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherEscalationRatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyResource>%s</%sEnergyResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyResource), input_name='EnergyResource')), namespace_, eol_))
        if self.EscalationRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEscalationRate>%s</%sEscalationRate>%s' % (namespace_, self.gds_format_float(self.EscalationRate, input_name='EscalationRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyResource':
            EnergyResource_ = child_.text
            EnergyResource_ = self.gds_validate_string(EnergyResource_, node, 'EnergyResource')
            self.EnergyResource = EnergyResource_
            # validate type EnergyResource
            self.validate_EnergyResource(self.EnergyResource)
        elif nodeName_ == 'EscalationRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'EscalationRate')
            self.EscalationRate = fval_
# end class OtherEscalationRatesType


class InflationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InflationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InflationRateType.subclass:
            return InflationRateType.subclass(*args_, **kwargs_)
        else:
            return InflationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InflationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InflationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InflationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InflationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InflationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InflationRateType


class QualificationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AuditorQualification=None, AuditorQualificationNumber=None, AuditorQualificationState=None, CertificationExpirationDate=None, CertifiedAuditTeamMemberContactID=None, AuditTeamMemberCertificationType=None):
        self.original_tagname_ = None
        self.AuditorQualification = AuditorQualification
        self.validate_AuditorQualificationType(self.AuditorQualification)
        self.AuditorQualificationNumber = AuditorQualificationNumber
        self.AuditorQualificationState = AuditorQualificationState
        self.validate_State(self.AuditorQualificationState)
        if isinstance(CertificationExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CertificationExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = CertificationExpirationDate
        self.CertificationExpirationDate = initvalue_
        self.CertifiedAuditTeamMemberContactID = CertifiedAuditTeamMemberContactID
        self.AuditTeamMemberCertificationType = AuditTeamMemberCertificationType
        self.validate_AuditorQualificationType(self.AuditTeamMemberCertificationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QualificationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QualificationsType.subclass:
            return QualificationsType.subclass(*args_, **kwargs_)
        else:
            return QualificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AuditorQualificationType(self, value):
        # Validate type AuditorQualificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Professional Engineer (PE)', 'Certified Energy Manager (CEM)', 'Building Operator Certification (BOC)', 'Building Performance Institute (BPI) Certification', 'Building Performance Institute: Building Analyst (BA)', 'Building Performance Institute: Advanced Home Energy Professional (HEP)', 'Building Performance Institute: Advanced Home Energy Professional - Energy Auditor (HEP-EA)', 'Building Performance Institute: Advanced Home Energy Professional - Quality Control Inspector (HEP-QCI)', 'Building Performance Institute: Multifamily Building Analyst', 'Residential Energy Services Network (RESNET) Certification', 'Residential Energy Services Network (RESNET) - Home Partner', 'Registered Architect (RA)', 'Refrigerating System Operating Engineer', 'High Pressure Boiler Operating Engineer', 'Certified Commissioning Professional (CCP)', 'Associate Commissioning Professional (ACP)', 'Existing Building Commissioning Professional (EBCP)', 'Commissioning Process Management Professional (CPMP)', 'Accredited Commissioning Process Authority Professional (CxAP)', 'NYSERDA FlexTech Consultant', 'Certified Energy Auditor (CEA)', 'High-Performance Building Design Professional (HBDP)', 'Other', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AuditorQualificationType' % {"value" : value.encode("utf-8")} )
    def validate_State(self, value):
        # Validate type State, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AA', 'AE', 'AL', 'AK', 'AP', 'AS', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'DC', 'FM', 'FL', 'GA', 'GU', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MH', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'MP', 'OH', 'OK', 'OR', 'PW', 'PA', 'PR', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VI', 'VA', 'WA', 'WV', 'WI', 'WY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on State' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AuditorQualification is not None or
            self.AuditorQualificationNumber is not None or
            self.AuditorQualificationState is not None or
            self.CertificationExpirationDate is not None or
            self.CertifiedAuditTeamMemberContactID is not None or
            self.AuditTeamMemberCertificationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='QualificationsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualificationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='QualificationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='QualificationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='QualificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AuditorQualification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditorQualification>%s</%sAuditorQualification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AuditorQualification), input_name='AuditorQualification')), namespace_, eol_))
        if self.AuditorQualificationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditorQualificationNumber>%s</%sAuditorQualificationNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AuditorQualificationNumber), input_name='AuditorQualificationNumber')), namespace_, eol_))
        if self.AuditorQualificationState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditorQualificationState>%s</%sAuditorQualificationState>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AuditorQualificationState), input_name='AuditorQualificationState')), namespace_, eol_))
        if self.CertificationExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCertificationExpirationDate>%s</%sCertificationExpirationDate>%s' % (namespace_, self.gds_format_date(self.CertificationExpirationDate, input_name='CertificationExpirationDate'), namespace_, eol_))
        if self.CertifiedAuditTeamMemberContactID is not None:
            self.CertifiedAuditTeamMemberContactID.export(outfile, level, namespace_, name_='CertifiedAuditTeamMemberContactID', pretty_print=pretty_print)
        if self.AuditTeamMemberCertificationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuditTeamMemberCertificationType>%s</%sAuditTeamMemberCertificationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AuditTeamMemberCertificationType), input_name='AuditTeamMemberCertificationType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AuditorQualification':
            AuditorQualification_ = child_.text
            AuditorQualification_ = self.gds_validate_string(AuditorQualification_, node, 'AuditorQualification')
            self.AuditorQualification = AuditorQualification_
            # validate type AuditorQualificationType
            self.validate_AuditorQualificationType(self.AuditorQualification)
        elif nodeName_ == 'AuditorQualificationNumber':
            AuditorQualificationNumber_ = child_.text
            AuditorQualificationNumber_ = self.gds_validate_string(AuditorQualificationNumber_, node, 'AuditorQualificationNumber')
            self.AuditorQualificationNumber = AuditorQualificationNumber_
        elif nodeName_ == 'AuditorQualificationState':
            AuditorQualificationState_ = child_.text
            AuditorQualificationState_ = self.gds_validate_string(AuditorQualificationState_, node, 'AuditorQualificationState')
            self.AuditorQualificationState = AuditorQualificationState_
            # validate type State
            self.validate_State(self.AuditorQualificationState)
        elif nodeName_ == 'CertificationExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.CertificationExpirationDate = dval_
        elif nodeName_ == 'CertifiedAuditTeamMemberContactID':
            obj_ = CertifiedAuditTeamMemberContactIDType.factory()
            obj_.build(child_)
            self.CertifiedAuditTeamMemberContactID = obj_
            obj_.original_tagname_ = 'CertifiedAuditTeamMemberContactID'
        elif nodeName_ == 'AuditTeamMemberCertificationType':
            AuditTeamMemberCertificationType_ = child_.text
            AuditTeamMemberCertificationType_ = self.gds_validate_string(AuditTeamMemberCertificationType_, node, 'AuditTeamMemberCertificationType')
            self.AuditTeamMemberCertificationType = AuditTeamMemberCertificationType_
            # validate type AuditorQualificationType
            self.validate_AuditorQualificationType(self.AuditTeamMemberCertificationType)
# end class QualificationsType


class CertifiedAuditTeamMemberContactIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CertifiedAuditTeamMemberContactIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CertifiedAuditTeamMemberContactIDType.subclass:
            return CertifiedAuditTeamMemberContactIDType.subclass(*args_, **kwargs_)
        else:
            return CertifiedAuditTeamMemberContactIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CertifiedAuditTeamMemberContactIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CertifiedAuditTeamMemberContactIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CertifiedAuditTeamMemberContactIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CertifiedAuditTeamMemberContactIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CertifiedAuditTeamMemberContactIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CertifiedAuditTeamMemberContactIDType


class AuditorContactIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuditorContactIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuditorContactIDType.subclass:
            return AuditorContactIDType.subclass(*args_, **kwargs_)
        else:
            return AuditorContactIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AuditorContactIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuditorContactIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AuditorContactIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AuditorContactIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AuditorContactIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AuditorContactIDType


class ContactsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Contact=None):
        self.original_tagname_ = None
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactsType.subclass:
            return ContactsType.subclass(*args_, **kwargs_)
        else:
            return ContactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Contact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ContactsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ContactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ContactsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ContactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Contact_ in self.Contact:
            Contact_.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Contact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.Contact.append(obj_)
            obj_.original_tagname_ = 'Contact'
# end class ContactsType


class ClimateZoneTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ASHRAE=None, EnergyStar=None, CaliforniaTitle24=None, IECC=None, BuildingAmerica=None, CBECS=None, DOE=None, Other=None):
        self.original_tagname_ = None
        self.ASHRAE = ASHRAE
        self.EnergyStar = EnergyStar
        self.CaliforniaTitle24 = CaliforniaTitle24
        self.IECC = IECC
        self.BuildingAmerica = BuildingAmerica
        self.CBECS = CBECS
        self.DOE = DOE
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClimateZoneTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClimateZoneTypeType.subclass:
            return ClimateZoneTypeType.subclass(*args_, **kwargs_)
        else:
            return ClimateZoneTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ASHRAE is not None or
            self.EnergyStar is not None or
            self.CaliforniaTitle24 is not None or
            self.IECC is not None or
            self.BuildingAmerica is not None or
            self.CBECS is not None or
            self.DOE is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClimateZoneTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClimateZoneTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClimateZoneTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClimateZoneTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClimateZoneTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASHRAE is not None:
            self.ASHRAE.export(outfile, level, namespace_, name_='ASHRAE', pretty_print=pretty_print)
        if self.EnergyStar is not None:
            self.EnergyStar.export(outfile, level, namespace_, name_='EnergyStar', pretty_print=pretty_print)
        if self.CaliforniaTitle24 is not None:
            self.CaliforniaTitle24.export(outfile, level, namespace_, name_='CaliforniaTitle24', pretty_print=pretty_print)
        if self.IECC is not None:
            self.IECC.export(outfile, level, namespace_, name_='IECC', pretty_print=pretty_print)
        if self.BuildingAmerica is not None:
            self.BuildingAmerica.export(outfile, level, namespace_, name_='BuildingAmerica', pretty_print=pretty_print)
        if self.CBECS is not None:
            self.CBECS.export(outfile, level, namespace_, name_='CBECS', pretty_print=pretty_print)
        if self.DOE is not None:
            self.DOE.export(outfile, level, namespace_, name_='DOE', pretty_print=pretty_print)
        if self.Other is not None:
            self.Other.export(outfile, level, namespace_, name_='Other', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ASHRAE':
            obj_ = ASHRAEType.factory()
            obj_.build(child_)
            self.ASHRAE = obj_
            obj_.original_tagname_ = 'ASHRAE'
        elif nodeName_ == 'EnergyStar':
            obj_ = EnergyStarType.factory()
            obj_.build(child_)
            self.EnergyStar = obj_
            obj_.original_tagname_ = 'EnergyStar'
        elif nodeName_ == 'CaliforniaTitle24':
            obj_ = CaliforniaTitle24Type.factory()
            obj_.build(child_)
            self.CaliforniaTitle24 = obj_
            obj_.original_tagname_ = 'CaliforniaTitle24'
        elif nodeName_ == 'IECC':
            obj_ = IECCType.factory()
            obj_.build(child_)
            self.IECC = obj_
            obj_.original_tagname_ = 'IECC'
        elif nodeName_ == 'BuildingAmerica':
            obj_ = BuildingAmericaType.factory()
            obj_.build(child_)
            self.BuildingAmerica = obj_
            obj_.original_tagname_ = 'BuildingAmerica'
        elif nodeName_ == 'CBECS':
            obj_ = CBECSType.factory()
            obj_.build(child_)
            self.CBECS = obj_
            obj_.original_tagname_ = 'CBECS'
        elif nodeName_ == 'DOE':
            obj_ = DOEType.factory()
            obj_.build(child_)
            self.DOE = obj_
            obj_.original_tagname_ = 'DOE'
        elif nodeName_ == 'Other':
            obj_ = OtherType.factory()
            obj_.build(child_)
            self.Other = obj_
            obj_.original_tagname_ = 'Other'
# end class ClimateZoneTypeType


class ASHRAEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType2(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ASHRAEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ASHRAEType.subclass:
            return ASHRAEType.subclass(*args_, **kwargs_)
        else:
            return ASHRAEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType2(self, value):
        # Validate type ClimateZoneType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1A', '1B', '2A', '2B', '3A', '3B', '3C', '4A', '4B', '4C', '5A', '5B', '5C', '6A', '6B', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType2' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ASHRAEType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ASHRAEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ASHRAEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ASHRAEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ASHRAEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType2
            self.validate_ClimateZoneType2(self.ClimateZone)
# end class ASHRAEType


class EnergyStarType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType3(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyStarType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyStarType.subclass:
            return EnergyStarType.subclass(*args_, **kwargs_)
        else:
            return EnergyStarType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType3(self, value):
        # Validate type ClimateZoneType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Northern', 'North-Central', 'South-Central', 'Southern']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType3' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyStarType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyStarType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyStarType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyStarType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyStarType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType3
            self.validate_ClimateZoneType3(self.ClimateZone)
# end class EnergyStarType


class CaliforniaTitle24Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType4(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CaliforniaTitle24Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CaliforniaTitle24Type.subclass:
            return CaliforniaTitle24Type.subclass(*args_, **kwargs_)
        else:
            return CaliforniaTitle24Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType4(self, value):
        # Validate type ClimateZoneType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Climate Zone 1', 'Climate Zone 2', 'Climate Zone 3', 'Climate Zone 4', 'Climate Zone 5', 'Climate Zone 6', 'Climate Zone 7', 'Climate Zone 8', 'Climate Zone 9', 'Climate Zone 10', 'Climate Zone 11', 'Climate Zone 12', 'Climate Zone 13', 'Climate Zone 14', 'Climate Zone 15', 'Climate Zone 16']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType4' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CaliforniaTitle24Type', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CaliforniaTitle24Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CaliforniaTitle24Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CaliforniaTitle24Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CaliforniaTitle24Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType4
            self.validate_ClimateZoneType4(self.ClimateZone)
# end class CaliforniaTitle24Type


class IECCType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType5(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IECCType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IECCType.subclass:
            return IECCType.subclass(*args_, **kwargs_)
        else:
            return IECCType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType5(self, value):
        # Validate type ClimateZoneType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4 (Except Marine)', '4 (Marine)', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType5' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IECCType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IECCType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IECCType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IECCType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IECCType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType5
            self.validate_ClimateZoneType5(self.ClimateZone)
# end class IECCType


class BuildingAmericaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType6(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BuildingAmericaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BuildingAmericaType.subclass:
            return BuildingAmericaType.subclass(*args_, **kwargs_)
        else:
            return BuildingAmericaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType6(self, value):
        # Validate type ClimateZoneType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Subarctic', 'Marine', 'Hot-dry', 'Mixed-dry', 'Hot-humid', 'Mixed-humid', 'Cold', 'Very cold']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType6' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BuildingAmericaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildingAmericaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BuildingAmericaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BuildingAmericaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BuildingAmericaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType6
            self.validate_ClimateZoneType6(self.ClimateZone)
# end class BuildingAmericaType


class CBECSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType7(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CBECSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CBECSType.subclass:
            return CBECSType.subclass(*args_, **kwargs_)
        else:
            return CBECSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType7(self, value):
        # Validate type ClimateZoneType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType7' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CBECSType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CBECSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CBECSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CBECSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CBECSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType7
            self.validate_ClimateZoneType7(self.ClimateZone)
# end class CBECSType


class DOEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
        self.validate_ClimateZoneType8(self.ClimateZone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DOEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DOEType.subclass:
            return DOEType.subclass(*args_, **kwargs_)
        else:
            return DOEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClimateZoneType8(self, value):
        # Validate type ClimateZoneType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Subarctic', 'Marine', 'Hot-dry', 'Mixed-dry', 'Hot-humid', 'Mixed-humid', 'Cold', 'Very cold']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClimateZoneType8' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DOEType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DOEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DOEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DOEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DOEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
            # validate type ClimateZoneType8
            self.validate_ClimateZoneType8(self.ClimateZone)
# end class DOEType


class OtherType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClimateZone=None):
        self.original_tagname_ = None
        self.ClimateZone = ClimateZone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherType.subclass:
            return OtherType.subclass(*args_, **kwargs_)
        else:
            return OtherType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ClimateZone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClimateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimateZone>%s</%sClimateZone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClimateZone), input_name='ClimateZone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClimateZone':
            ClimateZone_ = child_.text
            ClimateZone_ = self.gds_validate_string(ClimateZone_, node, 'ClimateZone')
            self.ClimateZone = ClimateZone_
# end class OtherType


class WeatherDataStationIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherDataStationIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherDataStationIDType.subclass:
            return WeatherDataStationIDType.subclass(*args_, **kwargs_)
        else:
            return WeatherDataStationIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WeatherDataStationIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherDataStationIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WeatherDataStationIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WeatherDataStationIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WeatherDataStationIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WeatherDataStationIDType


class LongitudeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LongitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LongitudeType.subclass:
            return LongitudeType.subclass(*args_, **kwargs_)
        else:
            return LongitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LongitudeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LongitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LongitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LongitudeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LongitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LongitudeType


class LatitudeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LatitudeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LatitudeType.subclass:
            return LatitudeType.subclass(*args_, **kwargs_)
        else:
            return LatitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LatitudeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LatitudeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LatitudeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LatitudeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LatitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LatitudeType


class CommercialFacilitiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommercialFacility=None):
        self.original_tagname_ = None
        if CommercialFacility is None:
            self.CommercialFacility = []
        else:
            self.CommercialFacility = CommercialFacility
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommercialFacilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommercialFacilitiesType.subclass:
            return CommercialFacilitiesType.subclass(*args_, **kwargs_)
        else:
            return CommercialFacilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CommercialFacility
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CommercialFacilitiesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommercialFacilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CommercialFacilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CommercialFacilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CommercialFacilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CommercialFacility_ in self.CommercialFacility:
            CommercialFacility_.export(outfile, level, namespace_, name_='CommercialFacility', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommercialFacility':
            obj_ = CommercialFacilityType.factory()
            obj_.build(child_)
            self.CommercialFacility.append(obj_)
            obj_.original_tagname_ = 'CommercialFacility'
# end class CommercialFacilitiesType


class SpatialUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpatialUnitType=None, NumberOfUnits=None, UnitDensity=None):
        self.original_tagname_ = None
        self.SpatialUnitType = SpatialUnitType
        self.validate_SpatialUnitTypeType(self.SpatialUnitType)
        self.NumberOfUnits = NumberOfUnits
        self.UnitDensity = UnitDensity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpatialUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpatialUnitsType.subclass:
            return SpatialUnitsType.subclass(*args_, **kwargs_)
        else:
            return SpatialUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SpatialUnitTypeType(self, value):
        # Validate type SpatialUnitTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Lots', 'Parking spaces', 'Apartment units', 'Businesses', 'Guest rooms', 'Stations', 'Buildings', 'Areas', 'Thermal Zones', 'Floors', 'Rooms', 'Bedrooms', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpatialUnitTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpatialUnitType is not None or
            self.NumberOfUnits is not None or
            self.UnitDensity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpatialUnitsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpatialUnitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpatialUnitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpatialUnitsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpatialUnitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpatialUnitType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpatialUnitType>%s</%sSpatialUnitType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SpatialUnitType), input_name='SpatialUnitType')), namespace_, eol_))
        if self.NumberOfUnits is not None:
            self.NumberOfUnits.export(outfile, level, namespace_, name_='NumberOfUnits', pretty_print=pretty_print)
        if self.UnitDensity is not None:
            self.UnitDensity.export(outfile, level, namespace_, name_='UnitDensity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpatialUnitType':
            SpatialUnitType_ = child_.text
            SpatialUnitType_ = self.gds_validate_string(SpatialUnitType_, node, 'SpatialUnitType')
            self.SpatialUnitType = SpatialUnitType_
            # validate type SpatialUnitTypeType
            self.validate_SpatialUnitTypeType(self.SpatialUnitType)
        elif nodeName_ == 'NumberOfUnits':
            obj_ = NumberOfUnitsType.factory()
            obj_.build(child_)
            self.NumberOfUnits = obj_
            obj_.original_tagname_ = 'NumberOfUnits'
        elif nodeName_ == 'UnitDensity':
            obj_ = UnitDensityType.factory()
            obj_.build(child_)
            self.UnitDensity = obj_
            obj_.original_tagname_ = 'UnitDensity'
# end class SpatialUnitsType


class NumberOfUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfUnitsType.subclass:
            return NumberOfUnitsType.subclass(*args_, **kwargs_)
        else:
            return NumberOfUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfUnitsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfUnitsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfUnitsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfUnitsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfUnitsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfUnitsType


class UnitDensityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitDensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitDensityType.subclass:
            return UnitDensityType.subclass(*args_, **kwargs_)
        else:
            return UnitDensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UnitDensityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitDensityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UnitDensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UnitDensityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UnitDensityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnitDensityType


class FederalBuildingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FederalBuildingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FederalBuildingType.subclass:
            return FederalBuildingType.subclass(*args_, **kwargs_)
        else:
            return FederalBuildingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FederalBuildingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FederalBuildingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FederalBuildingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FederalBuildingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FederalBuildingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class FederalBuildingType


class False(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, False)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if False.subclass:
            return False.subclass(*args_, **kwargs_)
        else:
            return False(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='False', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='False')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='False', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='False'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='False', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class False


class TrueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Agency=None, DepartmentRegion=None):
        self.original_tagname_ = None
        self.Agency = Agency
        self.DepartmentRegion = DepartmentRegion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType.subclass:
            return TrueType.subclass(*args_, **kwargs_)
        else:
            return TrueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Agency is not None or
            self.DepartmentRegion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Agency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgency>%s</%sAgency>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Agency), input_name='Agency')), namespace_, eol_))
        if self.DepartmentRegion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDepartmentRegion>%s</%sDepartmentRegion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DepartmentRegion), input_name='DepartmentRegion')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Agency':
            Agency_ = child_.text
            Agency_ = self.gds_validate_string(Agency_, node, 'Agency')
            self.Agency = Agency_
        elif nodeName_ == 'DepartmentRegion':
            DepartmentRegion_ = child_.text
            DepartmentRegion_ = self.gds_validate_string(DepartmentRegion_, node, 'DepartmentRegion')
            self.DepartmentRegion = DepartmentRegion_
# end class TrueType


class PortfolioManagerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioManagerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioManagerType.subclass:
            return PortfolioManagerType.subclass(*args_, **kwargs_)
        else:
            return PortfolioManagerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PortfolioManagerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioManagerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PortfolioManagerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PortfolioManagerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PortfolioManagerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType9.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class PortfolioManagerType


class TrueType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PMBenchmarkDate=None, BuildingProfileStatus=None, FederalSustainabilityChecklistCompletionPercentage=None):
        self.original_tagname_ = None
        if isinstance(PMBenchmarkDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PMBenchmarkDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PMBenchmarkDate
        self.PMBenchmarkDate = initvalue_
        self.BuildingProfileStatus = BuildingProfileStatus
        self.validate_BuildingProfileStatusType(self.BuildingProfileStatus)
        self.FederalSustainabilityChecklistCompletionPercentage = FederalSustainabilityChecklistCompletionPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType9.subclass:
            return TrueType9.subclass(*args_, **kwargs_)
        else:
            return TrueType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BuildingProfileStatusType(self, value):
        # Validate type BuildingProfileStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Draft', 'Received', 'Under Review', 'On Hold', 'Reviewed and Approved', 'Reviewed and Not Approved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BuildingProfileStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PMBenchmarkDate is not None or
            self.BuildingProfileStatus is not None or
            self.FederalSustainabilityChecklistCompletionPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType9', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PMBenchmarkDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPMBenchmarkDate>%s</%sPMBenchmarkDate>%s' % (namespace_, self.gds_format_date(self.PMBenchmarkDate, input_name='PMBenchmarkDate'), namespace_, eol_))
        if self.BuildingProfileStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBuildingProfileStatus>%s</%sBuildingProfileStatus>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BuildingProfileStatus), input_name='BuildingProfileStatus')), namespace_, eol_))
        if self.FederalSustainabilityChecklistCompletionPercentage is not None:
            self.FederalSustainabilityChecklistCompletionPercentage.export(outfile, level, namespace_, name_='FederalSustainabilityChecklistCompletionPercentage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PMBenchmarkDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PMBenchmarkDate = dval_
        elif nodeName_ == 'BuildingProfileStatus':
            BuildingProfileStatus_ = child_.text
            BuildingProfileStatus_ = self.gds_validate_string(BuildingProfileStatus_, node, 'BuildingProfileStatus')
            self.BuildingProfileStatus = BuildingProfileStatus_
            # validate type BuildingProfileStatusType
            self.validate_BuildingProfileStatusType(self.BuildingProfileStatus)
        elif nodeName_ == 'FederalSustainabilityChecklistCompletionPercentage':
            obj_ = FederalSustainabilityChecklistCompletionPercentageType.factory()
            obj_.build(child_)
            self.FederalSustainabilityChecklistCompletionPercentage = obj_
            obj_.original_tagname_ = 'FederalSustainabilityChecklistCompletionPercentage'
# end class TrueType9


class FederalSustainabilityChecklistCompletionPercentageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FederalSustainabilityChecklistCompletionPercentageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FederalSustainabilityChecklistCompletionPercentageType.subclass:
            return FederalSustainabilityChecklistCompletionPercentageType.subclass(*args_, **kwargs_)
        else:
            return FederalSustainabilityChecklistCompletionPercentageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FederalSustainabilityChecklistCompletionPercentageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FederalSustainabilityChecklistCompletionPercentageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FederalSustainabilityChecklistCompletionPercentageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FederalSustainabilityChecklistCompletionPercentageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FederalSustainabilityChecklistCompletionPercentageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FederalSustainabilityChecklistCompletionPercentageType


class NumberOfBusinessesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfBusinessesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfBusinessesType.subclass:
            return NumberOfBusinessesType.subclass(*args_, **kwargs_)
        else:
            return NumberOfBusinessesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfBusinessesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfBusinessesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfBusinessesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfBusinessesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfBusinessesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfBusinessesType


class AspectRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AspectRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AspectRatioType.subclass:
            return AspectRatioType.subclass(*args_, **kwargs_)
        else:
            return AspectRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AspectRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AspectRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AspectRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AspectRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AspectRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AspectRatioType


class PerimeterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PerimeterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PerimeterType.subclass:
            return PerimeterType.subclass(*args_, **kwargs_)
        else:
            return PerimeterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PerimeterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PerimeterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PerimeterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PerimeterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PerimeterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PerimeterType


class AssessmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AssessmentProgram=None, AssessmentLevel=None, AssessmentValue=None, AssessmentYear=None, AssessmentVersion=None):
        self.original_tagname_ = None
        self.AssessmentProgram = AssessmentProgram
        self.validate_AssessmentProgramType(self.AssessmentProgram)
        self.AssessmentLevel = AssessmentLevel
        self.validate_AssessmentLevelType(self.AssessmentLevel)
        self.AssessmentValue = AssessmentValue
        self.AssessmentYear = AssessmentYear
        self.AssessmentVersion = AssessmentVersion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssessmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssessmentType.subclass:
            return AssessmentType.subclass(*args_, **kwargs_)
        else:
            return AssessmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AssessmentProgramType(self, value):
        # Validate type AssessmentProgramType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ENERGY STAR', 'ENERGY STAR Certified Homes', 'LEED', 'Home Energy Upgrade Certificate of Energy Efficiency Performance', 'Home Energy Upgrade Certificate of Energy Efficiency Improvements', 'Passive House', 'Living Building Challenge', 'Green Globes', 'Challenge Home', 'WaterSense', 'Indoor airPLUS', 'NGBS ICC 700', 'CMP Green Value Score', 'RESNET HERS', 'Home Energy Score', 'ASHRAE Building EQ', 'Commercial Building Energy Asset Score', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssessmentProgramType' % {"value" : value.encode("utf-8")} )
    def validate_AssessmentLevelType(self, value):
        # Validate type AssessmentLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bronze', 'Silver', 'Gold', 'Emerald', 'Certified', 'Platinum', 'One Star', 'Two Star', 'Three Star', 'Four Star', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssessmentLevelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AssessmentProgram is not None or
            self.AssessmentLevel is not None or
            self.AssessmentValue is not None or
            self.AssessmentYear is not None or
            self.AssessmentVersion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AssessmentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssessmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AssessmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AssessmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AssessmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssessmentProgram is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssessmentProgram>%s</%sAssessmentProgram>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssessmentProgram), input_name='AssessmentProgram')), namespace_, eol_))
        if self.AssessmentLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssessmentLevel>%s</%sAssessmentLevel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssessmentLevel), input_name='AssessmentLevel')), namespace_, eol_))
        if self.AssessmentValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssessmentValue>%s</%sAssessmentValue>%s' % (namespace_, self.gds_format_float(self.AssessmentValue, input_name='AssessmentValue'), namespace_, eol_))
        if self.AssessmentYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssessmentYear>%s</%sAssessmentYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssessmentYear), input_name='AssessmentYear')), namespace_, eol_))
        if self.AssessmentVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssessmentVersion>%s</%sAssessmentVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssessmentVersion), input_name='AssessmentVersion')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssessmentProgram':
            AssessmentProgram_ = child_.text
            AssessmentProgram_ = self.gds_validate_string(AssessmentProgram_, node, 'AssessmentProgram')
            self.AssessmentProgram = AssessmentProgram_
            # validate type AssessmentProgramType
            self.validate_AssessmentProgramType(self.AssessmentProgram)
        elif nodeName_ == 'AssessmentLevel':
            AssessmentLevel_ = child_.text
            AssessmentLevel_ = self.gds_validate_string(AssessmentLevel_, node, 'AssessmentLevel')
            self.AssessmentLevel = AssessmentLevel_
            # validate type AssessmentLevelType
            self.validate_AssessmentLevelType(self.AssessmentLevel)
        elif nodeName_ == 'AssessmentValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AssessmentValue')
            self.AssessmentValue = fval_
        elif nodeName_ == 'AssessmentYear':
            AssessmentYear_ = child_.text
            AssessmentYear_ = self.gds_validate_string(AssessmentYear_, node, 'AssessmentYear')
            self.AssessmentYear = AssessmentYear_
        elif nodeName_ == 'AssessmentVersion':
            AssessmentVersion_ = child_.text
            AssessmentVersion_ = self.gds_validate_string(AssessmentVersion_, node, 'AssessmentVersion')
            self.AssessmentVersion = AssessmentVersion_
# end class AssessmentType


class PercentOccupiedByOwnerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentOccupiedByOwnerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentOccupiedByOwnerType.subclass:
            return PercentOccupiedByOwnerType.subclass(*args_, **kwargs_)
        else:
            return PercentOccupiedByOwnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentOccupiedByOwnerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentOccupiedByOwnerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentOccupiedByOwnerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentOccupiedByOwnerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentOccupiedByOwnerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentOccupiedByOwnerType


class SubsectionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Subsection=None):
        self.original_tagname_ = None
        if Subsection is None:
            self.Subsection = []
        else:
            self.Subsection = Subsection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsectionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsectionsType.subclass:
            return SubsectionsType.subclass(*args_, **kwargs_)
        else:
            return SubsectionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Subsection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SubsectionsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsectionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SubsectionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SubsectionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SubsectionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Subsection_ in self.Subsection:
            Subsection_.export(outfile, level, namespace_, name_='Subsection', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subsection':
            obj_ = SubsectionType.factory()
            obj_.build(child_)
            self.Subsection.append(obj_)
            obj_.original_tagname_ = 'Subsection'
# end class SubsectionsType


class SubsectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Block=None, Zone=None, Space=None):
        self.original_tagname_ = None
        self.Block = Block
        self.Zone = Zone
        self.Space = Space
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsectionType.subclass:
            return SubsectionType.subclass(*args_, **kwargs_)
        else:
            return SubsectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Block is not None or
            self.Zone is not None or
            self.Space is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SubsectionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SubsectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SubsectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SubsectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Block is not None:
            self.Block.export(outfile, level, namespace_, name_='Block', pretty_print=pretty_print)
        if self.Zone is not None:
            self.Zone.export(outfile, level, namespace_, name_='Zone', pretty_print=pretty_print)
        if self.Space is not None:
            self.Space.export(outfile, level, namespace_, name_='Space', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Block':
            obj_ = BlockType.factory()
            obj_.build(child_)
            self.Block = obj_
            obj_.original_tagname_ = 'Block'
        elif nodeName_ == 'Zone':
            obj_ = ZoneType.factory()
            obj_.build(child_)
            self.Zone = obj_
            obj_.original_tagname_ = 'Zone'
        elif nodeName_ == 'Space':
            obj_ = SpaceType.factory()
            obj_.build(child_)
            self.Space = obj_
            obj_.original_tagname_ = 'Space'
# end class SubsectionType


class PerimeterZoneDepthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PerimeterZoneDepthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PerimeterZoneDepthType.subclass:
            return PerimeterZoneDepthType.subclass(*args_, **kwargs_)
        else:
            return PerimeterZoneDepthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PerimeterZoneDepthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PerimeterZoneDepthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PerimeterZoneDepthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PerimeterZoneDepthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PerimeterZoneDepthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PerimeterZoneDepthType


class SideA1OrientationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SideA1OrientationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SideA1OrientationType.subclass:
            return SideA1OrientationType.subclass(*args_, **kwargs_)
        else:
            return SideA1OrientationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SideA1OrientationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SideA1OrientationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SideA1OrientationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SideA1OrientationType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SideA1OrientationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SideA1OrientationType


class SidesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Side=None):
        self.original_tagname_ = None
        if Side is None:
            self.Side = []
        else:
            self.Side = Side
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SidesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SidesType.subclass:
            return SidesType.subclass(*args_, **kwargs_)
        else:
            return SidesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Side
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SidesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SidesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SidesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SidesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SidesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Side_ in self.Side:
            Side_.export(outfile, level, namespace_, name_='Side', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Side':
            obj_ = SideType.factory()
            obj_.build(child_)
            self.Side.append(obj_)
            obj_.original_tagname_ = 'Side'
# end class SidesType


class SideType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SideNumber=None, SideLength=None, WallID=None, WindowID=None, DoorID=None, ZoneID=None, SpaceID=None):
        self.original_tagname_ = None
        self.SideNumber = SideNumber
        self.validate_SideNumberType(self.SideNumber)
        self.SideLength = SideLength
        self.WallID = WallID
        self.WindowID = WindowID
        self.DoorID = DoorID
        self.ZoneID = ZoneID
        self.SpaceID = SpaceID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SideType.subclass:
            return SideType.subclass(*args_, **kwargs_)
        else:
            return SideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SideNumberType(self, value):
        # Validate type SideNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3', 'D1', 'D2', 'D3', 'AO1', 'BO1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SideNumberType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SideNumber is not None or
            self.SideLength is not None or
            self.WallID is not None or
            self.WindowID is not None or
            self.DoorID is not None or
            self.ZoneID is not None or
            self.SpaceID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SideType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SideType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SideNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSideNumber>%s</%sSideNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SideNumber), input_name='SideNumber')), namespace_, eol_))
        if self.SideLength is not None:
            self.SideLength.export(outfile, level, namespace_, name_='SideLength', pretty_print=pretty_print)
        if self.WallID is not None:
            self.WallID.export(outfile, level, namespace_, name_='WallID', pretty_print=pretty_print)
        if self.WindowID is not None:
            self.WindowID.export(outfile, level, namespace_, name_='WindowID', pretty_print=pretty_print)
        if self.DoorID is not None:
            self.DoorID.export(outfile, level, namespace_, name_='DoorID', pretty_print=pretty_print)
        if self.ZoneID is not None:
            self.ZoneID.export(outfile, level, namespace_, name_='ZoneID', pretty_print=pretty_print)
        if self.SpaceID is not None:
            self.SpaceID.export(outfile, level, namespace_, name_='SpaceID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideNumber':
            SideNumber_ = child_.text
            SideNumber_ = self.gds_validate_string(SideNumber_, node, 'SideNumber')
            self.SideNumber = SideNumber_
            # validate type SideNumberType
            self.validate_SideNumberType(self.SideNumber)
        elif nodeName_ == 'SideLength':
            obj_ = SideLengthType.factory()
            obj_.build(child_)
            self.SideLength = obj_
            obj_.original_tagname_ = 'SideLength'
        elif nodeName_ == 'WallID':
            obj_ = WallIDType.factory()
            obj_.build(child_)
            self.WallID = obj_
            obj_.original_tagname_ = 'WallID'
        elif nodeName_ == 'WindowID':
            obj_ = WindowIDType.factory()
            obj_.build(child_)
            self.WindowID = obj_
            obj_.original_tagname_ = 'WindowID'
        elif nodeName_ == 'DoorID':
            obj_ = DoorIDType.factory()
            obj_.build(child_)
            self.DoorID = obj_
            obj_.original_tagname_ = 'DoorID'
        elif nodeName_ == 'ZoneID':
            obj_ = ZoneIDType.factory()
            obj_.build(child_)
            self.ZoneID = obj_
            obj_.original_tagname_ = 'ZoneID'
        elif nodeName_ == 'SpaceID':
            obj_ = SpaceIDType.factory()
            obj_.build(child_)
            self.SpaceID = obj_
            obj_.original_tagname_ = 'SpaceID'
# end class SideType


class SideLengthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SideLengthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SideLengthType.subclass:
            return SideLengthType.subclass(*args_, **kwargs_)
        else:
            return SideLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SideLengthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SideLengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SideLengthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SideLengthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SideLengthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SideLengthType


class WallIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, WallArea=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.WallArea = WallArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallIDType.subclass:
            return WallIDType.subclass(*args_, **kwargs_)
        else:
            return WallIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.WallArea is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WallArea is not None:
            self.WallArea.export(outfile, level, namespace_, name_='WallArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WallArea':
            obj_ = WallAreaType.factory()
            obj_.build(child_)
            self.WallArea = obj_
            obj_.original_tagname_ = 'WallArea'
# end class WallIDType


class WallAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallAreaType.subclass:
            return WallAreaType.subclass(*args_, **kwargs_)
        else:
            return WallAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallAreaType


class WindowIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, FenestrationArea=None, WindowToWallRatio=None, PercentOfWindowAreaShaded=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.FenestrationArea = FenestrationArea
        self.WindowToWallRatio = WindowToWallRatio
        self.PercentOfWindowAreaShaded = PercentOfWindowAreaShaded
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowIDType.subclass:
            return WindowIDType.subclass(*args_, **kwargs_)
        else:
            return WindowIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FenestrationArea is not None or
            self.WindowToWallRatio is not None or
            self.PercentOfWindowAreaShaded is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FenestrationArea is not None:
            self.FenestrationArea.export(outfile, level, namespace_, name_='FenestrationArea', pretty_print=pretty_print)
        if self.WindowToWallRatio is not None:
            self.WindowToWallRatio.export(outfile, level, namespace_, name_='WindowToWallRatio', pretty_print=pretty_print)
        if self.PercentOfWindowAreaShaded is not None:
            self.PercentOfWindowAreaShaded.export(outfile, level, namespace_, name_='PercentOfWindowAreaShaded', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FenestrationArea':
            obj_ = FenestrationAreaType.factory()
            obj_.build(child_)
            self.FenestrationArea = obj_
            obj_.original_tagname_ = 'FenestrationArea'
        elif nodeName_ == 'WindowToWallRatio':
            obj_ = WindowToWallRatioType.factory()
            obj_.build(child_)
            self.WindowToWallRatio = obj_
            obj_.original_tagname_ = 'WindowToWallRatio'
        elif nodeName_ == 'PercentOfWindowAreaShaded':
            obj_ = PercentOfWindowAreaShadedType.factory()
            obj_.build(child_)
            self.PercentOfWindowAreaShaded = obj_
            obj_.original_tagname_ = 'PercentOfWindowAreaShaded'
# end class WindowIDType


class FenestrationAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationAreaType.subclass:
            return FenestrationAreaType.subclass(*args_, **kwargs_)
        else:
            return FenestrationAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FenestrationAreaType


class WindowToWallRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowToWallRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowToWallRatioType.subclass:
            return WindowToWallRatioType.subclass(*args_, **kwargs_)
        else:
            return WindowToWallRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowToWallRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowToWallRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowToWallRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowToWallRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowToWallRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WindowToWallRatioType


class PercentOfWindowAreaShadedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentOfWindowAreaShadedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentOfWindowAreaShadedType.subclass:
            return PercentOfWindowAreaShadedType.subclass(*args_, **kwargs_)
        else:
            return PercentOfWindowAreaShadedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentOfWindowAreaShadedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentOfWindowAreaShadedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentOfWindowAreaShadedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentOfWindowAreaShadedType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentOfWindowAreaShadedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentOfWindowAreaShadedType


class DoorIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, FenestrationArea=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.FenestrationArea = FenestrationArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoorIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoorIDType.subclass:
            return DoorIDType.subclass(*args_, **kwargs_)
        else:
            return DoorIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FenestrationArea is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DoorIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoorIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DoorIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DoorIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DoorIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FenestrationArea is not None:
            self.FenestrationArea.export(outfile, level, namespace_, name_='FenestrationArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FenestrationArea':
            obj_ = FenestrationAreaType10.factory()
            obj_.build(child_)
            self.FenestrationArea = obj_
            obj_.original_tagname_ = 'FenestrationArea'
# end class DoorIDType


class FenestrationAreaType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationAreaType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationAreaType10.subclass:
            return FenestrationAreaType10.subclass(*args_, **kwargs_)
        else:
            return FenestrationAreaType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationAreaType10', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationAreaType10')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationAreaType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationAreaType10'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationAreaType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FenestrationAreaType10


class ZoneIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneIDType.subclass:
            return ZoneIDType.subclass(*args_, **kwargs_)
        else:
            return ZoneIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ZoneIDType


class SpaceIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceIDType.subclass:
            return SpaceIDType.subclass(*args_, **kwargs_)
        else:
            return SpaceIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpaceIDType


class RoofIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, RoofArea=None, RoofInsulatedArea=None, SkylightID=None, ZoneID=None, SpaceID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.RoofArea = RoofArea
        self.RoofInsulatedArea = RoofInsulatedArea
        if SkylightID is None:
            self.SkylightID = []
        else:
            self.SkylightID = SkylightID
        if ZoneID is None:
            self.ZoneID = []
        else:
            self.ZoneID = ZoneID
        if SpaceID is None:
            self.SpaceID = []
        else:
            self.SpaceID = SpaceID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofIDType.subclass:
            return RoofIDType.subclass(*args_, **kwargs_)
        else:
            return RoofIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RoofArea is not None or
            self.RoofInsulatedArea is not None or
            self.SkylightID or
            self.ZoneID or
            self.SpaceID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RoofArea is not None:
            self.RoofArea.export(outfile, level, namespace_, name_='RoofArea', pretty_print=pretty_print)
        if self.RoofInsulatedArea is not None:
            self.RoofInsulatedArea.export(outfile, level, namespace_, name_='RoofInsulatedArea', pretty_print=pretty_print)
        for SkylightID_ in self.SkylightID:
            SkylightID_.export(outfile, level, namespace_, name_='SkylightID', pretty_print=pretty_print)
        for ZoneID_ in self.ZoneID:
            ZoneID_.export(outfile, level, namespace_, name_='ZoneID', pretty_print=pretty_print)
        for SpaceID_ in self.SpaceID:
            SpaceID_.export(outfile, level, namespace_, name_='SpaceID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RoofArea':
            obj_ = RoofAreaType.factory()
            obj_.build(child_)
            self.RoofArea = obj_
            obj_.original_tagname_ = 'RoofArea'
        elif nodeName_ == 'RoofInsulatedArea':
            obj_ = RoofInsulatedAreaType.factory()
            obj_.build(child_)
            self.RoofInsulatedArea = obj_
            obj_.original_tagname_ = 'RoofInsulatedArea'
        elif nodeName_ == 'SkylightID':
            obj_ = SkylightIDType.factory()
            obj_.build(child_)
            self.SkylightID.append(obj_)
            obj_.original_tagname_ = 'SkylightID'
        elif nodeName_ == 'ZoneID':
            obj_ = ZoneIDType11.factory()
            obj_.build(child_)
            self.ZoneID.append(obj_)
            obj_.original_tagname_ = 'ZoneID'
        elif nodeName_ == 'SpaceID':
            obj_ = SpaceIDType12.factory()
            obj_.build(child_)
            self.SpaceID.append(obj_)
            obj_.original_tagname_ = 'SpaceID'
# end class RoofIDType


class RoofAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofAreaType.subclass:
            return RoofAreaType.subclass(*args_, **kwargs_)
        else:
            return RoofAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofAreaType


class RoofInsulatedAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofInsulatedAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofInsulatedAreaType.subclass:
            return RoofInsulatedAreaType.subclass(*args_, **kwargs_)
        else:
            return RoofInsulatedAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofInsulatedAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofInsulatedAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofInsulatedAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofInsulatedAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofInsulatedAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofInsulatedAreaType


class SkylightIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, PercentSkylightArea=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.PercentSkylightArea = PercentSkylightArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SkylightIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SkylightIDType.subclass:
            return SkylightIDType.subclass(*args_, **kwargs_)
        else:
            return SkylightIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PercentSkylightArea is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SkylightIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SkylightIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SkylightIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SkylightIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SkylightIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PercentSkylightArea is not None:
            self.PercentSkylightArea.export(outfile, level, namespace_, name_='PercentSkylightArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PercentSkylightArea':
            obj_ = PercentSkylightAreaType.factory()
            obj_.build(child_)
            self.PercentSkylightArea = obj_
            obj_.original_tagname_ = 'PercentSkylightArea'
# end class SkylightIDType


class PercentSkylightAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentSkylightAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentSkylightAreaType.subclass:
            return PercentSkylightAreaType.subclass(*args_, **kwargs_)
        else:
            return PercentSkylightAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentSkylightAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentSkylightAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentSkylightAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentSkylightAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentSkylightAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentSkylightAreaType


class ZoneIDType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneIDType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneIDType11.subclass:
            return ZoneIDType11.subclass(*args_, **kwargs_)
        else:
            return ZoneIDType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneIDType11', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneIDType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneIDType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneIDType11'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneIDType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ZoneIDType11


class SpaceIDType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceIDType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceIDType12.subclass:
            return SpaceIDType12.subclass(*args_, **kwargs_)
        else:
            return SpaceIDType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceIDType12', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceIDType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceIDType12', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceIDType12'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceIDType12', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpaceIDType12


class FoundationIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, FoundationArea=None, ZoneID=None, SpaceID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.FoundationArea = FoundationArea
        if ZoneID is None:
            self.ZoneID = []
        else:
            self.ZoneID = ZoneID
        if SpaceID is None:
            self.SpaceID = []
        else:
            self.SpaceID = SpaceID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationIDType.subclass:
            return FoundationIDType.subclass(*args_, **kwargs_)
        else:
            return FoundationIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FoundationArea is not None or
            self.ZoneID or
            self.SpaceID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FoundationArea is not None:
            self.FoundationArea.export(outfile, level, namespace_, name_='FoundationArea', pretty_print=pretty_print)
        for ZoneID_ in self.ZoneID:
            ZoneID_.export(outfile, level, namespace_, name_='ZoneID', pretty_print=pretty_print)
        for SpaceID_ in self.SpaceID:
            SpaceID_.export(outfile, level, namespace_, name_='SpaceID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FoundationArea':
            obj_ = FoundationAreaType.factory()
            obj_.build(child_)
            self.FoundationArea = obj_
            obj_.original_tagname_ = 'FoundationArea'
        elif nodeName_ == 'ZoneID':
            obj_ = ZoneIDType13.factory()
            obj_.build(child_)
            self.ZoneID.append(obj_)
            obj_.original_tagname_ = 'ZoneID'
        elif nodeName_ == 'SpaceID':
            obj_ = SpaceIDType14.factory()
            obj_.build(child_)
            self.SpaceID.append(obj_)
            obj_.original_tagname_ = 'SpaceID'
# end class FoundationIDType


class FoundationAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationAreaType.subclass:
            return FoundationAreaType.subclass(*args_, **kwargs_)
        else:
            return FoundationAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationAreaType


class ZoneIDType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneIDType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneIDType13.subclass:
            return ZoneIDType13.subclass(*args_, **kwargs_)
        else:
            return ZoneIDType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneIDType13', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneIDType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneIDType13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneIDType13'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneIDType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ZoneIDType13


class SpaceIDType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceIDType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceIDType14.subclass:
            return SpaceIDType14.subclass(*args_, **kwargs_)
        else:
            return SpaceIDType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceIDType14', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceIDType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceIDType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceIDType14'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceIDType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpaceIDType14


class XOffsetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XOffsetType.subclass:
            return XOffsetType.subclass(*args_, **kwargs_)
        else:
            return XOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='XOffsetType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XOffsetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='XOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='XOffsetType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='XOffsetType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class XOffsetType


class YOffsetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YOffsetType.subclass:
            return YOffsetType.subclass(*args_, **kwargs_)
        else:
            return YOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='YOffsetType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YOffsetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='YOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='YOffsetType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='YOffsetType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class YOffsetType


class ZOffsetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZOffsetType.subclass:
            return ZOffsetType.subclass(*args_, **kwargs_)
        else:
            return ZOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZOffsetType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZOffsetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZOffsetType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZOffsetType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ZOffsetType


class FloorsAboveGradeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorsAboveGradeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorsAboveGradeType.subclass:
            return FloorsAboveGradeType.subclass(*args_, **kwargs_)
        else:
            return FloorsAboveGradeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorsAboveGradeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorsAboveGradeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorsAboveGradeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorsAboveGradeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorsAboveGradeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorsAboveGradeType


class FloorsBelowGradeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorsBelowGradeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorsBelowGradeType.subclass:
            return FloorsBelowGradeType.subclass(*args_, **kwargs_)
        else:
            return FloorsBelowGradeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorsBelowGradeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorsBelowGradeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorsBelowGradeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorsBelowGradeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorsBelowGradeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorsBelowGradeType


class FloorsPartiallyBelowGradeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorsPartiallyBelowGradeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorsPartiallyBelowGradeType.subclass:
            return FloorsPartiallyBelowGradeType.subclass(*args_, **kwargs_)
        else:
            return FloorsPartiallyBelowGradeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorsPartiallyBelowGradeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorsPartiallyBelowGradeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorsPartiallyBelowGradeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorsPartiallyBelowGradeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorsPartiallyBelowGradeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorsPartiallyBelowGradeType


class FloorToFloorHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorToFloorHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorToFloorHeightType.subclass:
            return FloorToFloorHeightType.subclass(*args_, **kwargs_)
        else:
            return FloorToFloorHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorToFloorHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorToFloorHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorToFloorHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorToFloorHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorToFloorHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorToFloorHeightType


class FloorToCeilingHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorToCeilingHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorToCeilingHeightType.subclass:
            return FloorToCeilingHeightType.subclass(*args_, **kwargs_)
        else:
            return FloorToCeilingHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorToCeilingHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorToCeilingHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorToCeilingHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorToCeilingHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorToCeilingHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorToCeilingHeightType


class DeliveryIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryIDType.subclass:
            return DeliveryIDType.subclass(*args_, **kwargs_)
        else:
            return DeliveryIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DeliveryIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DeliveryIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DeliveryIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DeliveryIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeliveryIDType


class HVACScheduleIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HVACScheduleIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HVACScheduleIDType.subclass:
            return HVACScheduleIDType.subclass(*args_, **kwargs_)
        else:
            return HVACScheduleIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HVACScheduleIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HVACScheduleIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HVACScheduleIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HVACScheduleIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HVACScheduleIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HVACScheduleIDType


class BlockIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockIDType.subclass:
            return BlockIDType.subclass(*args_, **kwargs_)
        else:
            return BlockIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BlockIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlockIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BlockIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BlockIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BlockIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BlockIDType


class SetpointTemperatureHeatingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetpointTemperatureHeatingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetpointTemperatureHeatingType.subclass:
            return SetpointTemperatureHeatingType.subclass(*args_, **kwargs_)
        else:
            return SetpointTemperatureHeatingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SetpointTemperatureHeatingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetpointTemperatureHeatingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SetpointTemperatureHeatingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SetpointTemperatureHeatingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SetpointTemperatureHeatingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SetpointTemperatureHeatingType


class SetbackTemperatureHeatingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetbackTemperatureHeatingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetbackTemperatureHeatingType.subclass:
            return SetbackTemperatureHeatingType.subclass(*args_, **kwargs_)
        else:
            return SetbackTemperatureHeatingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SetbackTemperatureHeatingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetbackTemperatureHeatingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SetbackTemperatureHeatingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SetbackTemperatureHeatingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SetbackTemperatureHeatingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SetbackTemperatureHeatingType


class SetpointTemperatureCoolingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetpointTemperatureCoolingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetpointTemperatureCoolingType.subclass:
            return SetpointTemperatureCoolingType.subclass(*args_, **kwargs_)
        else:
            return SetpointTemperatureCoolingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SetpointTemperatureCoolingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetpointTemperatureCoolingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SetpointTemperatureCoolingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SetpointTemperatureCoolingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SetpointTemperatureCoolingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SetpointTemperatureCoolingType


class SetupTemperatureCoolingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetupTemperatureCoolingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetupTemperatureCoolingType.subclass:
            return SetupTemperatureCoolingType.subclass(*args_, **kwargs_)
        else:
            return SetupTemperatureCoolingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SetupTemperatureCoolingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetupTemperatureCoolingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SetupTemperatureCoolingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SetupTemperatureCoolingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SetupTemperatureCoolingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SetupTemperatureCoolingType


class OccupancyScheduleIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OccupancyScheduleIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OccupancyScheduleIDType.subclass:
            return OccupancyScheduleIDType.subclass(*args_, **kwargs_)
        else:
            return OccupancyScheduleIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OccupancyScheduleIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupancyScheduleIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OccupancyScheduleIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OccupancyScheduleIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OccupancyScheduleIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OccupancyScheduleIDType


class DaylightingIlluminanceSetPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DaylightingIlluminanceSetPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DaylightingIlluminanceSetPointType.subclass:
            return DaylightingIlluminanceSetPointType.subclass(*args_, **kwargs_)
        else:
            return DaylightingIlluminanceSetPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DaylightingIlluminanceSetPointType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DaylightingIlluminanceSetPointType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DaylightingIlluminanceSetPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DaylightingIlluminanceSetPointType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DaylightingIlluminanceSetPointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DaylightingIlluminanceSetPointType


class PercentageOfCommonSpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentageOfCommonSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentageOfCommonSpaceType.subclass:
            return PercentageOfCommonSpaceType.subclass(*args_, **kwargs_)
        else:
            return PercentageOfCommonSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentageOfCommonSpaceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentageOfCommonSpaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentageOfCommonSpaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentageOfCommonSpaceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentageOfCommonSpaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentageOfCommonSpaceType


class ConditionedVolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionedVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionedVolumeType.subclass:
            return ConditionedVolumeType.subclass(*args_, **kwargs_)
        else:
            return ConditionedVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConditionedVolumeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConditionedVolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConditionedVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConditionedVolumeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConditionedVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConditionedVolumeType


class ZoneIDType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneIDType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneIDType15.subclass:
            return ZoneIDType15.subclass(*args_, **kwargs_)
        else:
            return ZoneIDType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneIDType15', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneIDType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneIDType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneIDType15'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneIDType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ZoneIDType15


class ScheduleDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DayType=None, ScheduleCategory=None, DayStartTime=None, DayEndTime=None, PartialOperationPercentage=None):
        self.original_tagname_ = None
        self.DayType = DayType
        self.validate_DayTypeType(self.DayType)
        self.ScheduleCategory = ScheduleCategory
        self.validate_ScheduleCategoryType(self.ScheduleCategory)
        if isinstance(DayStartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DayStartTime, '%H:%M:%S').time()
        else:
            initvalue_ = DayStartTime
        self.DayStartTime = initvalue_
        if isinstance(DayEndTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DayEndTime, '%H:%M:%S').time()
        else:
            initvalue_ = DayEndTime
        self.DayEndTime = initvalue_
        self.PartialOperationPercentage = PartialOperationPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScheduleDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScheduleDetailsType.subclass:
            return ScheduleDetailsType.subclass(*args_, **kwargs_)
        else:
            return ScheduleDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DayTypeType(self, value):
        # Validate type DayTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['All week', 'Weekday', 'Weekend', 'Saturday', 'Sunday', 'Holiday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ScheduleCategoryType(self, value):
        # Validate type ScheduleCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Business', 'Occupied', 'Unoccupied', 'Sleeping', 'Public access', 'Setback', 'Operating', 'HVAC equipment', 'Cooling equipment', 'Heating equipment', 'Lighting', 'Cooking equipment', 'Miscellaneous equipment', 'On-peak', 'Off-peak', 'Super off-peak', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ScheduleCategoryType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DayType is not None or
            self.ScheduleCategory is not None or
            self.DayStartTime is not None or
            self.DayEndTime is not None or
            self.PartialOperationPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScheduleDetailsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScheduleDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScheduleDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScheduleDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScheduleDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DayType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDayType>%s</%sDayType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DayType), input_name='DayType')), namespace_, eol_))
        if self.ScheduleCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScheduleCategory>%s</%sScheduleCategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ScheduleCategory), input_name='ScheduleCategory')), namespace_, eol_))
        if self.DayStartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDayStartTime>%s</%sDayStartTime>%s' % (namespace_, self.gds_format_time(self.DayStartTime, input_name='DayStartTime'), namespace_, eol_))
        if self.DayEndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDayEndTime>%s</%sDayEndTime>%s' % (namespace_, self.gds_format_time(self.DayEndTime, input_name='DayEndTime'), namespace_, eol_))
        if self.PartialOperationPercentage is not None:
            self.PartialOperationPercentage.export(outfile, level, namespace_, name_='PartialOperationPercentage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DayType':
            DayType_ = child_.text
            DayType_ = self.gds_validate_string(DayType_, node, 'DayType')
            self.DayType = DayType_
            # validate type DayTypeType
            self.validate_DayTypeType(self.DayType)
        elif nodeName_ == 'ScheduleCategory':
            ScheduleCategory_ = child_.text
            ScheduleCategory_ = self.gds_validate_string(ScheduleCategory_, node, 'ScheduleCategory')
            self.ScheduleCategory = ScheduleCategory_
            # validate type ScheduleCategoryType
            self.validate_ScheduleCategoryType(self.ScheduleCategory)
        elif nodeName_ == 'DayStartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.DayStartTime = dval_
        elif nodeName_ == 'DayEndTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.DayEndTime = dval_
        elif nodeName_ == 'PartialOperationPercentage':
            obj_ = PartialOperationPercentageType.factory()
            obj_.build(child_)
            self.PartialOperationPercentage = obj_
            obj_.original_tagname_ = 'PartialOperationPercentage'
# end class ScheduleDetailsType


class PartialOperationPercentageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartialOperationPercentageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartialOperationPercentageType.subclass:
            return PartialOperationPercentageType.subclass(*args_, **kwargs_)
        else:
            return PartialOperationPercentageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PartialOperationPercentageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialOperationPercentageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PartialOperationPercentageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PartialOperationPercentageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PartialOperationPercentageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartialOperationPercentageType


class ContactTelephoneNumbersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ContactTelephoneNumberLabel=None, ContactTelephoneNumber=None):
        self.original_tagname_ = None
        self.ContactTelephoneNumberLabel = ContactTelephoneNumberLabel
        self.validate_ContactTelephoneNumberLabelType(self.ContactTelephoneNumberLabel)
        self.ContactTelephoneNumber = ContactTelephoneNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactTelephoneNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactTelephoneNumbersType.subclass:
            return ContactTelephoneNumbersType.subclass(*args_, **kwargs_)
        else:
            return ContactTelephoneNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ContactTelephoneNumberLabelType(self, value):
        # Validate type ContactTelephoneNumberLabelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Days', 'Evenings', 'Cell', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ContactTelephoneNumberLabelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ContactTelephoneNumberLabel is not None or
            self.ContactTelephoneNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ContactTelephoneNumbersType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactTelephoneNumbersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ContactTelephoneNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ContactTelephoneNumbersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ContactTelephoneNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactTelephoneNumberLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactTelephoneNumberLabel>%s</%sContactTelephoneNumberLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactTelephoneNumberLabel), input_name='ContactTelephoneNumberLabel')), namespace_, eol_))
        if self.ContactTelephoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactTelephoneNumber>%s</%sContactTelephoneNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactTelephoneNumber), input_name='ContactTelephoneNumber')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactTelephoneNumberLabel':
            ContactTelephoneNumberLabel_ = child_.text
            ContactTelephoneNumberLabel_ = self.gds_validate_string(ContactTelephoneNumberLabel_, node, 'ContactTelephoneNumberLabel')
            self.ContactTelephoneNumberLabel = ContactTelephoneNumberLabel_
            # validate type ContactTelephoneNumberLabelType
            self.validate_ContactTelephoneNumberLabelType(self.ContactTelephoneNumberLabel)
        elif nodeName_ == 'ContactTelephoneNumber':
            ContactTelephoneNumber_ = child_.text
            ContactTelephoneNumber_ = self.gds_validate_string(ContactTelephoneNumber_, node, 'ContactTelephoneNumber')
            self.ContactTelephoneNumber = ContactTelephoneNumber_
# end class ContactTelephoneNumbersType


class ContactEmailAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ContactEmailAddressLabel=None, ContactEmailAddress=None):
        self.original_tagname_ = None
        self.ContactEmailAddressLabel = ContactEmailAddressLabel
        self.validate_ContactEmailAddressLabelType(self.ContactEmailAddressLabel)
        self.ContactEmailAddress = ContactEmailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactEmailAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactEmailAddressesType.subclass:
            return ContactEmailAddressesType.subclass(*args_, **kwargs_)
        else:
            return ContactEmailAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ContactEmailAddressLabelType(self, value):
        # Validate type ContactEmailAddressLabelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Personal', 'Work', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ContactEmailAddressLabelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ContactEmailAddressLabel is not None or
            self.ContactEmailAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ContactEmailAddressesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactEmailAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ContactEmailAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ContactEmailAddressesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ContactEmailAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactEmailAddressLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactEmailAddressLabel>%s</%sContactEmailAddressLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactEmailAddressLabel), input_name='ContactEmailAddressLabel')), namespace_, eol_))
        if self.ContactEmailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactEmailAddress>%s</%sContactEmailAddress>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ContactEmailAddress), input_name='ContactEmailAddress')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactEmailAddressLabel':
            ContactEmailAddressLabel_ = child_.text
            ContactEmailAddressLabel_ = self.gds_validate_string(ContactEmailAddressLabel_, node, 'ContactEmailAddressLabel')
            self.ContactEmailAddressLabel = ContactEmailAddressLabel_
            # validate type ContactEmailAddressLabelType
            self.validate_ContactEmailAddressLabelType(self.ContactEmailAddressLabel)
        elif nodeName_ == 'ContactEmailAddress':
            ContactEmailAddress_ = child_.text
            ContactEmailAddress_ = self.gds_validate_string(ContactEmailAddress_, node, 'ContactEmailAddress')
            self.ContactEmailAddress = ContactEmailAddress_
# end class ContactEmailAddressesType


class ScenarioTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrentBuilding=None, Benchmark=None, Target=None, PackageOfMeasures=None, Other=None):
        self.original_tagname_ = None
        self.CurrentBuilding = CurrentBuilding
        self.Benchmark = Benchmark
        self.Target = Target
        self.PackageOfMeasures = PackageOfMeasures
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScenarioTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScenarioTypeType.subclass:
            return ScenarioTypeType.subclass(*args_, **kwargs_)
        else:
            return ScenarioTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CurrentBuilding is not None or
            self.Benchmark is not None or
            self.Target is not None or
            self.PackageOfMeasures is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScenarioTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScenarioTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScenarioTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScenarioTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScenarioTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrentBuilding is not None:
            self.CurrentBuilding.export(outfile, level, namespace_, name_='CurrentBuilding', pretty_print=pretty_print)
        if self.Benchmark is not None:
            self.Benchmark.export(outfile, level, namespace_, name_='Benchmark', pretty_print=pretty_print)
        if self.Target is not None:
            self.Target.export(outfile, level, namespace_, name_='Target', pretty_print=pretty_print)
        if self.PackageOfMeasures is not None:
            self.PackageOfMeasures.export(outfile, level, namespace_, name_='PackageOfMeasures', pretty_print=pretty_print)
        if self.Other is not None:
            self.Other.export(outfile, level, namespace_, name_='Other', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrentBuilding':
            obj_ = CurrentBuildingType.factory()
            obj_.build(child_)
            self.CurrentBuilding = obj_
            obj_.original_tagname_ = 'CurrentBuilding'
        elif nodeName_ == 'Benchmark':
            obj_ = BenchmarkType16.factory()
            obj_.build(child_)
            self.Benchmark = obj_
            obj_.original_tagname_ = 'Benchmark'
        elif nodeName_ == 'Target':
            obj_ = TargetType.factory()
            obj_.build(child_)
            self.Target = obj_
            obj_.original_tagname_ = 'Target'
        elif nodeName_ == 'PackageOfMeasures':
            obj_ = PackageOfMeasuresType.factory()
            obj_.build(child_)
            self.PackageOfMeasures = obj_
            obj_.original_tagname_ = 'PackageOfMeasures'
        elif nodeName_ == 'Other':
            obj_ = OtherType28.factory()
            obj_.build(child_)
            self.Other = obj_
            obj_.original_tagname_ = 'Other'
# end class ScenarioTypeType


class CurrentBuildingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CalculationMethod=None, AssetScore=None, ENERGYSTARScore=None):
        self.original_tagname_ = None
        self.CalculationMethod = CalculationMethod
        self.AssetScore = AssetScore
        self.ENERGYSTARScore = ENERGYSTARScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrentBuildingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrentBuildingType.subclass:
            return CurrentBuildingType.subclass(*args_, **kwargs_)
        else:
            return CurrentBuildingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CalculationMethod is not None or
            self.AssetScore is not None or
            self.ENERGYSTARScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CurrentBuildingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentBuildingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CurrentBuildingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CurrentBuildingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CurrentBuildingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
        if self.AssetScore is not None:
            self.AssetScore.export(outfile, level, namespace_='auc:', name_='AssetScore', pretty_print=pretty_print)
        if self.ENERGYSTARScore is not None:
            self.ENERGYSTARScore.export(outfile, level, namespace_='auc:', name_='ENERGYSTARScore', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
        elif nodeName_ == 'AssetScore':
            obj_ = AssetScore.factory()
            obj_.build(child_)
            self.AssetScore = obj_
            obj_.original_tagname_ = 'AssetScore'
        elif nodeName_ == 'ENERGYSTARScore':
            obj_ = ENERGYSTARScore.factory()
            obj_.build(child_)
            self.ENERGYSTARScore = obj_
            obj_.original_tagname_ = 'ENERGYSTARScore'
# end class CurrentBuildingType


class BenchmarkType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BenchmarkType=None, BenchmarkTool=None):
        self.original_tagname_ = None
        self.BenchmarkType = BenchmarkType
        self.BenchmarkTool = BenchmarkTool
        self.validate_BenchmarkToolType(self.BenchmarkTool)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BenchmarkType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BenchmarkType16.subclass:
            return BenchmarkType16.subclass(*args_, **kwargs_)
        else:
            return BenchmarkType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BenchmarkToolType(self, value):
        # Validate type BenchmarkToolType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Portfolio Manager', 'Buildings Performance Database Tool', 'EnergyIQ', 'Labs21', 'Fabs21', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BenchmarkToolType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BenchmarkType is not None or
            self.BenchmarkTool is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BenchmarkType16', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BenchmarkType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BenchmarkType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BenchmarkType16'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BenchmarkType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BenchmarkType is not None:
            self.BenchmarkType.export(outfile, level, namespace_, name_='BenchmarkType', pretty_print=pretty_print)
        if self.BenchmarkTool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBenchmarkTool>%s</%sBenchmarkTool>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BenchmarkTool), input_name='BenchmarkTool')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BenchmarkType':
            obj_ = BenchmarkTypeType.factory()
            obj_.build(child_)
            self.BenchmarkType = obj_
            obj_.original_tagname_ = 'BenchmarkType'
        elif nodeName_ == 'BenchmarkTool':
            BenchmarkTool_ = child_.text
            BenchmarkTool_ = self.gds_validate_string(BenchmarkTool_, node, 'BenchmarkTool')
            self.BenchmarkTool = BenchmarkTool_
            # validate type BenchmarkToolType
            self.validate_BenchmarkToolType(self.BenchmarkTool)
# end class BenchmarkType16


class BenchmarkTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PortfolioManager=None, CBECS=None, CodeMinimum=None, StandardPractice=None, Other=None):
        self.original_tagname_ = None
        self.PortfolioManager = PortfolioManager
        self.CBECS = CBECS
        self.CodeMinimum = CodeMinimum
        self.StandardPractice = StandardPractice
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BenchmarkTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BenchmarkTypeType.subclass:
            return BenchmarkTypeType.subclass(*args_, **kwargs_)
        else:
            return BenchmarkTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PortfolioManager is not None or
            self.CBECS is not None or
            self.CodeMinimum is not None or
            self.StandardPractice is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BenchmarkTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BenchmarkTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BenchmarkTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BenchmarkTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BenchmarkTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PortfolioManager is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortfolioManager>%s</%sPortfolioManager>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PortfolioManager), input_name='PortfolioManager')), namespace_, eol_))
        if self.CBECS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCBECS>%s</%sCBECS>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CBECS), input_name='CBECS')), namespace_, eol_))
        if self.CodeMinimum is not None:
            self.CodeMinimum.export(outfile, level, namespace_, name_='CodeMinimum', pretty_print=pretty_print)
        if self.StandardPractice is not None:
            self.StandardPractice.export(outfile, level, namespace_, name_='StandardPractice', pretty_print=pretty_print)
        if self.Other is not None:
            self.Other.export(outfile, level, namespace_, name_='Other', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PortfolioManager':
            PortfolioManager_ = child_.text
            PortfolioManager_ = self.gds_validate_string(PortfolioManager_, node, 'PortfolioManager')
            self.PortfolioManager = PortfolioManager_
        elif nodeName_ == 'CBECS':
            CBECS_ = child_.text
            CBECS_ = self.gds_validate_string(CBECS_, node, 'CBECS')
            self.CBECS = CBECS_
        elif nodeName_ == 'CodeMinimum':
            obj_ = CodeMinimumType.factory()
            obj_.build(child_)
            self.CodeMinimum = obj_
            obj_.original_tagname_ = 'CodeMinimum'
        elif nodeName_ == 'StandardPractice':
            obj_ = StandardPracticeType.factory()
            obj_.build(child_)
            self.StandardPractice = obj_
            obj_.original_tagname_ = 'StandardPractice'
        elif nodeName_ == 'Other':
            obj_ = OtherType17.factory()
            obj_.build(child_)
            self.Other = obj_
            obj_.original_tagname_ = 'Other'
# end class BenchmarkTypeType


class PortfolioManager(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortfolioManager)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortfolioManager.subclass:
            return PortfolioManager.subclass(*args_, **kwargs_)
        else:
            return PortfolioManager(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PortfolioManager', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortfolioManager')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PortfolioManager', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PortfolioManager'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PortfolioManager', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PortfolioManager


class CBECS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CBECS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CBECS.subclass:
            return CBECS.subclass(*args_, **kwargs_)
        else:
            return CBECS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CBECS', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CBECS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CBECS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CBECS'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CBECS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CBECS


class CodeMinimumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CodeName=None, CodeYear=None, CalculationMethod=None):
        self.original_tagname_ = None
        self.CodeName = CodeName
        self.CodeYear = CodeYear
        self.CalculationMethod = CalculationMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeMinimumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeMinimumType.subclass:
            return CodeMinimumType.subclass(*args_, **kwargs_)
        else:
            return CodeMinimumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CodeName is not None or
            self.CodeYear is not None or
            self.CalculationMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CodeMinimumType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeMinimumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CodeMinimumType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CodeMinimumType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CodeMinimumType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CodeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeName>%s</%sCodeName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CodeName), input_name='CodeName')), namespace_, eol_))
        if self.CodeYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeYear>%s</%sCodeYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CodeYear), input_name='CodeYear')), namespace_, eol_))
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodeName':
            CodeName_ = child_.text
            CodeName_ = self.gds_validate_string(CodeName_, node, 'CodeName')
            self.CodeName = CodeName_
        elif nodeName_ == 'CodeYear':
            CodeYear_ = child_.text
            CodeYear_ = self.gds_validate_string(CodeYear_, node, 'CodeYear')
            self.CodeYear = CodeYear_
        elif nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
# end class CodeMinimumType


class StandardPracticeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StandardPracticeDescription=None, CalculationMethod=None):
        self.original_tagname_ = None
        self.StandardPracticeDescription = StandardPracticeDescription
        self.CalculationMethod = CalculationMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StandardPracticeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StandardPracticeType.subclass:
            return StandardPracticeType.subclass(*args_, **kwargs_)
        else:
            return StandardPracticeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.StandardPracticeDescription is not None or
            self.CalculationMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StandardPracticeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StandardPracticeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StandardPracticeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StandardPracticeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StandardPracticeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StandardPracticeDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStandardPracticeDescription>%s</%sStandardPracticeDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StandardPracticeDescription), input_name='StandardPracticeDescription')), namespace_, eol_))
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StandardPracticeDescription':
            StandardPracticeDescription_ = child_.text
            StandardPracticeDescription_ = self.gds_validate_string(StandardPracticeDescription_, node, 'StandardPracticeDescription')
            self.StandardPracticeDescription = StandardPracticeDescription_
        elif nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
# end class StandardPracticeType


class OtherType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OtherBenchmarkDescription=None, CalculationMethod=None):
        self.original_tagname_ = None
        self.OtherBenchmarkDescription = OtherBenchmarkDescription
        self.CalculationMethod = CalculationMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherType17.subclass:
            return OtherType17.subclass(*args_, **kwargs_)
        else:
            return OtherType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.OtherBenchmarkDescription is not None or
            self.CalculationMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherType17', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherType17'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherBenchmarkDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherBenchmarkDescription>%s</%sOtherBenchmarkDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherBenchmarkDescription), input_name='OtherBenchmarkDescription')), namespace_, eol_))
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherBenchmarkDescription':
            OtherBenchmarkDescription_ = child_.text
            OtherBenchmarkDescription_ = self.gds_validate_string(OtherBenchmarkDescription_, node, 'OtherBenchmarkDescription')
            self.OtherBenchmarkDescription = OtherBenchmarkDescription_
        elif nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
# end class OtherType17


class TargetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceCase=None, AnnualSavingsSiteEnergy=None, AnnualSavingsSourceEnergy=None, AnnualSavingsCost=None, SummerPeakElectricityReduction=None, WinterPeakElectricityReduction=None, AnnualWaterSavings=None, AnnualWaterCostSavings=None, SimplePayback=None, NetPresentValue=None, InternalRateOfReturn=None, AssetScore=None, ENERGYSTARScore=None):
        self.original_tagname_ = None
        self.ReferenceCase = ReferenceCase
        self.AnnualSavingsSiteEnergy = AnnualSavingsSiteEnergy
        self.AnnualSavingsSourceEnergy = AnnualSavingsSourceEnergy
        self.AnnualSavingsCost = AnnualSavingsCost
        self.SummerPeakElectricityReduction = SummerPeakElectricityReduction
        self.WinterPeakElectricityReduction = WinterPeakElectricityReduction
        self.AnnualWaterSavings = AnnualWaterSavings
        self.AnnualWaterCostSavings = AnnualWaterCostSavings
        self.SimplePayback = SimplePayback
        self.NetPresentValue = NetPresentValue
        self.InternalRateOfReturn = InternalRateOfReturn
        self.AssetScore = AssetScore
        self.ENERGYSTARScore = ENERGYSTARScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetType.subclass:
            return TargetType.subclass(*args_, **kwargs_)
        else:
            return TargetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ReferenceCase is not None or
            self.AnnualSavingsSiteEnergy is not None or
            self.AnnualSavingsSourceEnergy is not None or
            self.AnnualSavingsCost is not None or
            self.SummerPeakElectricityReduction is not None or
            self.WinterPeakElectricityReduction is not None or
            self.AnnualWaterSavings is not None or
            self.AnnualWaterCostSavings is not None or
            self.SimplePayback is not None or
            self.NetPresentValue is not None or
            self.InternalRateOfReturn is not None or
            self.AssetScore is not None or
            self.ENERGYSTARScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TargetType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TargetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TargetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TargetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceCase is not None:
            self.ReferenceCase.export(outfile, level, namespace_='auc:', name_='ReferenceCase', pretty_print=pretty_print)
        if self.AnnualSavingsSiteEnergy is not None:
            self.AnnualSavingsSiteEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSiteEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsSourceEnergy is not None:
            self.AnnualSavingsSourceEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSourceEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsCost is not None:
            self.AnnualSavingsCost.export(outfile, level, namespace_, name_='AnnualSavingsCost', pretty_print=pretty_print)
        if self.SummerPeakElectricityReduction is not None:
            self.SummerPeakElectricityReduction.export(outfile, level, namespace_, name_='SummerPeakElectricityReduction', pretty_print=pretty_print)
        if self.WinterPeakElectricityReduction is not None:
            self.WinterPeakElectricityReduction.export(outfile, level, namespace_, name_='WinterPeakElectricityReduction', pretty_print=pretty_print)
        if self.AnnualWaterSavings is not None:
            self.AnnualWaterSavings.export(outfile, level, namespace_, name_='AnnualWaterSavings', pretty_print=pretty_print)
        if self.AnnualWaterCostSavings is not None:
            self.AnnualWaterCostSavings.export(outfile, level, namespace_, name_='AnnualWaterCostSavings', pretty_print=pretty_print)
        if self.SimplePayback is not None:
            self.SimplePayback.export(outfile, level, namespace_, name_='SimplePayback', pretty_print=pretty_print)
        if self.NetPresentValue is not None:
            self.NetPresentValue.export(outfile, level, namespace_, name_='NetPresentValue', pretty_print=pretty_print)
        if self.InternalRateOfReturn is not None:
            self.InternalRateOfReturn.export(outfile, level, namespace_, name_='InternalRateOfReturn', pretty_print=pretty_print)
        if self.AssetScore is not None:
            self.AssetScore.export(outfile, level, namespace_='auc:', name_='AssetScore', pretty_print=pretty_print)
        if self.ENERGYSTARScore is not None:
            self.ENERGYSTARScore.export(outfile, level, namespace_='auc:', name_='ENERGYSTARScore', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceCase':
            obj_ = ReferenceCase.factory()
            obj_.build(child_)
            self.ReferenceCase = obj_
            obj_.original_tagname_ = 'ReferenceCase'
        elif nodeName_ == 'AnnualSavingsSiteEnergy':
            obj_ = AnnualSavingsSiteEnergyType.factory()
            obj_.build(child_)
            self.AnnualSavingsSiteEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSiteEnergy'
        elif nodeName_ == 'AnnualSavingsSourceEnergy':
            obj_ = AnnualSavingsSourceEnergyType.factory()
            obj_.build(child_)
            self.AnnualSavingsSourceEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSourceEnergy'
        elif nodeName_ == 'AnnualSavingsCost':
            obj_ = AnnualSavingsCostType.factory()
            obj_.build(child_)
            self.AnnualSavingsCost = obj_
            obj_.original_tagname_ = 'AnnualSavingsCost'
        elif nodeName_ == 'SummerPeakElectricityReduction':
            obj_ = SummerPeakElectricityReductionType.factory()
            obj_.build(child_)
            self.SummerPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'SummerPeakElectricityReduction'
        elif nodeName_ == 'WinterPeakElectricityReduction':
            obj_ = WinterPeakElectricityReductionType.factory()
            obj_.build(child_)
            self.WinterPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'WinterPeakElectricityReduction'
        elif nodeName_ == 'AnnualWaterSavings':
            obj_ = AnnualWaterSavingsType.factory()
            obj_.build(child_)
            self.AnnualWaterSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterSavings'
        elif nodeName_ == 'AnnualWaterCostSavings':
            obj_ = AnnualWaterCostSavingsType.factory()
            obj_.build(child_)
            self.AnnualWaterCostSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterCostSavings'
        elif nodeName_ == 'SimplePayback':
            obj_ = SimplePaybackType.factory()
            obj_.build(child_)
            self.SimplePayback = obj_
            obj_.original_tagname_ = 'SimplePayback'
        elif nodeName_ == 'NetPresentValue':
            obj_ = NetPresentValueType.factory()
            obj_.build(child_)
            self.NetPresentValue = obj_
            obj_.original_tagname_ = 'NetPresentValue'
        elif nodeName_ == 'InternalRateOfReturn':
            obj_ = InternalRateOfReturnType.factory()
            obj_.build(child_)
            self.InternalRateOfReturn = obj_
            obj_.original_tagname_ = 'InternalRateOfReturn'
        elif nodeName_ == 'AssetScore':
            obj_ = AssetScore.factory()
            obj_.build(child_)
            self.AssetScore = obj_
            obj_.original_tagname_ = 'AssetScore'
        elif nodeName_ == 'ENERGYSTARScore':
            obj_ = ENERGYSTARScore.factory()
            obj_.build(child_)
            self.ENERGYSTARScore = obj_
            obj_.original_tagname_ = 'ENERGYSTARScore'
# end class TargetType


class AnnualSavingsSiteEnergyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSiteEnergyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSiteEnergyType.subclass:
            return AnnualSavingsSiteEnergyType.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSiteEnergyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSiteEnergyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSiteEnergyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSiteEnergyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSiteEnergyType


class AnnualSavingsSourceEnergyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSourceEnergyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSourceEnergyType.subclass:
            return AnnualSavingsSourceEnergyType.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSourceEnergyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSourceEnergyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSourceEnergyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSourceEnergyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSourceEnergyType


class AnnualSavingsCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsCostType.subclass:
            return AnnualSavingsCostType.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsCostType


class SummerPeakElectricityReductionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummerPeakElectricityReductionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummerPeakElectricityReductionType.subclass:
            return SummerPeakElectricityReductionType.subclass(*args_, **kwargs_)
        else:
            return SummerPeakElectricityReductionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SummerPeakElectricityReductionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SummerPeakElectricityReductionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SummerPeakElectricityReductionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SummerPeakElectricityReductionType


class WinterPeakElectricityReductionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WinterPeakElectricityReductionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WinterPeakElectricityReductionType.subclass:
            return WinterPeakElectricityReductionType.subclass(*args_, **kwargs_)
        else:
            return WinterPeakElectricityReductionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WinterPeakElectricityReductionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WinterPeakElectricityReductionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WinterPeakElectricityReductionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WinterPeakElectricityReductionType


class AnnualWaterSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterSavingsType.subclass:
            return AnnualWaterSavingsType.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterSavingsType


class AnnualWaterCostSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterCostSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterCostSavingsType.subclass:
            return AnnualWaterCostSavingsType.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterCostSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterCostSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterCostSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterCostSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterCostSavingsType


class SimplePaybackType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePaybackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePaybackType.subclass:
            return SimplePaybackType.subclass(*args_, **kwargs_)
        else:
            return SimplePaybackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimplePaybackType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePaybackType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimplePaybackType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimplePaybackType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimplePaybackType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SimplePaybackType


class NetPresentValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetPresentValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetPresentValueType.subclass:
            return NetPresentValueType.subclass(*args_, **kwargs_)
        else:
            return NetPresentValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetPresentValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetPresentValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetPresentValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetPresentValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetPresentValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetPresentValueType


class InternalRateOfReturnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternalRateOfReturnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternalRateOfReturnType.subclass:
            return InternalRateOfReturnType.subclass(*args_, **kwargs_)
        else:
            return InternalRateOfReturnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternalRateOfReturnType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InternalRateOfReturnType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InternalRateOfReturnType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InternalRateOfReturnType


class PackageOfMeasuresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceCase=None, MeasuresID=None, CalculationMethod=None, AnnualSavingsSiteEnergy=None, AnnualSavingsSourceEnergy=None, AnnualSavingsCost=None, AnnualSavingsByFuel=None, SummerPeakElectricityReduction=None, WinterPeakElectricityReduction=None, AnnualWaterSavings=None, AnnualWaterCostSavings=None, ImplementationPeriod=None, PackageFirstCost=None, MVCost=None, OMCostAnnualSavings=None, EquipmentDisposalAndSalvageCosts=None, ImplementationPeriodCostSavings=None, PercentGuaranteedSavings=None, ProjectMarkup=None, FundingFromIncentives=None, FundingFromTaxCredits=None, OtherFinancialIncentives=None, RecurringIncentives=None, NPVofTaxImplications=None, CostEffectivenessScreeningMethod=None, SimplePayback=None, NetPresentValue=None, InternalRateOfReturn=None, AssetScore=None, ENERGYSTARScore=None):
        self.original_tagname_ = None
        self.ReferenceCase = ReferenceCase
        if MeasuresID is None:
            self.MeasuresID = []
        else:
            self.MeasuresID = MeasuresID
        self.CalculationMethod = CalculationMethod
        self.AnnualSavingsSiteEnergy = AnnualSavingsSiteEnergy
        self.AnnualSavingsSourceEnergy = AnnualSavingsSourceEnergy
        self.AnnualSavingsCost = AnnualSavingsCost
        if AnnualSavingsByFuel is None:
            self.AnnualSavingsByFuel = []
        else:
            self.AnnualSavingsByFuel = AnnualSavingsByFuel
        self.SummerPeakElectricityReduction = SummerPeakElectricityReduction
        self.WinterPeakElectricityReduction = WinterPeakElectricityReduction
        self.AnnualWaterSavings = AnnualWaterSavings
        self.AnnualWaterCostSavings = AnnualWaterCostSavings
        self.ImplementationPeriod = ImplementationPeriod
        self.PackageFirstCost = PackageFirstCost
        self.MVCost = MVCost
        self.OMCostAnnualSavings = OMCostAnnualSavings
        self.EquipmentDisposalAndSalvageCosts = EquipmentDisposalAndSalvageCosts
        self.ImplementationPeriodCostSavings = ImplementationPeriodCostSavings
        self.PercentGuaranteedSavings = PercentGuaranteedSavings
        self.ProjectMarkup = ProjectMarkup
        self.FundingFromIncentives = FundingFromIncentives
        self.FundingFromTaxCredits = FundingFromTaxCredits
        self.OtherFinancialIncentives = OtherFinancialIncentives
        self.RecurringIncentives = RecurringIncentives
        self.NPVofTaxImplications = NPVofTaxImplications
        self.CostEffectivenessScreeningMethod = CostEffectivenessScreeningMethod
        self.validate_CostEffectivenessScreeningMethod(self.CostEffectivenessScreeningMethod)
        self.SimplePayback = SimplePayback
        self.NetPresentValue = NetPresentValue
        self.InternalRateOfReturn = InternalRateOfReturn
        self.AssetScore = AssetScore
        self.ENERGYSTARScore = ENERGYSTARScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageOfMeasuresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageOfMeasuresType.subclass:
            return PackageOfMeasuresType.subclass(*args_, **kwargs_)
        else:
            return PackageOfMeasuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CostEffectivenessScreeningMethod(self, value):
        # Validate type CostEffectivenessScreeningMethod, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ReferenceCase is not None or
            self.MeasuresID or
            self.CalculationMethod is not None or
            self.AnnualSavingsSiteEnergy is not None or
            self.AnnualSavingsSourceEnergy is not None or
            self.AnnualSavingsCost is not None or
            self.AnnualSavingsByFuel or
            self.SummerPeakElectricityReduction is not None or
            self.WinterPeakElectricityReduction is not None or
            self.AnnualWaterSavings is not None or
            self.AnnualWaterCostSavings is not None or
            self.ImplementationPeriod is not None or
            self.PackageFirstCost is not None or
            self.MVCost is not None or
            self.OMCostAnnualSavings is not None or
            self.EquipmentDisposalAndSalvageCosts is not None or
            self.ImplementationPeriodCostSavings is not None or
            self.PercentGuaranteedSavings is not None or
            self.ProjectMarkup is not None or
            self.FundingFromIncentives is not None or
            self.FundingFromTaxCredits is not None or
            self.OtherFinancialIncentives is not None or
            self.RecurringIncentives is not None or
            self.NPVofTaxImplications is not None or
            self.CostEffectivenessScreeningMethod is not None or
            self.SimplePayback is not None or
            self.NetPresentValue is not None or
            self.InternalRateOfReturn is not None or
            self.AssetScore is not None or
            self.ENERGYSTARScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PackageOfMeasuresType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageOfMeasuresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PackageOfMeasuresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PackageOfMeasuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PackageOfMeasuresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceCase is not None:
            self.ReferenceCase.export(outfile, level, namespace_='auc:', name_='ReferenceCase', pretty_print=pretty_print)
        for MeasuresID_ in self.MeasuresID:
            MeasuresID_.export(outfile, level, namespace_, name_='MeasuresID', pretty_print=pretty_print)
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
        if self.AnnualSavingsSiteEnergy is not None:
            self.AnnualSavingsSiteEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSiteEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsSourceEnergy is not None:
            self.AnnualSavingsSourceEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSourceEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsCost is not None:
            self.AnnualSavingsCost.export(outfile, level, namespace_, name_='AnnualSavingsCost', pretty_print=pretty_print)
        for AnnualSavingsByFuel_ in self.AnnualSavingsByFuel:
            AnnualSavingsByFuel_.export(outfile, level, namespace_, name_='AnnualSavingsByFuel', pretty_print=pretty_print)
        if self.SummerPeakElectricityReduction is not None:
            self.SummerPeakElectricityReduction.export(outfile, level, namespace_, name_='SummerPeakElectricityReduction', pretty_print=pretty_print)
        if self.WinterPeakElectricityReduction is not None:
            self.WinterPeakElectricityReduction.export(outfile, level, namespace_, name_='WinterPeakElectricityReduction', pretty_print=pretty_print)
        if self.AnnualWaterSavings is not None:
            self.AnnualWaterSavings.export(outfile, level, namespace_, name_='AnnualWaterSavings', pretty_print=pretty_print)
        if self.AnnualWaterCostSavings is not None:
            self.AnnualWaterCostSavings.export(outfile, level, namespace_, name_='AnnualWaterCostSavings', pretty_print=pretty_print)
        if self.ImplementationPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImplementationPeriod>%s</%sImplementationPeriod>%s' % (namespace_, self.gds_format_integer(self.ImplementationPeriod, input_name='ImplementationPeriod'), namespace_, eol_))
        if self.PackageFirstCost is not None:
            self.PackageFirstCost.export(outfile, level, namespace_, name_='PackageFirstCost', pretty_print=pretty_print)
        if self.MVCost is not None:
            self.MVCost.export(outfile, level, namespace_, name_='MVCost', pretty_print=pretty_print)
        if self.OMCostAnnualSavings is not None:
            self.OMCostAnnualSavings.export(outfile, level, namespace_, name_='OMCostAnnualSavings', pretty_print=pretty_print)
        if self.EquipmentDisposalAndSalvageCosts is not None:
            self.EquipmentDisposalAndSalvageCosts.export(outfile, level, namespace_, name_='EquipmentDisposalAndSalvageCosts', pretty_print=pretty_print)
        if self.ImplementationPeriodCostSavings is not None:
            self.ImplementationPeriodCostSavings.export(outfile, level, namespace_, name_='ImplementationPeriodCostSavings', pretty_print=pretty_print)
        if self.PercentGuaranteedSavings is not None:
            self.PercentGuaranteedSavings.export(outfile, level, namespace_, name_='PercentGuaranteedSavings', pretty_print=pretty_print)
        if self.ProjectMarkup is not None:
            self.ProjectMarkup.export(outfile, level, namespace_, name_='ProjectMarkup', pretty_print=pretty_print)
        if self.FundingFromIncentives is not None:
            self.FundingFromIncentives.export(outfile, level, namespace_, name_='FundingFromIncentives', pretty_print=pretty_print)
        if self.FundingFromTaxCredits is not None:
            self.FundingFromTaxCredits.export(outfile, level, namespace_, name_='FundingFromTaxCredits', pretty_print=pretty_print)
        if self.OtherFinancialIncentives is not None:
            self.OtherFinancialIncentives.export(outfile, level, namespace_, name_='OtherFinancialIncentives', pretty_print=pretty_print)
        if self.RecurringIncentives is not None:
            self.RecurringIncentives.export(outfile, level, namespace_, name_='RecurringIncentives', pretty_print=pretty_print)
        if self.NPVofTaxImplications is not None:
            self.NPVofTaxImplications.export(outfile, level, namespace_, name_='NPVofTaxImplications', pretty_print=pretty_print)
        if self.CostEffectivenessScreeningMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCostEffectivenessScreeningMethod>%s</%sCostEffectivenessScreeningMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CostEffectivenessScreeningMethod), input_name='CostEffectivenessScreeningMethod')), namespace_, eol_))
        if self.SimplePayback is not None:
            self.SimplePayback.export(outfile, level, namespace_, name_='SimplePayback', pretty_print=pretty_print)
        if self.NetPresentValue is not None:
            self.NetPresentValue.export(outfile, level, namespace_, name_='NetPresentValue', pretty_print=pretty_print)
        if self.InternalRateOfReturn is not None:
            self.InternalRateOfReturn.export(outfile, level, namespace_, name_='InternalRateOfReturn', pretty_print=pretty_print)
        if self.AssetScore is not None:
            self.AssetScore.export(outfile, level, namespace_='auc:', name_='AssetScore', pretty_print=pretty_print)
        if self.ENERGYSTARScore is not None:
            self.ENERGYSTARScore.export(outfile, level, namespace_='auc:', name_='ENERGYSTARScore', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceCase':
            obj_ = ReferenceCase.factory()
            obj_.build(child_)
            self.ReferenceCase = obj_
            obj_.original_tagname_ = 'ReferenceCase'
        elif nodeName_ == 'MeasuresID':
            obj_ = MeasuresIDType.factory()
            obj_.build(child_)
            self.MeasuresID.append(obj_)
            obj_.original_tagname_ = 'MeasuresID'
        elif nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
        elif nodeName_ == 'AnnualSavingsSiteEnergy':
            obj_ = AnnualSavingsSiteEnergyType18.factory()
            obj_.build(child_)
            self.AnnualSavingsSiteEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSiteEnergy'
        elif nodeName_ == 'AnnualSavingsSourceEnergy':
            obj_ = AnnualSavingsSourceEnergyType19.factory()
            obj_.build(child_)
            self.AnnualSavingsSourceEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSourceEnergy'
        elif nodeName_ == 'AnnualSavingsCost':
            obj_ = AnnualSavingsCostType20.factory()
            obj_.build(child_)
            self.AnnualSavingsCost = obj_
            obj_.original_tagname_ = 'AnnualSavingsCost'
        elif nodeName_ == 'AnnualSavingsByFuel':
            obj_ = AnnualSavingsByFuelType.factory()
            obj_.build(child_)
            self.AnnualSavingsByFuel.append(obj_)
            obj_.original_tagname_ = 'AnnualSavingsByFuel'
        elif nodeName_ == 'SummerPeakElectricityReduction':
            obj_ = SummerPeakElectricityReductionType21.factory()
            obj_.build(child_)
            self.SummerPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'SummerPeakElectricityReduction'
        elif nodeName_ == 'WinterPeakElectricityReduction':
            obj_ = WinterPeakElectricityReductionType22.factory()
            obj_.build(child_)
            self.WinterPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'WinterPeakElectricityReduction'
        elif nodeName_ == 'AnnualWaterSavings':
            obj_ = AnnualWaterSavingsType23.factory()
            obj_.build(child_)
            self.AnnualWaterSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterSavings'
        elif nodeName_ == 'AnnualWaterCostSavings':
            obj_ = AnnualWaterCostSavingsType24.factory()
            obj_.build(child_)
            self.AnnualWaterCostSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterCostSavings'
        elif nodeName_ == 'ImplementationPeriod':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ImplementationPeriod')
            self.ImplementationPeriod = ival_
        elif nodeName_ == 'PackageFirstCost':
            obj_ = PackageFirstCostType.factory()
            obj_.build(child_)
            self.PackageFirstCost = obj_
            obj_.original_tagname_ = 'PackageFirstCost'
        elif nodeName_ == 'MVCost':
            obj_ = MVCostType.factory()
            obj_.build(child_)
            self.MVCost = obj_
            obj_.original_tagname_ = 'MVCost'
        elif nodeName_ == 'OMCostAnnualSavings':
            obj_ = OMCostAnnualSavingsType.factory()
            obj_.build(child_)
            self.OMCostAnnualSavings = obj_
            obj_.original_tagname_ = 'OMCostAnnualSavings'
        elif nodeName_ == 'EquipmentDisposalAndSalvageCosts':
            obj_ = EquipmentDisposalAndSalvageCostsType.factory()
            obj_.build(child_)
            self.EquipmentDisposalAndSalvageCosts = obj_
            obj_.original_tagname_ = 'EquipmentDisposalAndSalvageCosts'
        elif nodeName_ == 'ImplementationPeriodCostSavings':
            obj_ = ImplementationPeriodCostSavingsType.factory()
            obj_.build(child_)
            self.ImplementationPeriodCostSavings = obj_
            obj_.original_tagname_ = 'ImplementationPeriodCostSavings'
        elif nodeName_ == 'PercentGuaranteedSavings':
            obj_ = PercentGuaranteedSavingsType.factory()
            obj_.build(child_)
            self.PercentGuaranteedSavings = obj_
            obj_.original_tagname_ = 'PercentGuaranteedSavings'
        elif nodeName_ == 'ProjectMarkup':
            obj_ = ProjectMarkupType.factory()
            obj_.build(child_)
            self.ProjectMarkup = obj_
            obj_.original_tagname_ = 'ProjectMarkup'
        elif nodeName_ == 'FundingFromIncentives':
            obj_ = FundingFromIncentivesType.factory()
            obj_.build(child_)
            self.FundingFromIncentives = obj_
            obj_.original_tagname_ = 'FundingFromIncentives'
        elif nodeName_ == 'FundingFromTaxCredits':
            obj_ = FundingFromTaxCreditsType.factory()
            obj_.build(child_)
            self.FundingFromTaxCredits = obj_
            obj_.original_tagname_ = 'FundingFromTaxCredits'
        elif nodeName_ == 'OtherFinancialIncentives':
            obj_ = OtherFinancialIncentivesType.factory()
            obj_.build(child_)
            self.OtherFinancialIncentives = obj_
            obj_.original_tagname_ = 'OtherFinancialIncentives'
        elif nodeName_ == 'RecurringIncentives':
            obj_ = RecurringIncentivesType.factory()
            obj_.build(child_)
            self.RecurringIncentives = obj_
            obj_.original_tagname_ = 'RecurringIncentives'
        elif nodeName_ == 'NPVofTaxImplications':
            obj_ = NPVofTaxImplicationsType.factory()
            obj_.build(child_)
            self.NPVofTaxImplications = obj_
            obj_.original_tagname_ = 'NPVofTaxImplications'
        elif nodeName_ == 'CostEffectivenessScreeningMethod':
            CostEffectivenessScreeningMethod_ = child_.text
            CostEffectivenessScreeningMethod_ = self.gds_validate_string(CostEffectivenessScreeningMethod_, node, 'CostEffectivenessScreeningMethod')
            self.CostEffectivenessScreeningMethod = CostEffectivenessScreeningMethod_
            # validate type CostEffectivenessScreeningMethod
            self.validate_CostEffectivenessScreeningMethod(self.CostEffectivenessScreeningMethod)
        elif nodeName_ == 'SimplePayback':
            obj_ = SimplePaybackType25.factory()
            obj_.build(child_)
            self.SimplePayback = obj_
            obj_.original_tagname_ = 'SimplePayback'
        elif nodeName_ == 'NetPresentValue':
            obj_ = NetPresentValueType26.factory()
            obj_.build(child_)
            self.NetPresentValue = obj_
            obj_.original_tagname_ = 'NetPresentValue'
        elif nodeName_ == 'InternalRateOfReturn':
            obj_ = InternalRateOfReturnType27.factory()
            obj_.build(child_)
            self.InternalRateOfReturn = obj_
            obj_.original_tagname_ = 'InternalRateOfReturn'
        elif nodeName_ == 'AssetScore':
            obj_ = AssetScore.factory()
            obj_.build(child_)
            self.AssetScore = obj_
            obj_.original_tagname_ = 'AssetScore'
        elif nodeName_ == 'ENERGYSTARScore':
            obj_ = ENERGYSTARScore.factory()
            obj_.build(child_)
            self.ENERGYSTARScore = obj_
            obj_.original_tagname_ = 'ENERGYSTARScore'
# end class PackageOfMeasuresType


class MeasuresIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuresIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuresIDType.subclass:
            return MeasuresIDType.subclass(*args_, **kwargs_)
        else:
            return MeasuresIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasuresIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasuresIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasuresIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasuresIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasuresIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasuresIDType


class AnnualSavingsSiteEnergyType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSiteEnergyType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSiteEnergyType18.subclass:
            return AnnualSavingsSiteEnergyType18.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSiteEnergyType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType18', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSiteEnergyType18')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSiteEnergyType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSiteEnergyType18'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSiteEnergyType18


class AnnualSavingsSourceEnergyType19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSourceEnergyType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSourceEnergyType19.subclass:
            return AnnualSavingsSourceEnergyType19.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSourceEnergyType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType19', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSourceEnergyType19')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSourceEnergyType19', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSourceEnergyType19'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType19', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSourceEnergyType19


class AnnualSavingsCostType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsCostType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsCostType20.subclass:
            return AnnualSavingsCostType20.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsCostType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType20', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsCostType20')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsCostType20', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsCostType20'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType20', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsCostType20


class AnnualSavingsByFuelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyResource=None, ResourceUnits=None, AnnualSavingsNativeUnits=None):
        self.original_tagname_ = None
        self.EnergyResource = EnergyResource
        self.validate_EnergyResource(self.EnergyResource)
        self.ResourceUnits = ResourceUnits
        self.validate_ResourceUnits(self.ResourceUnits)
        self.AnnualSavingsNativeUnits = AnnualSavingsNativeUnits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsByFuelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsByFuelType.subclass:
            return AnnualSavingsByFuelType.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsByFuelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnergyResource(self, value):
        # Validate type EnergyResource, a restriction on xs:string.
        pass
    def validate_ResourceUnits(self, value):
        # Validate type ResourceUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.EnergyResource is not None or
            self.ResourceUnits is not None or
            self.AnnualSavingsNativeUnits is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsByFuelType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsByFuelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsByFuelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsByFuelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsByFuelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyResource>%s</%sEnergyResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyResource), input_name='EnergyResource')), namespace_, eol_))
        if self.ResourceUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceUnits>%s</%sResourceUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ResourceUnits), input_name='ResourceUnits')), namespace_, eol_))
        if self.AnnualSavingsNativeUnits is not None:
            self.AnnualSavingsNativeUnits.export(outfile, level, namespace_, name_='AnnualSavingsNativeUnits', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyResource':
            EnergyResource_ = child_.text
            EnergyResource_ = self.gds_validate_string(EnergyResource_, node, 'EnergyResource')
            self.EnergyResource = EnergyResource_
            # validate type EnergyResource
            self.validate_EnergyResource(self.EnergyResource)
        elif nodeName_ == 'ResourceUnits':
            ResourceUnits_ = child_.text
            ResourceUnits_ = self.gds_validate_string(ResourceUnits_, node, 'ResourceUnits')
            self.ResourceUnits = ResourceUnits_
            # validate type ResourceUnits
            self.validate_ResourceUnits(self.ResourceUnits)
        elif nodeName_ == 'AnnualSavingsNativeUnits':
            obj_ = AnnualSavingsNativeUnitsType.factory()
            obj_.build(child_)
            self.AnnualSavingsNativeUnits = obj_
            obj_.original_tagname_ = 'AnnualSavingsNativeUnits'
# end class AnnualSavingsByFuelType


class AnnualSavingsNativeUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsNativeUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsNativeUnitsType.subclass:
            return AnnualSavingsNativeUnitsType.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsNativeUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsNativeUnitsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsNativeUnitsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsNativeUnitsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsNativeUnitsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsNativeUnitsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsNativeUnitsType


class SummerPeakElectricityReductionType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummerPeakElectricityReductionType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummerPeakElectricityReductionType21.subclass:
            return SummerPeakElectricityReductionType21.subclass(*args_, **kwargs_)
        else:
            return SummerPeakElectricityReductionType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType21', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SummerPeakElectricityReductionType21')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SummerPeakElectricityReductionType21', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SummerPeakElectricityReductionType21'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType21', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SummerPeakElectricityReductionType21


class WinterPeakElectricityReductionType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WinterPeakElectricityReductionType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WinterPeakElectricityReductionType22.subclass:
            return WinterPeakElectricityReductionType22.subclass(*args_, **kwargs_)
        else:
            return WinterPeakElectricityReductionType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType22', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WinterPeakElectricityReductionType22')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WinterPeakElectricityReductionType22', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WinterPeakElectricityReductionType22'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType22', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WinterPeakElectricityReductionType22


class AnnualWaterSavingsType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterSavingsType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterSavingsType23.subclass:
            return AnnualWaterSavingsType23.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterSavingsType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType23', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterSavingsType23')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterSavingsType23', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterSavingsType23'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType23', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterSavingsType23


class AnnualWaterCostSavingsType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterCostSavingsType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterCostSavingsType24.subclass:
            return AnnualWaterCostSavingsType24.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterCostSavingsType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType24', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterCostSavingsType24')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterCostSavingsType24', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterCostSavingsType24'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType24', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterCostSavingsType24


class PackageFirstCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageFirstCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageFirstCostType.subclass:
            return PackageFirstCostType.subclass(*args_, **kwargs_)
        else:
            return PackageFirstCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PackageFirstCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageFirstCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PackageFirstCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PackageFirstCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PackageFirstCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PackageFirstCostType


class MVCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MVCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MVCostType.subclass:
            return MVCostType.subclass(*args_, **kwargs_)
        else:
            return MVCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MVCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MVCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MVCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MVCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MVCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MVCostType


class OMCostAnnualSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OMCostAnnualSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OMCostAnnualSavingsType.subclass:
            return OMCostAnnualSavingsType.subclass(*args_, **kwargs_)
        else:
            return OMCostAnnualSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OMCostAnnualSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OMCostAnnualSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OMCostAnnualSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OMCostAnnualSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OMCostAnnualSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OMCostAnnualSavingsType


class EquipmentDisposalAndSalvageCostsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquipmentDisposalAndSalvageCostsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquipmentDisposalAndSalvageCostsType.subclass:
            return EquipmentDisposalAndSalvageCostsType.subclass(*args_, **kwargs_)
        else:
            return EquipmentDisposalAndSalvageCostsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquipmentDisposalAndSalvageCostsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EquipmentDisposalAndSalvageCostsType


class ImplementationPeriodCostSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImplementationPeriodCostSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImplementationPeriodCostSavingsType.subclass:
            return ImplementationPeriodCostSavingsType.subclass(*args_, **kwargs_)
        else:
            return ImplementationPeriodCostSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ImplementationPeriodCostSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImplementationPeriodCostSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ImplementationPeriodCostSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ImplementationPeriodCostSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ImplementationPeriodCostSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ImplementationPeriodCostSavingsType


class PercentGuaranteedSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentGuaranteedSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentGuaranteedSavingsType.subclass:
            return PercentGuaranteedSavingsType.subclass(*args_, **kwargs_)
        else:
            return PercentGuaranteedSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentGuaranteedSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentGuaranteedSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentGuaranteedSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentGuaranteedSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentGuaranteedSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentGuaranteedSavingsType


class ProjectMarkupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectMarkupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectMarkupType.subclass:
            return ProjectMarkupType.subclass(*args_, **kwargs_)
        else:
            return ProjectMarkupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ProjectMarkupType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectMarkupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ProjectMarkupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ProjectMarkupType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ProjectMarkupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProjectMarkupType


class FundingFromIncentivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FundingFromIncentivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FundingFromIncentivesType.subclass:
            return FundingFromIncentivesType.subclass(*args_, **kwargs_)
        else:
            return FundingFromIncentivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FundingFromIncentivesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FundingFromIncentivesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FundingFromIncentivesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FundingFromIncentivesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FundingFromIncentivesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FundingFromIncentivesType


class FundingFromTaxCreditsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FundingFromTaxCreditsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FundingFromTaxCreditsType.subclass:
            return FundingFromTaxCreditsType.subclass(*args_, **kwargs_)
        else:
            return FundingFromTaxCreditsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FundingFromTaxCreditsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FundingFromTaxCreditsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FundingFromTaxCreditsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FundingFromTaxCreditsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FundingFromTaxCreditsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FundingFromTaxCreditsType


class OtherFinancialIncentivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherFinancialIncentivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherFinancialIncentivesType.subclass:
            return OtherFinancialIncentivesType.subclass(*args_, **kwargs_)
        else:
            return OtherFinancialIncentivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherFinancialIncentivesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherFinancialIncentivesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherFinancialIncentivesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherFinancialIncentivesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherFinancialIncentivesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OtherFinancialIncentivesType


class RecurringIncentivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecurringIncentivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecurringIncentivesType.subclass:
            return RecurringIncentivesType.subclass(*args_, **kwargs_)
        else:
            return RecurringIncentivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecurringIncentivesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecurringIncentivesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecurringIncentivesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecurringIncentivesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecurringIncentivesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecurringIncentivesType


class NPVofTaxImplicationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NPVofTaxImplicationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NPVofTaxImplicationsType.subclass:
            return NPVofTaxImplicationsType.subclass(*args_, **kwargs_)
        else:
            return NPVofTaxImplicationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NPVofTaxImplicationsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NPVofTaxImplicationsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NPVofTaxImplicationsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NPVofTaxImplicationsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NPVofTaxImplicationsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NPVofTaxImplicationsType


class SimplePaybackType25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePaybackType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePaybackType25.subclass:
            return SimplePaybackType25.subclass(*args_, **kwargs_)
        else:
            return SimplePaybackType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimplePaybackType25', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePaybackType25')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimplePaybackType25', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimplePaybackType25'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimplePaybackType25', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SimplePaybackType25


class NetPresentValueType26(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetPresentValueType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetPresentValueType26.subclass:
            return NetPresentValueType26.subclass(*args_, **kwargs_)
        else:
            return NetPresentValueType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetPresentValueType26', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetPresentValueType26')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetPresentValueType26', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetPresentValueType26'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetPresentValueType26', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetPresentValueType26


class InternalRateOfReturnType27(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternalRateOfReturnType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternalRateOfReturnType27.subclass:
            return InternalRateOfReturnType27.subclass(*args_, **kwargs_)
        else:
            return InternalRateOfReturnType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType27', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternalRateOfReturnType27')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InternalRateOfReturnType27', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InternalRateOfReturnType27'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType27', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InternalRateOfReturnType27


class OtherType28(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceCase=None, AnnualSavingsSiteEnergy=None, AnnualSavingsSourceEnergy=None, AnnualSavingsCost=None, SummerPeakElectricityReduction=None, WinterPeakElectricityReduction=None, AnnualWaterSavings=None, AnnualWaterCostSavings=None, SimplePayback=None, NetPresentValue=None, InternalRateOfReturn=None, AssetScore=None, ENERGYSTARScore=None):
        self.original_tagname_ = None
        self.ReferenceCase = ReferenceCase
        self.AnnualSavingsSiteEnergy = AnnualSavingsSiteEnergy
        self.AnnualSavingsSourceEnergy = AnnualSavingsSourceEnergy
        self.AnnualSavingsCost = AnnualSavingsCost
        self.SummerPeakElectricityReduction = SummerPeakElectricityReduction
        self.WinterPeakElectricityReduction = WinterPeakElectricityReduction
        self.AnnualWaterSavings = AnnualWaterSavings
        self.AnnualWaterCostSavings = AnnualWaterCostSavings
        self.SimplePayback = SimplePayback
        self.NetPresentValue = NetPresentValue
        self.InternalRateOfReturn = InternalRateOfReturn
        self.AssetScore = AssetScore
        self.ENERGYSTARScore = ENERGYSTARScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherType28.subclass:
            return OtherType28.subclass(*args_, **kwargs_)
        else:
            return OtherType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ReferenceCase is not None or
            self.AnnualSavingsSiteEnergy is not None or
            self.AnnualSavingsSourceEnergy is not None or
            self.AnnualSavingsCost is not None or
            self.SummerPeakElectricityReduction is not None or
            self.WinterPeakElectricityReduction is not None or
            self.AnnualWaterSavings is not None or
            self.AnnualWaterCostSavings is not None or
            self.SimplePayback is not None or
            self.NetPresentValue is not None or
            self.InternalRateOfReturn is not None or
            self.AssetScore is not None or
            self.ENERGYSTARScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherType28', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherType28')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherType28'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceCase is not None:
            self.ReferenceCase.export(outfile, level, namespace_='auc:', name_='ReferenceCase', pretty_print=pretty_print)
        if self.AnnualSavingsSiteEnergy is not None:
            self.AnnualSavingsSiteEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSiteEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsSourceEnergy is not None:
            self.AnnualSavingsSourceEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSourceEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsCost is not None:
            self.AnnualSavingsCost.export(outfile, level, namespace_, name_='AnnualSavingsCost', pretty_print=pretty_print)
        if self.SummerPeakElectricityReduction is not None:
            self.SummerPeakElectricityReduction.export(outfile, level, namespace_, name_='SummerPeakElectricityReduction', pretty_print=pretty_print)
        if self.WinterPeakElectricityReduction is not None:
            self.WinterPeakElectricityReduction.export(outfile, level, namespace_, name_='WinterPeakElectricityReduction', pretty_print=pretty_print)
        if self.AnnualWaterSavings is not None:
            self.AnnualWaterSavings.export(outfile, level, namespace_, name_='AnnualWaterSavings', pretty_print=pretty_print)
        if self.AnnualWaterCostSavings is not None:
            self.AnnualWaterCostSavings.export(outfile, level, namespace_, name_='AnnualWaterCostSavings', pretty_print=pretty_print)
        if self.SimplePayback is not None:
            self.SimplePayback.export(outfile, level, namespace_, name_='SimplePayback', pretty_print=pretty_print)
        if self.NetPresentValue is not None:
            self.NetPresentValue.export(outfile, level, namespace_, name_='NetPresentValue', pretty_print=pretty_print)
        if self.InternalRateOfReturn is not None:
            self.InternalRateOfReturn.export(outfile, level, namespace_, name_='InternalRateOfReturn', pretty_print=pretty_print)
        if self.AssetScore is not None:
            self.AssetScore.export(outfile, level, namespace_='auc:', name_='AssetScore', pretty_print=pretty_print)
        if self.ENERGYSTARScore is not None:
            self.ENERGYSTARScore.export(outfile, level, namespace_='auc:', name_='ENERGYSTARScore', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceCase':
            obj_ = ReferenceCase.factory()
            obj_.build(child_)
            self.ReferenceCase = obj_
            obj_.original_tagname_ = 'ReferenceCase'
        elif nodeName_ == 'AnnualSavingsSiteEnergy':
            obj_ = AnnualSavingsSiteEnergyType29.factory()
            obj_.build(child_)
            self.AnnualSavingsSiteEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSiteEnergy'
        elif nodeName_ == 'AnnualSavingsSourceEnergy':
            obj_ = AnnualSavingsSourceEnergyType30.factory()
            obj_.build(child_)
            self.AnnualSavingsSourceEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSourceEnergy'
        elif nodeName_ == 'AnnualSavingsCost':
            obj_ = AnnualSavingsCostType31.factory()
            obj_.build(child_)
            self.AnnualSavingsCost = obj_
            obj_.original_tagname_ = 'AnnualSavingsCost'
        elif nodeName_ == 'SummerPeakElectricityReduction':
            obj_ = SummerPeakElectricityReductionType32.factory()
            obj_.build(child_)
            self.SummerPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'SummerPeakElectricityReduction'
        elif nodeName_ == 'WinterPeakElectricityReduction':
            obj_ = WinterPeakElectricityReductionType33.factory()
            obj_.build(child_)
            self.WinterPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'WinterPeakElectricityReduction'
        elif nodeName_ == 'AnnualWaterSavings':
            obj_ = AnnualWaterSavingsType34.factory()
            obj_.build(child_)
            self.AnnualWaterSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterSavings'
        elif nodeName_ == 'AnnualWaterCostSavings':
            obj_ = AnnualWaterCostSavingsType35.factory()
            obj_.build(child_)
            self.AnnualWaterCostSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterCostSavings'
        elif nodeName_ == 'SimplePayback':
            obj_ = SimplePaybackType36.factory()
            obj_.build(child_)
            self.SimplePayback = obj_
            obj_.original_tagname_ = 'SimplePayback'
        elif nodeName_ == 'NetPresentValue':
            obj_ = NetPresentValueType37.factory()
            obj_.build(child_)
            self.NetPresentValue = obj_
            obj_.original_tagname_ = 'NetPresentValue'
        elif nodeName_ == 'InternalRateOfReturn':
            obj_ = InternalRateOfReturnType38.factory()
            obj_.build(child_)
            self.InternalRateOfReturn = obj_
            obj_.original_tagname_ = 'InternalRateOfReturn'
        elif nodeName_ == 'AssetScore':
            obj_ = AssetScore.factory()
            obj_.build(child_)
            self.AssetScore = obj_
            obj_.original_tagname_ = 'AssetScore'
        elif nodeName_ == 'ENERGYSTARScore':
            obj_ = ENERGYSTARScore.factory()
            obj_.build(child_)
            self.ENERGYSTARScore = obj_
            obj_.original_tagname_ = 'ENERGYSTARScore'
# end class OtherType28


class AnnualSavingsSiteEnergyType29(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSiteEnergyType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSiteEnergyType29.subclass:
            return AnnualSavingsSiteEnergyType29.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSiteEnergyType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType29', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSiteEnergyType29')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSiteEnergyType29', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSiteEnergyType29'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType29', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSiteEnergyType29


class AnnualSavingsSourceEnergyType30(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSourceEnergyType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSourceEnergyType30.subclass:
            return AnnualSavingsSourceEnergyType30.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSourceEnergyType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType30', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSourceEnergyType30')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSourceEnergyType30', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSourceEnergyType30'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType30', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSourceEnergyType30


class AnnualSavingsCostType31(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsCostType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsCostType31.subclass:
            return AnnualSavingsCostType31.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsCostType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType31', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsCostType31')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsCostType31', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsCostType31'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType31', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsCostType31


class SummerPeakElectricityReductionType32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummerPeakElectricityReductionType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummerPeakElectricityReductionType32.subclass:
            return SummerPeakElectricityReductionType32.subclass(*args_, **kwargs_)
        else:
            return SummerPeakElectricityReductionType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType32', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SummerPeakElectricityReductionType32')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SummerPeakElectricityReductionType32', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SummerPeakElectricityReductionType32'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType32', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SummerPeakElectricityReductionType32


class WinterPeakElectricityReductionType33(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WinterPeakElectricityReductionType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WinterPeakElectricityReductionType33.subclass:
            return WinterPeakElectricityReductionType33.subclass(*args_, **kwargs_)
        else:
            return WinterPeakElectricityReductionType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType33', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WinterPeakElectricityReductionType33')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WinterPeakElectricityReductionType33', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WinterPeakElectricityReductionType33'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType33', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WinterPeakElectricityReductionType33


class AnnualWaterSavingsType34(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterSavingsType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterSavingsType34.subclass:
            return AnnualWaterSavingsType34.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterSavingsType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType34', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterSavingsType34')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterSavingsType34', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterSavingsType34'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType34', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterSavingsType34


class AnnualWaterCostSavingsType35(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterCostSavingsType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterCostSavingsType35.subclass:
            return AnnualWaterCostSavingsType35.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterCostSavingsType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType35', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterCostSavingsType35')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterCostSavingsType35', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterCostSavingsType35'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType35', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterCostSavingsType35


class SimplePaybackType36(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePaybackType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePaybackType36.subclass:
            return SimplePaybackType36.subclass(*args_, **kwargs_)
        else:
            return SimplePaybackType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimplePaybackType36', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePaybackType36')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimplePaybackType36', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimplePaybackType36'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimplePaybackType36', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SimplePaybackType36


class NetPresentValueType37(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetPresentValueType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetPresentValueType37.subclass:
            return NetPresentValueType37.subclass(*args_, **kwargs_)
        else:
            return NetPresentValueType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetPresentValueType37', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetPresentValueType37')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetPresentValueType37', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetPresentValueType37'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetPresentValueType37', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetPresentValueType37


class InternalRateOfReturnType38(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternalRateOfReturnType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternalRateOfReturnType38.subclass:
            return InternalRateOfReturnType38.subclass(*args_, **kwargs_)
        else:
            return InternalRateOfReturnType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType38', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternalRateOfReturnType38')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InternalRateOfReturnType38', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InternalRateOfReturnType38'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType38', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InternalRateOfReturnType38


class WeatherTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Normalized=None, AdjustedToYear=None, Actual=None, Other=None):
        self.original_tagname_ = None
        self.Normalized = Normalized
        self.AdjustedToYear = AdjustedToYear
        self.Actual = Actual
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeatherTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeatherTypeType.subclass:
            return WeatherTypeType.subclass(*args_, **kwargs_)
        else:
            return WeatherTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Normalized is not None or
            self.AdjustedToYear is not None or
            self.Actual is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WeatherTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeatherTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WeatherTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WeatherTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WeatherTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Normalized is not None:
            self.Normalized.export(outfile, level, namespace_, name_='Normalized', pretty_print=pretty_print)
        if self.AdjustedToYear is not None:
            self.AdjustedToYear.export(outfile, level, namespace_, name_='AdjustedToYear', pretty_print=pretty_print)
        if self.Actual is not None:
            self.Actual.export(outfile, level, namespace_, name_='Actual', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Normalized':
            obj_ = NormalizedType.factory()
            obj_.build(child_)
            self.Normalized = obj_
            obj_.original_tagname_ = 'Normalized'
        elif nodeName_ == 'AdjustedToYear':
            obj_ = AdjustedToYearType.factory()
            obj_.build(child_)
            self.AdjustedToYear = obj_
            obj_.original_tagname_ = 'AdjustedToYear'
        elif nodeName_ == 'Actual':
            obj_ = ActualType.factory()
            obj_.build(child_)
            self.Actual = obj_
            obj_.original_tagname_ = 'Actual'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class WeatherTypeType


class NormalizedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NormalizationYears=None, NormalizationStartYear=None, WeatherDataSource=None):
        self.original_tagname_ = None
        self.NormalizationYears = NormalizationYears
        self.NormalizationStartYear = NormalizationStartYear
        self.WeatherDataSource = WeatherDataSource
        self.validate_WeatherDataSource(self.WeatherDataSource)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormalizedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormalizedType.subclass:
            return NormalizedType.subclass(*args_, **kwargs_)
        else:
            return NormalizedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WeatherDataSource(self, value):
        # Validate type WeatherDataSource, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NormalizationYears is not None or
            self.NormalizationStartYear is not None or
            self.WeatherDataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NormalizedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormalizedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NormalizedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NormalizedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NormalizedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NormalizationYears is not None:
            self.NormalizationYears.export(outfile, level, namespace_, name_='NormalizationYears', pretty_print=pretty_print)
        if self.NormalizationStartYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNormalizationStartYear>%s</%sNormalizationStartYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NormalizationStartYear), input_name='NormalizationStartYear')), namespace_, eol_))
        if self.WeatherDataSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherDataSource>%s</%sWeatherDataSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WeatherDataSource), input_name='WeatherDataSource')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NormalizationYears':
            obj_ = NormalizationYearsType.factory()
            obj_.build(child_)
            self.NormalizationYears = obj_
            obj_.original_tagname_ = 'NormalizationYears'
        elif nodeName_ == 'NormalizationStartYear':
            NormalizationStartYear_ = child_.text
            NormalizationStartYear_ = self.gds_validate_string(NormalizationStartYear_, node, 'NormalizationStartYear')
            self.NormalizationStartYear = NormalizationStartYear_
        elif nodeName_ == 'WeatherDataSource':
            WeatherDataSource_ = child_.text
            WeatherDataSource_ = self.gds_validate_string(WeatherDataSource_, node, 'WeatherDataSource')
            self.WeatherDataSource = WeatherDataSource_
            # validate type WeatherDataSource
            self.validate_WeatherDataSource(self.WeatherDataSource)
# end class NormalizedType


class NormalizationYearsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormalizationYearsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormalizationYearsType.subclass:
            return NormalizationYearsType.subclass(*args_, **kwargs_)
        else:
            return NormalizationYearsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NormalizationYearsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormalizationYearsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NormalizationYearsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NormalizationYearsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NormalizationYearsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NormalizationYearsType


class AdjustedToYearType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WeatherYear=None):
        self.original_tagname_ = None
        self.WeatherYear = WeatherYear
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustedToYearType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustedToYearType.subclass:
            return AdjustedToYearType.subclass(*args_, **kwargs_)
        else:
            return AdjustedToYearType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.WeatherYear is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AdjustedToYearType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustedToYearType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AdjustedToYearType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AdjustedToYearType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AdjustedToYearType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WeatherYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherYear>%s</%sWeatherYear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WeatherYear), input_name='WeatherYear')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeatherYear':
            WeatherYear_ = child_.text
            WeatherYear_ = self.gds_validate_string(WeatherYear_, node, 'WeatherYear')
            self.WeatherYear = WeatherYear_
# end class AdjustedToYearType


class ActualType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WeatherDataSource=None):
        self.original_tagname_ = None
        self.WeatherDataSource = WeatherDataSource
        self.validate_WeatherDataSource(self.WeatherDataSource)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActualType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActualType.subclass:
            return ActualType.subclass(*args_, **kwargs_)
        else:
            return ActualType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WeatherDataSource(self, value):
        # Validate type WeatherDataSource, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.WeatherDataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ActualType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActualType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ActualType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ActualType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ActualType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WeatherDataSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeatherDataSource>%s</%sWeatherDataSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WeatherDataSource), input_name='WeatherDataSource')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeatherDataSource':
            WeatherDataSource_ = child_.text
            WeatherDataSource_ = self.gds_validate_string(WeatherDataSource_, node, 'WeatherDataSource')
            self.WeatherDataSource = WeatherDataSource_
            # validate type WeatherDataSource
            self.validate_WeatherDataSource(self.WeatherDataSource)
# end class ActualType


class ResourceUsesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResourceUse=None):
        self.original_tagname_ = None
        if ResourceUse is None:
            self.ResourceUse = []
        else:
            self.ResourceUse = ResourceUse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceUsesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceUsesType.subclass:
            return ResourceUsesType.subclass(*args_, **kwargs_)
        else:
            return ResourceUsesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ResourceUse
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResourceUsesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceUsesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResourceUsesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResourceUsesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResourceUsesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceUse_ in self.ResourceUse:
            ResourceUse_.export(outfile, level, namespace_, name_='ResourceUse', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceUse':
            obj_ = ResourceUseType.factory()
            obj_.build(child_)
            self.ResourceUse.append(obj_)
            obj_.original_tagname_ = 'ResourceUse'
# end class ResourceUsesType


class TimeSeriesDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TimeSeries=None):
        self.original_tagname_ = None
        if TimeSeries is None:
            self.TimeSeries = []
        else:
            self.TimeSeries = TimeSeries
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeriesDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeriesDataType.subclass:
            return TimeSeriesDataType.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.TimeSeries
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TimeSeriesDataType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeriesDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TimeSeriesDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TimeSeriesDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TimeSeriesDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TimeSeries_ in self.TimeSeries:
            TimeSeries_.export(outfile, level, namespace_, name_='TimeSeries', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeSeries':
            obj_ = TimeSeriesType.factory()
            obj_.build(child_)
            self.TimeSeries.append(obj_)
            obj_.original_tagname_ = 'TimeSeries'
# end class TimeSeriesDataType


class AllResourceTotalsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AllResourceTotal=None):
        self.original_tagname_ = None
        if AllResourceTotal is None:
            self.AllResourceTotal = []
        else:
            self.AllResourceTotal = AllResourceTotal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AllResourceTotalsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AllResourceTotalsType.subclass:
            return AllResourceTotalsType.subclass(*args_, **kwargs_)
        else:
            return AllResourceTotalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AllResourceTotal
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AllResourceTotalsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllResourceTotalsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AllResourceTotalsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AllResourceTotalsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AllResourceTotalsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AllResourceTotal_ in self.AllResourceTotal:
            AllResourceTotal_.export(outfile, level, namespace_, name_='AllResourceTotal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllResourceTotal':
            obj_ = AllResourceTotalType.factory()
            obj_.build(child_)
            self.AllResourceTotal.append(obj_)
            obj_.original_tagname_ = 'AllResourceTotal'
# end class AllResourceTotalsType


class AnnualHeatingDegreeDaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingDegreeDaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingDegreeDaysType.subclass:
            return AnnualHeatingDegreeDaysType.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingDegreeDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingDegreeDaysType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingDegreeDaysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingDegreeDaysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingDegreeDaysType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingDegreeDaysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingDegreeDaysType


class AnnualCoolingDegreeDaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualCoolingDegreeDaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualCoolingDegreeDaysType.subclass:
            return AnnualCoolingDegreeDaysType.subclass(*args_, **kwargs_)
        else:
            return AnnualCoolingDegreeDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualCoolingDegreeDaysType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualCoolingDegreeDaysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualCoolingDegreeDaysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualCoolingDegreeDaysType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualCoolingDegreeDaysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualCoolingDegreeDaysType


class HDDBaseTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HDDBaseTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HDDBaseTemperatureType.subclass:
            return HDDBaseTemperatureType.subclass(*args_, **kwargs_)
        else:
            return HDDBaseTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HDDBaseTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HDDBaseTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HDDBaseTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HDDBaseTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HDDBaseTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HDDBaseTemperatureType


class CDDBaseTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CDDBaseTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CDDBaseTemperatureType.subclass:
            return CDDBaseTemperatureType.subclass(*args_, **kwargs_)
        else:
            return CDDBaseTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CDDBaseTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CDDBaseTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CDDBaseTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CDDBaseTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CDDBaseTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CDDBaseTemperatureType


class AnnualFuelUseNativeUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualFuelUseNativeUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualFuelUseNativeUnitsType.subclass:
            return AnnualFuelUseNativeUnitsType.subclass(*args_, **kwargs_)
        else:
            return AnnualFuelUseNativeUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualFuelUseNativeUnitsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualFuelUseNativeUnitsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualFuelUseNativeUnitsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualFuelUseNativeUnitsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualFuelUseNativeUnitsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualFuelUseNativeUnitsType


class AnnualFuelUseConsistentUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualFuelUseConsistentUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualFuelUseConsistentUnitsType.subclass:
            return AnnualFuelUseConsistentUnitsType.subclass(*args_, **kwargs_)
        else:
            return AnnualFuelUseConsistentUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualFuelUseConsistentUnitsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualFuelUseConsistentUnitsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualFuelUseConsistentUnitsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualFuelUseConsistentUnitsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualFuelUseConsistentUnitsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualFuelUseConsistentUnitsType


class FuelUseIntensityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FuelUseIntensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FuelUseIntensityType.subclass:
            return FuelUseIntensityType.subclass(*args_, **kwargs_)
        else:
            return FuelUseIntensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FuelUseIntensityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FuelUseIntensityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FuelUseIntensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FuelUseIntensityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FuelUseIntensityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FuelUseIntensityType


class UtilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RateSchedule=None, MeteringConfiguration=None, TypeOfResourceMeter=None, FuelInterruptibility=None, UtilityName=None, PowerPlant=None, UtilityMeterNumber=None, UtilityAccountNumber=None, UtilityBillpayer=None, ElectricDistributionUtility=None, SourceSiteRatio=None):
        self.original_tagname_ = None
        if RateSchedule is None:
            self.RateSchedule = []
        else:
            self.RateSchedule = RateSchedule
        self.MeteringConfiguration = MeteringConfiguration
        self.validate_MeteringConfigurationType(self.MeteringConfiguration)
        self.TypeOfResourceMeter = TypeOfResourceMeter
        self.validate_TypeOfResourceMeterType(self.TypeOfResourceMeter)
        self.FuelInterruptibility = FuelInterruptibility
        self.validate_FuelInterruptibilityType(self.FuelInterruptibility)
        self.UtilityName = UtilityName
        self.PowerPlant = PowerPlant
        if UtilityMeterNumber is None:
            self.UtilityMeterNumber = []
        else:
            self.UtilityMeterNumber = UtilityMeterNumber
        self.UtilityAccountNumber = UtilityAccountNumber
        self.UtilityBillpayer = UtilityBillpayer
        self.ElectricDistributionUtility = ElectricDistributionUtility
        self.SourceSiteRatio = SourceSiteRatio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UtilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UtilityType.subclass:
            return UtilityType.subclass(*args_, **kwargs_)
        else:
            return UtilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeteringConfigurationType(self, value):
        # Validate type MeteringConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Direct metering (tenants directly metered)', 'Master meter without sub-metering (Tenants not directly metered or sub-metered)', 'Master meter with sub-metering (Tenants sub-metered by building owner)', 'Combination', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeteringConfigurationType' % {"value" : value.encode("utf-8")} )
    def validate_TypeOfResourceMeterType(self, value):
        # Validate type TypeOfResourceMeterType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Revenue grade meter', 'Advanced resource meter', 'Analog', 'Interval', 'Net', 'Smart meter', 'PDU input meter', 'IT equipment input meter', 'Supply UPS output meter', 'PDU output meter', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TypeOfResourceMeterType' % {"value" : value.encode("utf-8")} )
    def validate_FuelInterruptibilityType(self, value):
        # Validate type FuelInterruptibilityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Interruptible', 'Firm', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelInterruptibilityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateSchedule or
            self.MeteringConfiguration is not None or
            self.TypeOfResourceMeter is not None or
            self.FuelInterruptibility is not None or
            self.UtilityName is not None or
            self.PowerPlant is not None or
            self.UtilityMeterNumber or
            self.UtilityAccountNumber is not None or
            self.UtilityBillpayer is not None or
            self.ElectricDistributionUtility is not None or
            self.SourceSiteRatio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UtilityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UtilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UtilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UtilityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UtilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RateSchedule_ in self.RateSchedule:
            RateSchedule_.export(outfile, level, namespace_, name_='RateSchedule', pretty_print=pretty_print)
        if self.MeteringConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeteringConfiguration>%s</%sMeteringConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MeteringConfiguration), input_name='MeteringConfiguration')), namespace_, eol_))
        if self.TypeOfResourceMeter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeOfResourceMeter>%s</%sTypeOfResourceMeter>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TypeOfResourceMeter), input_name='TypeOfResourceMeter')), namespace_, eol_))
        if self.FuelInterruptibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFuelInterruptibility>%s</%sFuelInterruptibility>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FuelInterruptibility), input_name='FuelInterruptibility')), namespace_, eol_))
        if self.UtilityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityName>%s</%sUtilityName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityName), input_name='UtilityName')), namespace_, eol_))
        if self.PowerPlant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPowerPlant>%s</%sPowerPlant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PowerPlant), input_name='PowerPlant')), namespace_, eol_))
        for UtilityMeterNumber_ in self.UtilityMeterNumber:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityMeterNumber>%s</%sUtilityMeterNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(UtilityMeterNumber_), input_name='UtilityMeterNumber')), namespace_, eol_))
        if self.UtilityAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityAccountNumber>%s</%sUtilityAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityAccountNumber), input_name='UtilityAccountNumber')), namespace_, eol_))
        if self.UtilityBillpayer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityBillpayer>%s</%sUtilityBillpayer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityBillpayer), input_name='UtilityBillpayer')), namespace_, eol_))
        if self.ElectricDistributionUtility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sElectricDistributionUtility>%s</%sElectricDistributionUtility>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ElectricDistributionUtility), input_name='ElectricDistributionUtility')), namespace_, eol_))
        if self.SourceSiteRatio is not None:
            self.SourceSiteRatio.export(outfile, level, namespace_, name_='SourceSiteRatio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateSchedule':
            obj_ = RateScheduleType.factory()
            obj_.build(child_)
            self.RateSchedule.append(obj_)
            obj_.original_tagname_ = 'RateSchedule'
        elif nodeName_ == 'MeteringConfiguration':
            MeteringConfiguration_ = child_.text
            MeteringConfiguration_ = self.gds_validate_string(MeteringConfiguration_, node, 'MeteringConfiguration')
            self.MeteringConfiguration = MeteringConfiguration_
            # validate type MeteringConfigurationType
            self.validate_MeteringConfigurationType(self.MeteringConfiguration)
        elif nodeName_ == 'TypeOfResourceMeter':
            TypeOfResourceMeter_ = child_.text
            TypeOfResourceMeter_ = self.gds_validate_string(TypeOfResourceMeter_, node, 'TypeOfResourceMeter')
            self.TypeOfResourceMeter = TypeOfResourceMeter_
            # validate type TypeOfResourceMeterType
            self.validate_TypeOfResourceMeterType(self.TypeOfResourceMeter)
        elif nodeName_ == 'FuelInterruptibility':
            FuelInterruptibility_ = child_.text
            FuelInterruptibility_ = self.gds_validate_string(FuelInterruptibility_, node, 'FuelInterruptibility')
            self.FuelInterruptibility = FuelInterruptibility_
            # validate type FuelInterruptibilityType
            self.validate_FuelInterruptibilityType(self.FuelInterruptibility)
        elif nodeName_ == 'UtilityName':
            UtilityName_ = child_.text
            UtilityName_ = self.gds_validate_string(UtilityName_, node, 'UtilityName')
            self.UtilityName = UtilityName_
        elif nodeName_ == 'PowerPlant':
            PowerPlant_ = child_.text
            PowerPlant_ = self.gds_validate_string(PowerPlant_, node, 'PowerPlant')
            self.PowerPlant = PowerPlant_
        elif nodeName_ == 'UtilityMeterNumber':
            UtilityMeterNumber_ = child_.text
            UtilityMeterNumber_ = self.gds_validate_string(UtilityMeterNumber_, node, 'UtilityMeterNumber')
            self.UtilityMeterNumber.append(UtilityMeterNumber_)
        elif nodeName_ == 'UtilityAccountNumber':
            UtilityAccountNumber_ = child_.text
            UtilityAccountNumber_ = self.gds_validate_string(UtilityAccountNumber_, node, 'UtilityAccountNumber')
            self.UtilityAccountNumber = UtilityAccountNumber_
        elif nodeName_ == 'UtilityBillpayer':
            UtilityBillpayer_ = child_.text
            UtilityBillpayer_ = self.gds_validate_string(UtilityBillpayer_, node, 'UtilityBillpayer')
            self.UtilityBillpayer = UtilityBillpayer_
        elif nodeName_ == 'ElectricDistributionUtility':
            ElectricDistributionUtility_ = child_.text
            ElectricDistributionUtility_ = self.gds_validate_string(ElectricDistributionUtility_, node, 'ElectricDistributionUtility')
            self.ElectricDistributionUtility = ElectricDistributionUtility_
        elif nodeName_ == 'SourceSiteRatio':
            obj_ = SourceSiteRatioType.factory()
            obj_.build(child_)
            self.SourceSiteRatio = obj_
            obj_.original_tagname_ = 'SourceSiteRatio'
# end class UtilityType


class RateScheduleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RateStructureName=None, TypeOfRateStructure=None, RateStructureSector=None, ReferenceForRateStructure=None, RateStructureEffectiveDate=None, RateStructureEndDate=None, ReactivePowerCharge=None, MinimumPowerFactorWithoutPenalty=None, FixedMonthlyCharge=None, NetMetering=None, AverageMarginalCostRate=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.RateStructureName = RateStructureName
        self.TypeOfRateStructure = TypeOfRateStructure
        self.RateStructureSector = RateStructureSector
        self.validate_RateStructureSectorType(self.RateStructureSector)
        self.ReferenceForRateStructure = ReferenceForRateStructure
        if isinstance(RateStructureEffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RateStructureEffectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RateStructureEffectiveDate
        self.RateStructureEffectiveDate = initvalue_
        if isinstance(RateStructureEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RateStructureEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RateStructureEndDate
        self.RateStructureEndDate = initvalue_
        self.ReactivePowerCharge = ReactivePowerCharge
        self.MinimumPowerFactorWithoutPenalty = MinimumPowerFactorWithoutPenalty
        self.FixedMonthlyCharge = FixedMonthlyCharge
        self.NetMetering = NetMetering
        self.AverageMarginalCostRate = AverageMarginalCostRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateScheduleType.subclass:
            return RateScheduleType.subclass(*args_, **kwargs_)
        else:
            return RateScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RateStructureSectorType(self, value):
        # Validate type RateStructureSectorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Residential', 'Commercial', 'Industrial', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateStructureSectorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateStructureName is not None or
            self.TypeOfRateStructure is not None or
            self.RateStructureSector is not None or
            self.ReferenceForRateStructure is not None or
            self.RateStructureEffectiveDate is not None or
            self.RateStructureEndDate is not None or
            self.ReactivePowerCharge is not None or
            self.MinimumPowerFactorWithoutPenalty is not None or
            self.FixedMonthlyCharge is not None or
            self.NetMetering is not None or
            self.AverageMarginalCostRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RateScheduleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateScheduleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RateScheduleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RateScheduleType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RateScheduleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateStructureName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateStructureName>%s</%sRateStructureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RateStructureName), input_name='RateStructureName')), namespace_, eol_))
        if self.TypeOfRateStructure is not None:
            self.TypeOfRateStructure.export(outfile, level, namespace_, name_='TypeOfRateStructure', pretty_print=pretty_print)
        if self.RateStructureSector is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateStructureSector>%s</%sRateStructureSector>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RateStructureSector), input_name='RateStructureSector')), namespace_, eol_))
        if self.ReferenceForRateStructure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceForRateStructure>%s</%sReferenceForRateStructure>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceForRateStructure), input_name='ReferenceForRateStructure')), namespace_, eol_))
        if self.RateStructureEffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateStructureEffectiveDate>%s</%sRateStructureEffectiveDate>%s' % (namespace_, self.gds_format_date(self.RateStructureEffectiveDate, input_name='RateStructureEffectiveDate'), namespace_, eol_))
        if self.RateStructureEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRateStructureEndDate>%s</%sRateStructureEndDate>%s' % (namespace_, self.gds_format_date(self.RateStructureEndDate, input_name='RateStructureEndDate'), namespace_, eol_))
        if self.ReactivePowerCharge is not None:
            self.ReactivePowerCharge.export(outfile, level, namespace_, name_='ReactivePowerCharge', pretty_print=pretty_print)
        if self.MinimumPowerFactorWithoutPenalty is not None:
            self.MinimumPowerFactorWithoutPenalty.export(outfile, level, namespace_, name_='MinimumPowerFactorWithoutPenalty', pretty_print=pretty_print)
        if self.FixedMonthlyCharge is not None:
            self.FixedMonthlyCharge.export(outfile, level, namespace_, name_='FixedMonthlyCharge', pretty_print=pretty_print)
        if self.NetMetering is not None:
            self.NetMetering.export(outfile, level, namespace_, name_='NetMetering', pretty_print=pretty_print)
        if self.AverageMarginalCostRate is not None:
            self.AverageMarginalCostRate.export(outfile, level, namespace_, name_='AverageMarginalCostRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateStructureName':
            RateStructureName_ = child_.text
            RateStructureName_ = self.gds_validate_string(RateStructureName_, node, 'RateStructureName')
            self.RateStructureName = RateStructureName_
        elif nodeName_ == 'TypeOfRateStructure':
            obj_ = TypeOfRateStructureType.factory()
            obj_.build(child_)
            self.TypeOfRateStructure = obj_
            obj_.original_tagname_ = 'TypeOfRateStructure'
        elif nodeName_ == 'RateStructureSector':
            RateStructureSector_ = child_.text
            RateStructureSector_ = self.gds_validate_string(RateStructureSector_, node, 'RateStructureSector')
            self.RateStructureSector = RateStructureSector_
            # validate type RateStructureSectorType
            self.validate_RateStructureSectorType(self.RateStructureSector)
        elif nodeName_ == 'ReferenceForRateStructure':
            ReferenceForRateStructure_ = child_.text
            ReferenceForRateStructure_ = self.gds_validate_string(ReferenceForRateStructure_, node, 'ReferenceForRateStructure')
            self.ReferenceForRateStructure = ReferenceForRateStructure_
        elif nodeName_ == 'RateStructureEffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RateStructureEffectiveDate = dval_
        elif nodeName_ == 'RateStructureEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RateStructureEndDate = dval_
        elif nodeName_ == 'ReactivePowerCharge':
            obj_ = ReactivePowerChargeType.factory()
            obj_.build(child_)
            self.ReactivePowerCharge = obj_
            obj_.original_tagname_ = 'ReactivePowerCharge'
        elif nodeName_ == 'MinimumPowerFactorWithoutPenalty':
            obj_ = MinimumPowerFactorWithoutPenaltyType.factory()
            obj_.build(child_)
            self.MinimumPowerFactorWithoutPenalty = obj_
            obj_.original_tagname_ = 'MinimumPowerFactorWithoutPenalty'
        elif nodeName_ == 'FixedMonthlyCharge':
            obj_ = FixedMonthlyChargeType.factory()
            obj_.build(child_)
            self.FixedMonthlyCharge = obj_
            obj_.original_tagname_ = 'FixedMonthlyCharge'
        elif nodeName_ == 'NetMetering':
            obj_ = NetMeteringType.factory()
            obj_.build(child_)
            self.NetMetering = obj_
            obj_.original_tagname_ = 'NetMetering'
        elif nodeName_ == 'AverageMarginalCostRate':
            obj_ = AverageMarginalCostRateType.factory()
            obj_.build(child_)
            self.AverageMarginalCostRate = obj_
            obj_.original_tagname_ = 'AverageMarginalCostRate'
# end class RateScheduleType


class TypeOfRateStructureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FlatRate=None, TimeOfUseRate=None, TieredRate=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.FlatRate = FlatRate
        self.TimeOfUseRate = TimeOfUseRate
        if TieredRate is None:
            self.TieredRate = []
        else:
            self.TieredRate = TieredRate
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TypeOfRateStructureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TypeOfRateStructureType.subclass:
            return TypeOfRateStructureType.subclass(*args_, **kwargs_)
        else:
            return TypeOfRateStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FlatRate is not None or
            self.TimeOfUseRate is not None or
            self.TieredRate or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TypeOfRateStructureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeOfRateStructureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TypeOfRateStructureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TypeOfRateStructureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TypeOfRateStructureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FlatRate is not None:
            self.FlatRate.export(outfile, level, namespace_, name_='FlatRate', pretty_print=pretty_print)
        if self.TimeOfUseRate is not None:
            self.TimeOfUseRate.export(outfile, level, namespace_, name_='TimeOfUseRate', pretty_print=pretty_print)
        for TieredRate_ in self.TieredRate:
            TieredRate_.export(outfile, level, namespace_, name_='TieredRate', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlatRate':
            obj_ = FlatRateType.factory()
            obj_.build(child_)
            self.FlatRate = obj_
            obj_.original_tagname_ = 'FlatRate'
        elif nodeName_ == 'TimeOfUseRate':
            obj_ = TimeOfUseRateType.factory()
            obj_.build(child_)
            self.TimeOfUseRate = obj_
            obj_.original_tagname_ = 'TimeOfUseRate'
        elif nodeName_ == 'TieredRate':
            obj_ = TieredRateType.factory()
            obj_.build(child_)
            self.TieredRate.append(obj_)
            obj_.original_tagname_ = 'TieredRate'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class TypeOfRateStructureType


class FlatRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriod=None):
        self.original_tagname_ = None
        if RatePeriod is None:
            self.RatePeriod = []
        else:
            self.RatePeriod = RatePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlatRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlatRateType.subclass:
            return FlatRateType.subclass(*args_, **kwargs_)
        else:
            return FlatRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RatePeriod
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FlatRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlatRateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FlatRateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FlatRateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FlatRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RatePeriod_ in self.RatePeriod:
            RatePeriod_.export(outfile, level, namespace_, name_='RatePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriod':
            obj_ = RatePeriodType.factory()
            obj_.build(child_)
            self.RatePeriod.append(obj_)
            obj_.original_tagname_ = 'RatePeriod'
# end class FlatRateType


class RatePeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriodName=None, ApplicableStartDateForEnergyRate=None, ApplicableEndDateForEnergyRate=None, ApplicableStartDateForDemandRate=None, ApplicableEndDateForDemandRate=None, DemandWindow=None, DemandRatchetPercentage=None, EnergyCostRate=None, EnergyRateAdjustment=None, ElectricDemandRate=None, DemandRateAdjustment=None, EnergySellRate=None):
        self.original_tagname_ = None
        self.RatePeriodName = RatePeriodName
        self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate
        self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate
        self.ApplicableStartDateForDemandRate = ApplicableStartDateForDemandRate
        self.ApplicableEndDateForDemandRate = ApplicableEndDateForDemandRate
        self.DemandWindow = DemandWindow
        self.DemandRatchetPercentage = DemandRatchetPercentage
        self.EnergyCostRate = EnergyCostRate
        self.EnergyRateAdjustment = EnergyRateAdjustment
        self.ElectricDemandRate = ElectricDemandRate
        self.DemandRateAdjustment = DemandRateAdjustment
        self.EnergySellRate = EnergySellRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatePeriodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatePeriodType.subclass:
            return RatePeriodType.subclass(*args_, **kwargs_)
        else:
            return RatePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RatePeriodName is not None or
            self.ApplicableStartDateForEnergyRate is not None or
            self.ApplicableEndDateForEnergyRate is not None or
            self.ApplicableStartDateForDemandRate is not None or
            self.ApplicableEndDateForDemandRate is not None or
            self.DemandWindow is not None or
            self.DemandRatchetPercentage is not None or
            self.EnergyCostRate is not None or
            self.EnergyRateAdjustment is not None or
            self.ElectricDemandRate is not None or
            self.DemandRateAdjustment is not None or
            self.EnergySellRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatePeriodType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatePeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatePeriodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatePeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatePeriodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RatePeriodName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRatePeriodName>%s</%sRatePeriodName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RatePeriodName), input_name='RatePeriodName')), namespace_, eol_))
        if self.ApplicableStartDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartDateForEnergyRate>%s</%sApplicableStartDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartDateForEnergyRate), input_name='ApplicableStartDateForEnergyRate')), namespace_, eol_))
        if self.ApplicableEndDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndDateForEnergyRate>%s</%sApplicableEndDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndDateForEnergyRate), input_name='ApplicableEndDateForEnergyRate')), namespace_, eol_))
        if self.ApplicableStartDateForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartDateForDemandRate>%s</%sApplicableStartDateForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartDateForDemandRate), input_name='ApplicableStartDateForDemandRate')), namespace_, eol_))
        if self.ApplicableEndDateForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndDateForDemandRate>%s</%sApplicableEndDateForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndDateForDemandRate), input_name='ApplicableEndDateForDemandRate')), namespace_, eol_))
        if self.DemandWindow is not None:
            self.DemandWindow.export(outfile, level, namespace_, name_='DemandWindow', pretty_print=pretty_print)
        if self.DemandRatchetPercentage is not None:
            self.DemandRatchetPercentage.export(outfile, level, namespace_, name_='DemandRatchetPercentage', pretty_print=pretty_print)
        if self.EnergyCostRate is not None:
            self.EnergyCostRate.export(outfile, level, namespace_, name_='EnergyCostRate', pretty_print=pretty_print)
        if self.EnergyRateAdjustment is not None:
            self.EnergyRateAdjustment.export(outfile, level, namespace_, name_='EnergyRateAdjustment', pretty_print=pretty_print)
        if self.ElectricDemandRate is not None:
            self.ElectricDemandRate.export(outfile, level, namespace_, name_='ElectricDemandRate', pretty_print=pretty_print)
        if self.DemandRateAdjustment is not None:
            self.DemandRateAdjustment.export(outfile, level, namespace_, name_='DemandRateAdjustment', pretty_print=pretty_print)
        if self.EnergySellRate is not None:
            self.EnergySellRate.export(outfile, level, namespace_, name_='EnergySellRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriodName':
            RatePeriodName_ = child_.text
            RatePeriodName_ = self.gds_validate_string(RatePeriodName_, node, 'RatePeriodName')
            self.RatePeriodName = RatePeriodName_
        elif nodeName_ == 'ApplicableStartDateForEnergyRate':
            ApplicableStartDateForEnergyRate_ = child_.text
            ApplicableStartDateForEnergyRate_ = self.gds_validate_string(ApplicableStartDateForEnergyRate_, node, 'ApplicableStartDateForEnergyRate')
            self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate_
        elif nodeName_ == 'ApplicableEndDateForEnergyRate':
            ApplicableEndDateForEnergyRate_ = child_.text
            ApplicableEndDateForEnergyRate_ = self.gds_validate_string(ApplicableEndDateForEnergyRate_, node, 'ApplicableEndDateForEnergyRate')
            self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate_
        elif nodeName_ == 'ApplicableStartDateForDemandRate':
            ApplicableStartDateForDemandRate_ = child_.text
            ApplicableStartDateForDemandRate_ = self.gds_validate_string(ApplicableStartDateForDemandRate_, node, 'ApplicableStartDateForDemandRate')
            self.ApplicableStartDateForDemandRate = ApplicableStartDateForDemandRate_
        elif nodeName_ == 'ApplicableEndDateForDemandRate':
            ApplicableEndDateForDemandRate_ = child_.text
            ApplicableEndDateForDemandRate_ = self.gds_validate_string(ApplicableEndDateForDemandRate_, node, 'ApplicableEndDateForDemandRate')
            self.ApplicableEndDateForDemandRate = ApplicableEndDateForDemandRate_
        elif nodeName_ == 'DemandWindow':
            obj_ = DemandWindowType.factory()
            obj_.build(child_)
            self.DemandWindow = obj_
            obj_.original_tagname_ = 'DemandWindow'
        elif nodeName_ == 'DemandRatchetPercentage':
            obj_ = DemandRatchetPercentageType.factory()
            obj_.build(child_)
            self.DemandRatchetPercentage = obj_
            obj_.original_tagname_ = 'DemandRatchetPercentage'
        elif nodeName_ == 'EnergyCostRate':
            obj_ = EnergyCostRateType.factory()
            obj_.build(child_)
            self.EnergyCostRate = obj_
            obj_.original_tagname_ = 'EnergyCostRate'
        elif nodeName_ == 'EnergyRateAdjustment':
            obj_ = EnergyRateAdjustmentType.factory()
            obj_.build(child_)
            self.EnergyRateAdjustment = obj_
            obj_.original_tagname_ = 'EnergyRateAdjustment'
        elif nodeName_ == 'ElectricDemandRate':
            obj_ = ElectricDemandRateType.factory()
            obj_.build(child_)
            self.ElectricDemandRate = obj_
            obj_.original_tagname_ = 'ElectricDemandRate'
        elif nodeName_ == 'DemandRateAdjustment':
            obj_ = DemandRateAdjustmentType.factory()
            obj_.build(child_)
            self.DemandRateAdjustment = obj_
            obj_.original_tagname_ = 'DemandRateAdjustment'
        elif nodeName_ == 'EnergySellRate':
            obj_ = EnergySellRateType.factory()
            obj_.build(child_)
            self.EnergySellRate = obj_
            obj_.original_tagname_ = 'EnergySellRate'
# end class RatePeriodType


class DemandWindowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandWindowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandWindowType.subclass:
            return DemandWindowType.subclass(*args_, **kwargs_)
        else:
            return DemandWindowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandWindowType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandWindowType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandWindowType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandWindowType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandWindowType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandWindowType


class DemandRatchetPercentageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRatchetPercentageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRatchetPercentageType.subclass:
            return DemandRatchetPercentageType.subclass(*args_, **kwargs_)
        else:
            return DemandRatchetPercentageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRatchetPercentageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRatchetPercentageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRatchetPercentageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRatchetPercentageType


class EnergyCostRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCostRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCostRateType.subclass:
            return EnergyCostRateType.subclass(*args_, **kwargs_)
        else:
            return EnergyCostRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyCostRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyCostRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyCostRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyCostRateType


class EnergyRateAdjustmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyRateAdjustmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyRateAdjustmentType.subclass:
            return EnergyRateAdjustmentType.subclass(*args_, **kwargs_)
        else:
            return EnergyRateAdjustmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyRateAdjustmentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyRateAdjustmentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyRateAdjustmentType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyRateAdjustmentType


class ElectricDemandRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricDemandRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricDemandRateType.subclass:
            return ElectricDemandRateType.subclass(*args_, **kwargs_)
        else:
            return ElectricDemandRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricDemandRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricDemandRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricDemandRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricDemandRateType


class DemandRateAdjustmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRateAdjustmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRateAdjustmentType.subclass:
            return DemandRateAdjustmentType.subclass(*args_, **kwargs_)
        else:
            return DemandRateAdjustmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRateAdjustmentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRateAdjustmentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRateAdjustmentType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRateAdjustmentType


class EnergySellRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergySellRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergySellRateType.subclass:
            return EnergySellRateType.subclass(*args_, **kwargs_)
        else:
            return EnergySellRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergySellRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergySellRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergySellRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergySellRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergySellRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergySellRateType


class TimeOfUseRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriod=None):
        self.original_tagname_ = None
        if RatePeriod is None:
            self.RatePeriod = []
        else:
            self.RatePeriod = RatePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeOfUseRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeOfUseRateType.subclass:
            return TimeOfUseRateType.subclass(*args_, **kwargs_)
        else:
            return TimeOfUseRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RatePeriod
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TimeOfUseRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOfUseRateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TimeOfUseRateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TimeOfUseRateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TimeOfUseRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RatePeriod_ in self.RatePeriod:
            RatePeriod_.export(outfile, level, namespace_, name_='RatePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriod':
            obj_ = RatePeriodType39.factory()
            obj_.build(child_)
            self.RatePeriod.append(obj_)
            obj_.original_tagname_ = 'RatePeriod'
# end class TimeOfUseRateType


class RatePeriodType39(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriodName=None, ApplicableStartDateForEnergyRate=None, ApplicableEndDateForEnergyRate=None, ApplicableStartDateForDemandRate=None, ApplicableEndDateForDemandRate=None, TimeOfUsePeriod=None, EnergySellRate=None):
        self.original_tagname_ = None
        self.RatePeriodName = RatePeriodName
        self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate
        self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate
        self.ApplicableStartDateForDemandRate = ApplicableStartDateForDemandRate
        self.ApplicableEndDateForDemandRate = ApplicableEndDateForDemandRate
        if TimeOfUsePeriod is None:
            self.TimeOfUsePeriod = []
        else:
            self.TimeOfUsePeriod = TimeOfUsePeriod
        self.EnergySellRate = EnergySellRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatePeriodType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatePeriodType39.subclass:
            return RatePeriodType39.subclass(*args_, **kwargs_)
        else:
            return RatePeriodType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RatePeriodName is not None or
            self.ApplicableStartDateForEnergyRate is not None or
            self.ApplicableEndDateForEnergyRate is not None or
            self.ApplicableStartDateForDemandRate is not None or
            self.ApplicableEndDateForDemandRate is not None or
            self.TimeOfUsePeriod or
            self.EnergySellRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatePeriodType39', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatePeriodType39')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatePeriodType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatePeriodType39'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatePeriodType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RatePeriodName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRatePeriodName>%s</%sRatePeriodName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RatePeriodName), input_name='RatePeriodName')), namespace_, eol_))
        if self.ApplicableStartDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartDateForEnergyRate>%s</%sApplicableStartDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartDateForEnergyRate), input_name='ApplicableStartDateForEnergyRate')), namespace_, eol_))
        if self.ApplicableEndDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndDateForEnergyRate>%s</%sApplicableEndDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndDateForEnergyRate), input_name='ApplicableEndDateForEnergyRate')), namespace_, eol_))
        if self.ApplicableStartDateForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartDateForDemandRate>%s</%sApplicableStartDateForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartDateForDemandRate), input_name='ApplicableStartDateForDemandRate')), namespace_, eol_))
        if self.ApplicableEndDateForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndDateForDemandRate>%s</%sApplicableEndDateForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndDateForDemandRate), input_name='ApplicableEndDateForDemandRate')), namespace_, eol_))
        for TimeOfUsePeriod_ in self.TimeOfUsePeriod:
            TimeOfUsePeriod_.export(outfile, level, namespace_, name_='TimeOfUsePeriod', pretty_print=pretty_print)
        if self.EnergySellRate is not None:
            self.EnergySellRate.export(outfile, level, namespace_, name_='EnergySellRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriodName':
            RatePeriodName_ = child_.text
            RatePeriodName_ = self.gds_validate_string(RatePeriodName_, node, 'RatePeriodName')
            self.RatePeriodName = RatePeriodName_
        elif nodeName_ == 'ApplicableStartDateForEnergyRate':
            ApplicableStartDateForEnergyRate_ = child_.text
            ApplicableStartDateForEnergyRate_ = self.gds_validate_string(ApplicableStartDateForEnergyRate_, node, 'ApplicableStartDateForEnergyRate')
            self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate_
        elif nodeName_ == 'ApplicableEndDateForEnergyRate':
            ApplicableEndDateForEnergyRate_ = child_.text
            ApplicableEndDateForEnergyRate_ = self.gds_validate_string(ApplicableEndDateForEnergyRate_, node, 'ApplicableEndDateForEnergyRate')
            self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate_
        elif nodeName_ == 'ApplicableStartDateForDemandRate':
            ApplicableStartDateForDemandRate_ = child_.text
            ApplicableStartDateForDemandRate_ = self.gds_validate_string(ApplicableStartDateForDemandRate_, node, 'ApplicableStartDateForDemandRate')
            self.ApplicableStartDateForDemandRate = ApplicableStartDateForDemandRate_
        elif nodeName_ == 'ApplicableEndDateForDemandRate':
            ApplicableEndDateForDemandRate_ = child_.text
            ApplicableEndDateForDemandRate_ = self.gds_validate_string(ApplicableEndDateForDemandRate_, node, 'ApplicableEndDateForDemandRate')
            self.ApplicableEndDateForDemandRate = ApplicableEndDateForDemandRate_
        elif nodeName_ == 'TimeOfUsePeriod':
            obj_ = TimeOfUsePeriodType.factory()
            obj_.build(child_)
            self.TimeOfUsePeriod.append(obj_)
            obj_.original_tagname_ = 'TimeOfUsePeriod'
        elif nodeName_ == 'EnergySellRate':
            obj_ = EnergySellRateType46.factory()
            obj_.build(child_)
            self.EnergySellRate = obj_
            obj_.original_tagname_ = 'EnergySellRate'
# end class RatePeriodType39


class TimeOfUsePeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TOUNumberForRateStructure=None, ApplicableStartTimeForEnergyRate=None, ApplicableEndTimeForEnergyRate=None, ApplicableStartTimeForDemandRate=None, ApplicableEndTimeForDemandRate=None, EnergyCostRate=None, ElectricDemandRate=None, EnergyRateAdjustment=None, DemandRateAdjustment=None, DemandWindow=None, DemandRatchetPercentage=None):
        self.original_tagname_ = None
        self.TOUNumberForRateStructure = TOUNumberForRateStructure
        self.ApplicableStartTimeForEnergyRate = ApplicableStartTimeForEnergyRate
        self.ApplicableEndTimeForEnergyRate = ApplicableEndTimeForEnergyRate
        self.ApplicableStartTimeForDemandRate = ApplicableStartTimeForDemandRate
        self.ApplicableEndTimeForDemandRate = ApplicableEndTimeForDemandRate
        self.EnergyCostRate = EnergyCostRate
        self.ElectricDemandRate = ElectricDemandRate
        self.EnergyRateAdjustment = EnergyRateAdjustment
        self.DemandRateAdjustment = DemandRateAdjustment
        self.DemandWindow = DemandWindow
        self.DemandRatchetPercentage = DemandRatchetPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeOfUsePeriodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeOfUsePeriodType.subclass:
            return TimeOfUsePeriodType.subclass(*args_, **kwargs_)
        else:
            return TimeOfUsePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.TOUNumberForRateStructure is not None or
            self.ApplicableStartTimeForEnergyRate is not None or
            self.ApplicableEndTimeForEnergyRate is not None or
            self.ApplicableStartTimeForDemandRate is not None or
            self.ApplicableEndTimeForDemandRate is not None or
            self.EnergyCostRate is not None or
            self.ElectricDemandRate is not None or
            self.EnergyRateAdjustment is not None or
            self.DemandRateAdjustment is not None or
            self.DemandWindow is not None or
            self.DemandRatchetPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TimeOfUsePeriodType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOfUsePeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TimeOfUsePeriodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TimeOfUsePeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TimeOfUsePeriodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TOUNumberForRateStructure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTOUNumberForRateStructure>%s</%sTOUNumberForRateStructure>%s' % (namespace_, self.gds_format_integer(self.TOUNumberForRateStructure, input_name='TOUNumberForRateStructure'), namespace_, eol_))
        if self.ApplicableStartTimeForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartTimeForEnergyRate>%s</%sApplicableStartTimeForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartTimeForEnergyRate), input_name='ApplicableStartTimeForEnergyRate')), namespace_, eol_))
        if self.ApplicableEndTimeForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndTimeForEnergyRate>%s</%sApplicableEndTimeForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndTimeForEnergyRate), input_name='ApplicableEndTimeForEnergyRate')), namespace_, eol_))
        if self.ApplicableStartTimeForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartTimeForDemandRate>%s</%sApplicableStartTimeForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartTimeForDemandRate), input_name='ApplicableStartTimeForDemandRate')), namespace_, eol_))
        if self.ApplicableEndTimeForDemandRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndTimeForDemandRate>%s</%sApplicableEndTimeForDemandRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndTimeForDemandRate), input_name='ApplicableEndTimeForDemandRate')), namespace_, eol_))
        if self.EnergyCostRate is not None:
            self.EnergyCostRate.export(outfile, level, namespace_, name_='EnergyCostRate', pretty_print=pretty_print)
        if self.ElectricDemandRate is not None:
            self.ElectricDemandRate.export(outfile, level, namespace_, name_='ElectricDemandRate', pretty_print=pretty_print)
        if self.EnergyRateAdjustment is not None:
            self.EnergyRateAdjustment.export(outfile, level, namespace_, name_='EnergyRateAdjustment', pretty_print=pretty_print)
        if self.DemandRateAdjustment is not None:
            self.DemandRateAdjustment.export(outfile, level, namespace_, name_='DemandRateAdjustment', pretty_print=pretty_print)
        if self.DemandWindow is not None:
            self.DemandWindow.export(outfile, level, namespace_, name_='DemandWindow', pretty_print=pretty_print)
        if self.DemandRatchetPercentage is not None:
            self.DemandRatchetPercentage.export(outfile, level, namespace_, name_='DemandRatchetPercentage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TOUNumberForRateStructure':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOUNumberForRateStructure')
            self.TOUNumberForRateStructure = ival_
        elif nodeName_ == 'ApplicableStartTimeForEnergyRate':
            ApplicableStartTimeForEnergyRate_ = child_.text
            ApplicableStartTimeForEnergyRate_ = self.gds_validate_string(ApplicableStartTimeForEnergyRate_, node, 'ApplicableStartTimeForEnergyRate')
            self.ApplicableStartTimeForEnergyRate = ApplicableStartTimeForEnergyRate_
        elif nodeName_ == 'ApplicableEndTimeForEnergyRate':
            ApplicableEndTimeForEnergyRate_ = child_.text
            ApplicableEndTimeForEnergyRate_ = self.gds_validate_string(ApplicableEndTimeForEnergyRate_, node, 'ApplicableEndTimeForEnergyRate')
            self.ApplicableEndTimeForEnergyRate = ApplicableEndTimeForEnergyRate_
        elif nodeName_ == 'ApplicableStartTimeForDemandRate':
            ApplicableStartTimeForDemandRate_ = child_.text
            ApplicableStartTimeForDemandRate_ = self.gds_validate_string(ApplicableStartTimeForDemandRate_, node, 'ApplicableStartTimeForDemandRate')
            self.ApplicableStartTimeForDemandRate = ApplicableStartTimeForDemandRate_
        elif nodeName_ == 'ApplicableEndTimeForDemandRate':
            ApplicableEndTimeForDemandRate_ = child_.text
            ApplicableEndTimeForDemandRate_ = self.gds_validate_string(ApplicableEndTimeForDemandRate_, node, 'ApplicableEndTimeForDemandRate')
            self.ApplicableEndTimeForDemandRate = ApplicableEndTimeForDemandRate_
        elif nodeName_ == 'EnergyCostRate':
            obj_ = EnergyCostRateType40.factory()
            obj_.build(child_)
            self.EnergyCostRate = obj_
            obj_.original_tagname_ = 'EnergyCostRate'
        elif nodeName_ == 'ElectricDemandRate':
            obj_ = ElectricDemandRateType41.factory()
            obj_.build(child_)
            self.ElectricDemandRate = obj_
            obj_.original_tagname_ = 'ElectricDemandRate'
        elif nodeName_ == 'EnergyRateAdjustment':
            obj_ = EnergyRateAdjustmentType42.factory()
            obj_.build(child_)
            self.EnergyRateAdjustment = obj_
            obj_.original_tagname_ = 'EnergyRateAdjustment'
        elif nodeName_ == 'DemandRateAdjustment':
            obj_ = DemandRateAdjustmentType43.factory()
            obj_.build(child_)
            self.DemandRateAdjustment = obj_
            obj_.original_tagname_ = 'DemandRateAdjustment'
        elif nodeName_ == 'DemandWindow':
            obj_ = DemandWindowType44.factory()
            obj_.build(child_)
            self.DemandWindow = obj_
            obj_.original_tagname_ = 'DemandWindow'
        elif nodeName_ == 'DemandRatchetPercentage':
            obj_ = DemandRatchetPercentageType45.factory()
            obj_.build(child_)
            self.DemandRatchetPercentage = obj_
            obj_.original_tagname_ = 'DemandRatchetPercentage'
# end class TimeOfUsePeriodType


class EnergyCostRateType40(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCostRateType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCostRateType40.subclass:
            return EnergyCostRateType40.subclass(*args_, **kwargs_)
        else:
            return EnergyCostRateType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType40', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyCostRateType40')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyCostRateType40', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyCostRateType40'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType40', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyCostRateType40


class ElectricDemandRateType41(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricDemandRateType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricDemandRateType41.subclass:
            return ElectricDemandRateType41.subclass(*args_, **kwargs_)
        else:
            return ElectricDemandRateType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType41', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricDemandRateType41')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricDemandRateType41', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricDemandRateType41'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType41', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricDemandRateType41


class EnergyRateAdjustmentType42(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyRateAdjustmentType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyRateAdjustmentType42.subclass:
            return EnergyRateAdjustmentType42.subclass(*args_, **kwargs_)
        else:
            return EnergyRateAdjustmentType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType42', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyRateAdjustmentType42')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyRateAdjustmentType42', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyRateAdjustmentType42'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType42', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyRateAdjustmentType42


class DemandRateAdjustmentType43(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRateAdjustmentType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRateAdjustmentType43.subclass:
            return DemandRateAdjustmentType43.subclass(*args_, **kwargs_)
        else:
            return DemandRateAdjustmentType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType43', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRateAdjustmentType43')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRateAdjustmentType43', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRateAdjustmentType43'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType43', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRateAdjustmentType43


class DemandWindowType44(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandWindowType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandWindowType44.subclass:
            return DemandWindowType44.subclass(*args_, **kwargs_)
        else:
            return DemandWindowType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandWindowType44', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandWindowType44')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandWindowType44', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandWindowType44'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandWindowType44', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandWindowType44


class DemandRatchetPercentageType45(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRatchetPercentageType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRatchetPercentageType45.subclass:
            return DemandRatchetPercentageType45.subclass(*args_, **kwargs_)
        else:
            return DemandRatchetPercentageType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType45', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRatchetPercentageType45')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRatchetPercentageType45', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRatchetPercentageType45'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType45', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRatchetPercentageType45


class EnergySellRateType46(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergySellRateType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergySellRateType46.subclass:
            return EnergySellRateType46.subclass(*args_, **kwargs_)
        else:
            return EnergySellRateType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergySellRateType46', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergySellRateType46')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergySellRateType46', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergySellRateType46'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergySellRateType46', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergySellRateType46


class TieredRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriod=None, TierDirection=None):
        self.original_tagname_ = None
        if RatePeriod is None:
            self.RatePeriod = []
        else:
            self.RatePeriod = RatePeriod
        self.TierDirection = TierDirection
        self.validate_TierDirectionType(self.TierDirection)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TieredRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TieredRateType.subclass:
            return TieredRateType.subclass(*args_, **kwargs_)
        else:
            return TieredRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_TierDirectionType(self, value):
        # Validate type TierDirectionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Increasing', 'Decreasing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TierDirectionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RatePeriod or
            self.TierDirection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TieredRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TieredRateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TieredRateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TieredRateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TieredRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RatePeriod_ in self.RatePeriod:
            RatePeriod_.export(outfile, level, namespace_, name_='RatePeriod', pretty_print=pretty_print)
        if self.TierDirection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTierDirection>%s</%sTierDirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TierDirection), input_name='TierDirection')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriod':
            obj_ = RatePeriodType47.factory()
            obj_.build(child_)
            self.RatePeriod.append(obj_)
            obj_.original_tagname_ = 'RatePeriod'
        elif nodeName_ == 'TierDirection':
            TierDirection_ = child_.text
            TierDirection_ = self.gds_validate_string(TierDirection_, node, 'TierDirection')
            self.TierDirection = TierDirection_
            # validate type TierDirectionType
            self.validate_TierDirectionType(self.TierDirection)
# end class TieredRateType


class RatePeriodType47(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatePeriodName=None, ApplicableStartDateForEnergyRate=None, ApplicableEndDateForEnergyRate=None, RateTier=None, EnergySellRate=None):
        self.original_tagname_ = None
        self.RatePeriodName = RatePeriodName
        self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate
        self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate
        if RateTier is None:
            self.RateTier = []
        else:
            self.RateTier = RateTier
        self.EnergySellRate = EnergySellRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatePeriodType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatePeriodType47.subclass:
            return RatePeriodType47.subclass(*args_, **kwargs_)
        else:
            return RatePeriodType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.RatePeriodName is not None or
            self.ApplicableStartDateForEnergyRate is not None or
            self.ApplicableEndDateForEnergyRate is not None or
            self.RateTier or
            self.EnergySellRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatePeriodType47', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatePeriodType47')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatePeriodType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatePeriodType47'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatePeriodType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RatePeriodName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRatePeriodName>%s</%sRatePeriodName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RatePeriodName), input_name='RatePeriodName')), namespace_, eol_))
        if self.ApplicableStartDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableStartDateForEnergyRate>%s</%sApplicableStartDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableStartDateForEnergyRate), input_name='ApplicableStartDateForEnergyRate')), namespace_, eol_))
        if self.ApplicableEndDateForEnergyRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplicableEndDateForEnergyRate>%s</%sApplicableEndDateForEnergyRate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ApplicableEndDateForEnergyRate), input_name='ApplicableEndDateForEnergyRate')), namespace_, eol_))
        for RateTier_ in self.RateTier:
            RateTier_.export(outfile, level, namespace_, name_='RateTier', pretty_print=pretty_print)
        if self.EnergySellRate is not None:
            self.EnergySellRate.export(outfile, level, namespace_, name_='EnergySellRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatePeriodName':
            RatePeriodName_ = child_.text
            RatePeriodName_ = self.gds_validate_string(RatePeriodName_, node, 'RatePeriodName')
            self.RatePeriodName = RatePeriodName_
        elif nodeName_ == 'ApplicableStartDateForEnergyRate':
            ApplicableStartDateForEnergyRate_ = child_.text
            ApplicableStartDateForEnergyRate_ = self.gds_validate_string(ApplicableStartDateForEnergyRate_, node, 'ApplicableStartDateForEnergyRate')
            self.ApplicableStartDateForEnergyRate = ApplicableStartDateForEnergyRate_
        elif nodeName_ == 'ApplicableEndDateForEnergyRate':
            ApplicableEndDateForEnergyRate_ = child_.text
            ApplicableEndDateForEnergyRate_ = self.gds_validate_string(ApplicableEndDateForEnergyRate_, node, 'ApplicableEndDateForEnergyRate')
            self.ApplicableEndDateForEnergyRate = ApplicableEndDateForEnergyRate_
        elif nodeName_ == 'RateTier':
            obj_ = RateTierType.factory()
            obj_.build(child_)
            self.RateTier.append(obj_)
            obj_.original_tagname_ = 'RateTier'
        elif nodeName_ == 'EnergySellRate':
            obj_ = EnergySellRateType54.factory()
            obj_.build(child_)
            self.EnergySellRate = obj_
            obj_.original_tagname_ = 'EnergySellRate'
# end class RatePeriodType47


class RateTierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConsumptionEnergyTierDesignation=None, MaxkWhUsage=None, MaxkWUsage=None, EnergyCostRate=None, ElectricDemandRate=None, EnergyRateAdjustment=None, DemandRateAdjustment=None, DemandWindow=None, DemandRatchetPercentage=None):
        self.original_tagname_ = None
        self.ConsumptionEnergyTierDesignation = ConsumptionEnergyTierDesignation
        self.MaxkWhUsage = MaxkWhUsage
        self.MaxkWUsage = MaxkWUsage
        self.EnergyCostRate = EnergyCostRate
        self.ElectricDemandRate = ElectricDemandRate
        self.EnergyRateAdjustment = EnergyRateAdjustment
        self.DemandRateAdjustment = DemandRateAdjustment
        self.DemandWindow = DemandWindow
        self.DemandRatchetPercentage = DemandRatchetPercentage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateTierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateTierType.subclass:
            return RateTierType.subclass(*args_, **kwargs_)
        else:
            return RateTierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ConsumptionEnergyTierDesignation is not None or
            self.MaxkWhUsage is not None or
            self.MaxkWUsage is not None or
            self.EnergyCostRate is not None or
            self.ElectricDemandRate is not None or
            self.EnergyRateAdjustment is not None or
            self.DemandRateAdjustment is not None or
            self.DemandWindow is not None or
            self.DemandRatchetPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RateTierType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateTierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RateTierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RateTierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RateTierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConsumptionEnergyTierDesignation is not None:
            self.ConsumptionEnergyTierDesignation.export(outfile, level, namespace_, name_='ConsumptionEnergyTierDesignation', pretty_print=pretty_print)
        if self.MaxkWhUsage is not None:
            self.MaxkWhUsage.export(outfile, level, namespace_, name_='MaxkWhUsage', pretty_print=pretty_print)
        if self.MaxkWUsage is not None:
            self.MaxkWUsage.export(outfile, level, namespace_, name_='MaxkWUsage', pretty_print=pretty_print)
        if self.EnergyCostRate is not None:
            self.EnergyCostRate.export(outfile, level, namespace_, name_='EnergyCostRate', pretty_print=pretty_print)
        if self.ElectricDemandRate is not None:
            self.ElectricDemandRate.export(outfile, level, namespace_, name_='ElectricDemandRate', pretty_print=pretty_print)
        if self.EnergyRateAdjustment is not None:
            self.EnergyRateAdjustment.export(outfile, level, namespace_, name_='EnergyRateAdjustment', pretty_print=pretty_print)
        if self.DemandRateAdjustment is not None:
            self.DemandRateAdjustment.export(outfile, level, namespace_, name_='DemandRateAdjustment', pretty_print=pretty_print)
        if self.DemandWindow is not None:
            self.DemandWindow.export(outfile, level, namespace_, name_='DemandWindow', pretty_print=pretty_print)
        if self.DemandRatchetPercentage is not None:
            self.DemandRatchetPercentage.export(outfile, level, namespace_, name_='DemandRatchetPercentage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConsumptionEnergyTierDesignation':
            obj_ = ConsumptionEnergyTierDesignationType.factory()
            obj_.build(child_)
            self.ConsumptionEnergyTierDesignation = obj_
            obj_.original_tagname_ = 'ConsumptionEnergyTierDesignation'
        elif nodeName_ == 'MaxkWhUsage':
            obj_ = MaxkWhUsageType.factory()
            obj_.build(child_)
            self.MaxkWhUsage = obj_
            obj_.original_tagname_ = 'MaxkWhUsage'
        elif nodeName_ == 'MaxkWUsage':
            obj_ = MaxkWUsageType.factory()
            obj_.build(child_)
            self.MaxkWUsage = obj_
            obj_.original_tagname_ = 'MaxkWUsage'
        elif nodeName_ == 'EnergyCostRate':
            obj_ = EnergyCostRateType48.factory()
            obj_.build(child_)
            self.EnergyCostRate = obj_
            obj_.original_tagname_ = 'EnergyCostRate'
        elif nodeName_ == 'ElectricDemandRate':
            obj_ = ElectricDemandRateType49.factory()
            obj_.build(child_)
            self.ElectricDemandRate = obj_
            obj_.original_tagname_ = 'ElectricDemandRate'
        elif nodeName_ == 'EnergyRateAdjustment':
            obj_ = EnergyRateAdjustmentType50.factory()
            obj_.build(child_)
            self.EnergyRateAdjustment = obj_
            obj_.original_tagname_ = 'EnergyRateAdjustment'
        elif nodeName_ == 'DemandRateAdjustment':
            obj_ = DemandRateAdjustmentType51.factory()
            obj_.build(child_)
            self.DemandRateAdjustment = obj_
            obj_.original_tagname_ = 'DemandRateAdjustment'
        elif nodeName_ == 'DemandWindow':
            obj_ = DemandWindowType52.factory()
            obj_.build(child_)
            self.DemandWindow = obj_
            obj_.original_tagname_ = 'DemandWindow'
        elif nodeName_ == 'DemandRatchetPercentage':
            obj_ = DemandRatchetPercentageType53.factory()
            obj_.build(child_)
            self.DemandRatchetPercentage = obj_
            obj_.original_tagname_ = 'DemandRatchetPercentage'
# end class RateTierType


class ConsumptionEnergyTierDesignationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsumptionEnergyTierDesignationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsumptionEnergyTierDesignationType.subclass:
            return ConsumptionEnergyTierDesignationType.subclass(*args_, **kwargs_)
        else:
            return ConsumptionEnergyTierDesignationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConsumptionEnergyTierDesignationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionEnergyTierDesignationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConsumptionEnergyTierDesignationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConsumptionEnergyTierDesignationType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConsumptionEnergyTierDesignationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConsumptionEnergyTierDesignationType


class MaxkWhUsageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaxkWhUsageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaxkWhUsageType.subclass:
            return MaxkWhUsageType.subclass(*args_, **kwargs_)
        else:
            return MaxkWhUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MaxkWhUsageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaxkWhUsageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MaxkWhUsageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MaxkWhUsageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MaxkWhUsageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MaxkWhUsageType


class MaxkWUsageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaxkWUsageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaxkWUsageType.subclass:
            return MaxkWUsageType.subclass(*args_, **kwargs_)
        else:
            return MaxkWUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MaxkWUsageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaxkWUsageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MaxkWUsageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MaxkWUsageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MaxkWUsageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MaxkWUsageType


class EnergyCostRateType48(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCostRateType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCostRateType48.subclass:
            return EnergyCostRateType48.subclass(*args_, **kwargs_)
        else:
            return EnergyCostRateType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType48', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyCostRateType48')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyCostRateType48', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyCostRateType48'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyCostRateType48', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyCostRateType48


class ElectricDemandRateType49(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricDemandRateType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricDemandRateType49.subclass:
            return ElectricDemandRateType49.subclass(*args_, **kwargs_)
        else:
            return ElectricDemandRateType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType49', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricDemandRateType49')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricDemandRateType49', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricDemandRateType49'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricDemandRateType49', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricDemandRateType49


class EnergyRateAdjustmentType50(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyRateAdjustmentType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyRateAdjustmentType50.subclass:
            return EnergyRateAdjustmentType50.subclass(*args_, **kwargs_)
        else:
            return EnergyRateAdjustmentType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType50', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyRateAdjustmentType50')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyRateAdjustmentType50', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyRateAdjustmentType50'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyRateAdjustmentType50', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyRateAdjustmentType50


class DemandRateAdjustmentType51(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRateAdjustmentType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRateAdjustmentType51.subclass:
            return DemandRateAdjustmentType51.subclass(*args_, **kwargs_)
        else:
            return DemandRateAdjustmentType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType51', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRateAdjustmentType51')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRateAdjustmentType51', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRateAdjustmentType51'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRateAdjustmentType51', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRateAdjustmentType51


class DemandWindowType52(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandWindowType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandWindowType52.subclass:
            return DemandWindowType52.subclass(*args_, **kwargs_)
        else:
            return DemandWindowType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandWindowType52', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandWindowType52')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandWindowType52', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandWindowType52'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandWindowType52', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandWindowType52


class DemandRatchetPercentageType53(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandRatchetPercentageType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandRatchetPercentageType53.subclass:
            return DemandRatchetPercentageType53.subclass(*args_, **kwargs_)
        else:
            return DemandRatchetPercentageType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType53', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandRatchetPercentageType53')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DemandRatchetPercentageType53', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DemandRatchetPercentageType53'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DemandRatchetPercentageType53', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DemandRatchetPercentageType53


class EnergySellRateType54(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergySellRateType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergySellRateType54.subclass:
            return EnergySellRateType54.subclass(*args_, **kwargs_)
        else:
            return EnergySellRateType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergySellRateType54', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergySellRateType54')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergySellRateType54', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergySellRateType54'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergySellRateType54', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergySellRateType54


class ReactivePowerChargeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReactivePowerChargeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReactivePowerChargeType.subclass:
            return ReactivePowerChargeType.subclass(*args_, **kwargs_)
        else:
            return ReactivePowerChargeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ReactivePowerChargeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReactivePowerChargeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ReactivePowerChargeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ReactivePowerChargeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ReactivePowerChargeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReactivePowerChargeType


class MinimumPowerFactorWithoutPenaltyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumPowerFactorWithoutPenaltyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumPowerFactorWithoutPenaltyType.subclass:
            return MinimumPowerFactorWithoutPenaltyType.subclass(*args_, **kwargs_)
        else:
            return MinimumPowerFactorWithoutPenaltyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumPowerFactorWithoutPenaltyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumPowerFactorWithoutPenaltyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumPowerFactorWithoutPenaltyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumPowerFactorWithoutPenaltyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumPowerFactorWithoutPenaltyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumPowerFactorWithoutPenaltyType


class FixedMonthlyChargeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedMonthlyChargeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedMonthlyChargeType.subclass:
            return FixedMonthlyChargeType.subclass(*args_, **kwargs_)
        else:
            return FixedMonthlyChargeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FixedMonthlyChargeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedMonthlyChargeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FixedMonthlyChargeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FixedMonthlyChargeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FixedMonthlyChargeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FixedMonthlyChargeType


class NetMeteringType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetMeteringType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetMeteringType.subclass:
            return NetMeteringType.subclass(*args_, **kwargs_)
        else:
            return NetMeteringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetMeteringType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetMeteringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetMeteringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetMeteringType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetMeteringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType55.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class NetMeteringType


class TrueType55(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AverageMarginalSellRate=None):
        self.original_tagname_ = None
        self.AverageMarginalSellRate = AverageMarginalSellRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType55.subclass:
            return TrueType55.subclass(*args_, **kwargs_)
        else:
            return TrueType55(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AverageMarginalSellRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType55', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType55')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType55', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType55'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType55', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AverageMarginalSellRate is not None:
            self.AverageMarginalSellRate.export(outfile, level, namespace_, name_='AverageMarginalSellRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AverageMarginalSellRate':
            obj_ = AverageMarginalSellRateType.factory()
            obj_.build(child_)
            self.AverageMarginalSellRate = obj_
            obj_.original_tagname_ = 'AverageMarginalSellRate'
# end class TrueType55


class AverageMarginalSellRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AverageMarginalSellRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AverageMarginalSellRateType.subclass:
            return AverageMarginalSellRateType.subclass(*args_, **kwargs_)
        else:
            return AverageMarginalSellRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AverageMarginalSellRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageMarginalSellRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AverageMarginalSellRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AverageMarginalSellRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AverageMarginalSellRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AverageMarginalSellRateType


class AverageMarginalCostRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AverageMarginalCostRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AverageMarginalCostRateType.subclass:
            return AverageMarginalCostRateType.subclass(*args_, **kwargs_)
        else:
            return AverageMarginalCostRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AverageMarginalCostRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AverageMarginalCostRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AverageMarginalCostRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AverageMarginalCostRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AverageMarginalCostRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AverageMarginalCostRateType


class SourceSiteRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceSiteRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceSiteRatioType.subclass:
            return SourceSiteRatioType.subclass(*args_, **kwargs_)
        else:
            return SourceSiteRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceSiteRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceSiteRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceSiteRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceSiteRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceSiteRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceSiteRatioType


class EmissionsType56(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EmissionBoundary=None, EmissionsType=None, EmissionsFactor=None, EmissionsFactorSource=None, GHGEmissions=None, AvoidedEmissions=None):
        self.original_tagname_ = None
        self.EmissionBoundary = EmissionBoundary
        self.validate_EmissionBoundaryType(self.EmissionBoundary)
        self.EmissionsType = EmissionsType
        self.validate_EmissionsTypeType(self.EmissionsType)
        self.EmissionsFactor = EmissionsFactor
        self.EmissionsFactorSource = EmissionsFactorSource
        self.validate_EmissionsFactorSourceType(self.EmissionsFactorSource)
        self.GHGEmissions = GHGEmissions
        self.AvoidedEmissions = AvoidedEmissions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmissionsType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmissionsType56.subclass:
            return EmissionsType56.subclass(*args_, **kwargs_)
        else:
            return EmissionsType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EmissionBoundaryType(self, value):
        # Validate type EmissionBoundaryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Direct', 'Indirect', 'Net', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EmissionBoundaryType' % {"value" : value.encode("utf-8")} )
    def validate_EmissionsTypeType(self, value):
        # Validate type EmissionsTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Co2e', 'Co2', 'CH4', 'N2O', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EmissionsTypeType' % {"value" : value.encode("utf-8")} )
    def validate_EmissionsFactorSourceType(self, value):
        # Validate type EmissionsFactorSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EIA (US Energy Information Administration)', 'EPA (US Environmental Protection Agency)', 'Utility', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EmissionsFactorSourceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EmissionBoundary is not None or
            self.EmissionsType is not None or
            self.EmissionsFactor is not None or
            self.EmissionsFactorSource is not None or
            self.GHGEmissions is not None or
            self.AvoidedEmissions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EmissionsType56', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmissionsType56')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EmissionsType56', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EmissionsType56'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EmissionsType56', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EmissionBoundary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmissionBoundary>%s</%sEmissionBoundary>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EmissionBoundary), input_name='EmissionBoundary')), namespace_, eol_))
        if self.EmissionsType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmissionsType>%s</%sEmissionsType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EmissionsType), input_name='EmissionsType')), namespace_, eol_))
        if self.EmissionsFactor is not None:
            self.EmissionsFactor.export(outfile, level, namespace_, name_='EmissionsFactor', pretty_print=pretty_print)
        if self.EmissionsFactorSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmissionsFactorSource>%s</%sEmissionsFactorSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EmissionsFactorSource), input_name='EmissionsFactorSource')), namespace_, eol_))
        if self.GHGEmissions is not None:
            self.GHGEmissions.export(outfile, level, namespace_, name_='GHGEmissions', pretty_print=pretty_print)
        if self.AvoidedEmissions is not None:
            self.AvoidedEmissions.export(outfile, level, namespace_, name_='AvoidedEmissions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmissionBoundary':
            EmissionBoundary_ = child_.text
            EmissionBoundary_ = self.gds_validate_string(EmissionBoundary_, node, 'EmissionBoundary')
            self.EmissionBoundary = EmissionBoundary_
            # validate type EmissionBoundaryType
            self.validate_EmissionBoundaryType(self.EmissionBoundary)
        elif nodeName_ == 'EmissionsType':
            EmissionsType_ = child_.text
            EmissionsType_ = self.gds_validate_string(EmissionsType_, node, 'EmissionsType')
            self.EmissionsType = EmissionsType_
            # validate type EmissionsTypeType
            self.validate_EmissionsTypeType(self.EmissionsType)
        elif nodeName_ == 'EmissionsFactor':
            obj_ = EmissionsFactorType.factory()
            obj_.build(child_)
            self.EmissionsFactor = obj_
            obj_.original_tagname_ = 'EmissionsFactor'
        elif nodeName_ == 'EmissionsFactorSource':
            EmissionsFactorSource_ = child_.text
            EmissionsFactorSource_ = self.gds_validate_string(EmissionsFactorSource_, node, 'EmissionsFactorSource')
            self.EmissionsFactorSource = EmissionsFactorSource_
            # validate type EmissionsFactorSourceType
            self.validate_EmissionsFactorSourceType(self.EmissionsFactorSource)
        elif nodeName_ == 'GHGEmissions':
            obj_ = GHGEmissionsType.factory()
            obj_.build(child_)
            self.GHGEmissions = obj_
            obj_.original_tagname_ = 'GHGEmissions'
        elif nodeName_ == 'AvoidedEmissions':
            obj_ = AvoidedEmissionsType.factory()
            obj_.build(child_)
            self.AvoidedEmissions = obj_
            obj_.original_tagname_ = 'AvoidedEmissions'
# end class EmissionsType56


class EmissionsFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmissionsFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmissionsFactorType.subclass:
            return EmissionsFactorType.subclass(*args_, **kwargs_)
        else:
            return EmissionsFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EmissionsFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmissionsFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EmissionsFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EmissionsFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EmissionsFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmissionsFactorType


class GHGEmissionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GHGEmissionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GHGEmissionsType.subclass:
            return GHGEmissionsType.subclass(*args_, **kwargs_)
        else:
            return GHGEmissionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GHGEmissionsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GHGEmissionsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GHGEmissionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GHGEmissionsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GHGEmissionsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GHGEmissionsType


class AvoidedEmissionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AvoidedEmissionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AvoidedEmissionsType.subclass:
            return AvoidedEmissionsType.subclass(*args_, **kwargs_)
        else:
            return AvoidedEmissionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AvoidedEmissionsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AvoidedEmissionsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AvoidedEmissionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AvoidedEmissionsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AvoidedEmissionsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AvoidedEmissionsType


class SiteEnergyUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SiteEnergyUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SiteEnergyUseType.subclass:
            return SiteEnergyUseType.subclass(*args_, **kwargs_)
        else:
            return SiteEnergyUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteEnergyUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SiteEnergyUseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SiteEnergyUseType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SiteEnergyUseType


class SiteEnergyUseIntensityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SiteEnergyUseIntensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SiteEnergyUseIntensityType.subclass:
            return SiteEnergyUseIntensityType.subclass(*args_, **kwargs_)
        else:
            return SiteEnergyUseIntensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseIntensityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteEnergyUseIntensityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SiteEnergyUseIntensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SiteEnergyUseIntensityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseIntensityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SiteEnergyUseIntensityType


class SourceEnergyUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceEnergyUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceEnergyUseType.subclass:
            return SourceEnergyUseType.subclass(*args_, **kwargs_)
        else:
            return SourceEnergyUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceEnergyUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceEnergyUseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceEnergyUseType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceEnergyUseType


class SourceEnergyUseIntensityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceEnergyUseIntensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceEnergyUseIntensityType.subclass:
            return SourceEnergyUseIntensityType.subclass(*args_, **kwargs_)
        else:
            return SourceEnergyUseIntensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseIntensityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceEnergyUseIntensityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceEnergyUseIntensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceEnergyUseIntensityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseIntensityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceEnergyUseIntensityType


class EnergyCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCostType.subclass:
            return EnergyCostType.subclass(*args_, **kwargs_)
        else:
            return EnergyCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyCostType


class OnsiteRenewableSystemElectricityExportedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnsiteRenewableSystemElectricityExportedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnsiteRenewableSystemElectricityExportedType.subclass:
            return OnsiteRenewableSystemElectricityExportedType.subclass(*args_, **kwargs_)
        else:
            return OnsiteRenewableSystemElectricityExportedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OnsiteRenewableSystemElectricityExportedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnsiteRenewableSystemElectricityExportedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OnsiteRenewableSystemElectricityExportedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OnsiteRenewableSystemElectricityExportedType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OnsiteRenewableSystemElectricityExportedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OnsiteRenewableSystemElectricityExportedType


class ElectricitySourcedFromOnsiteRenewableSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricitySourcedFromOnsiteRenewableSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricitySourcedFromOnsiteRenewableSystemsType.subclass:
            return ElectricitySourcedFromOnsiteRenewableSystemsType.subclass(*args_, **kwargs_)
        else:
            return ElectricitySourcedFromOnsiteRenewableSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricitySourcedFromOnsiteRenewableSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricitySourcedFromOnsiteRenewableSystemsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricitySourcedFromOnsiteRenewableSystemsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricitySourcedFromOnsiteRenewableSystemsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricitySourcedFromOnsiteRenewableSystemsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricitySourcedFromOnsiteRenewableSystemsType


class SummerPeakType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummerPeakType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummerPeakType.subclass:
            return SummerPeakType.subclass(*args_, **kwargs_)
        else:
            return SummerPeakType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SummerPeakType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SummerPeakType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SummerPeakType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SummerPeakType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SummerPeakType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SummerPeakType


class WinterPeakType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WinterPeakType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WinterPeakType.subclass:
            return WinterPeakType.subclass(*args_, **kwargs_)
        else:
            return WinterPeakType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WinterPeakType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WinterPeakType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WinterPeakType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WinterPeakType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WinterPeakType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WinterPeakType


class WaterUseType57(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterUseType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterUseType57.subclass:
            return WaterUseType57.subclass(*args_, **kwargs_)
        else:
            return WaterUseType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterUseType57', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterUseType57')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterUseType57', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterUseType57'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterUseType57', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterUseType57


class WaterIntensityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterIntensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterIntensityType.subclass:
            return WaterIntensityType.subclass(*args_, **kwargs_)
        else:
            return WaterIntensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterIntensityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterIntensityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterIntensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterIntensityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterIntensityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterIntensityType


class WaterCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterCostType.subclass:
            return WaterCostType.subclass(*args_, **kwargs_)
        else:
            return WaterCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterCostType


class WasteWaterVolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WasteWaterVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WasteWaterVolumeType.subclass:
            return WasteWaterVolumeType.subclass(*args_, **kwargs_)
        else:
            return WasteWaterVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WasteWaterVolumeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasteWaterVolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WasteWaterVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WasteWaterVolumeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WasteWaterVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WasteWaterVolumeType


class IntervalReadingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntervalReadingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntervalReadingType.subclass:
            return IntervalReadingType.subclass(*args_, **kwargs_)
        else:
            return IntervalReadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IntervalReadingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntervalReadingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IntervalReadingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IntervalReadingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IntervalReadingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IntervalReadingType


class HeatingDegreeDaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingDegreeDaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingDegreeDaysType.subclass:
            return HeatingDegreeDaysType.subclass(*args_, **kwargs_)
        else:
            return HeatingDegreeDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingDegreeDaysType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingDegreeDaysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingDegreeDaysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingDegreeDaysType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingDegreeDaysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingDegreeDaysType


class CoolingDegreeDaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingDegreeDaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingDegreeDaysType.subclass:
            return CoolingDegreeDaysType.subclass(*args_, **kwargs_)
        else:
            return CoolingDegreeDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingDegreeDaysType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingDegreeDaysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingDegreeDaysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingDegreeDaysType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingDegreeDaysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingDegreeDaysType


class HDDBaseTemperatureType58(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HDDBaseTemperatureType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HDDBaseTemperatureType58.subclass:
            return HDDBaseTemperatureType58.subclass(*args_, **kwargs_)
        else:
            return HDDBaseTemperatureType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HDDBaseTemperatureType58', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HDDBaseTemperatureType58')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HDDBaseTemperatureType58', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HDDBaseTemperatureType58'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HDDBaseTemperatureType58', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HDDBaseTemperatureType58


class CDDBaseTemperatureType59(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CDDBaseTemperatureType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CDDBaseTemperatureType59.subclass:
            return CDDBaseTemperatureType59.subclass(*args_, **kwargs_)
        else:
            return CDDBaseTemperatureType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CDDBaseTemperatureType59', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CDDBaseTemperatureType59')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CDDBaseTemperatureType59', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CDDBaseTemperatureType59'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CDDBaseTemperatureType59', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CDDBaseTemperatureType59


class ResourceUseIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceUseIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceUseIDType.subclass:
            return ResourceUseIDType.subclass(*args_, **kwargs_)
        else:
            return ResourceUseIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResourceUseIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceUseIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResourceUseIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResourceUseIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResourceUseIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResourceUseIDType


class TypeOfMeasureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Replacement=None, ModificationRetrocommissioning=None, Addition=None, Removal=None):
        self.original_tagname_ = None
        self.Replacement = Replacement
        self.ModificationRetrocommissioning = ModificationRetrocommissioning
        self.Addition = Addition
        self.Removal = Removal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TypeOfMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TypeOfMeasureType.subclass:
            return TypeOfMeasureType.subclass(*args_, **kwargs_)
        else:
            return TypeOfMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Replacement is not None or
            self.ModificationRetrocommissioning is not None or
            self.Addition is not None or
            self.Removal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TypeOfMeasureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeOfMeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TypeOfMeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TypeOfMeasureType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TypeOfMeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Replacement is not None:
            self.Replacement.export(outfile, level, namespace_, name_='Replacement', pretty_print=pretty_print)
        if self.ModificationRetrocommissioning is not None:
            self.ModificationRetrocommissioning.export(outfile, level, namespace_, name_='ModificationRetrocommissioning', pretty_print=pretty_print)
        if self.Addition is not None:
            self.Addition.export(outfile, level, namespace_, name_='Addition', pretty_print=pretty_print)
        if self.Removal is not None:
            self.Removal.export(outfile, level, namespace_, name_='Removal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Replacement':
            obj_ = ReplacementType.factory()
            obj_.build(child_)
            self.Replacement = obj_
            obj_.original_tagname_ = 'Replacement'
        elif nodeName_ == 'ModificationRetrocommissioning':
            obj_ = ModificationRetrocommissioningType.factory()
            obj_.build(child_)
            self.ModificationRetrocommissioning = obj_
            obj_.original_tagname_ = 'ModificationRetrocommissioning'
        elif nodeName_ == 'Addition':
            obj_ = AdditionType.factory()
            obj_.build(child_)
            self.Addition = obj_
            obj_.original_tagname_ = 'Addition'
        elif nodeName_ == 'Removal':
            obj_ = RemovalType.factory()
            obj_.build(child_)
            self.Removal = obj_
            obj_.original_tagname_ = 'Removal'
# end class TypeOfMeasureType


class ReplacementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExistingSystemReplaced=None, AlternativeSystemReplacement=None, ExistingScheduleAffected=None, ModifiedSchedule=None):
        self.original_tagname_ = None
        if ExistingSystemReplaced is None:
            self.ExistingSystemReplaced = []
        else:
            self.ExistingSystemReplaced = ExistingSystemReplaced
        if AlternativeSystemReplacement is None:
            self.AlternativeSystemReplacement = []
        else:
            self.AlternativeSystemReplacement = AlternativeSystemReplacement
        if ExistingScheduleAffected is None:
            self.ExistingScheduleAffected = []
        else:
            self.ExistingScheduleAffected = ExistingScheduleAffected
        if ModifiedSchedule is None:
            self.ModifiedSchedule = []
        else:
            self.ModifiedSchedule = ModifiedSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReplacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReplacementType.subclass:
            return ReplacementType.subclass(*args_, **kwargs_)
        else:
            return ReplacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ExistingSystemReplaced or
            self.AlternativeSystemReplacement or
            self.ExistingScheduleAffected or
            self.ModifiedSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ReplacementType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReplacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ReplacementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ReplacementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ReplacementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExistingSystemReplaced_ in self.ExistingSystemReplaced:
            ExistingSystemReplaced_.export(outfile, level, namespace_, name_='ExistingSystemReplaced', pretty_print=pretty_print)
        for AlternativeSystemReplacement_ in self.AlternativeSystemReplacement:
            AlternativeSystemReplacement_.export(outfile, level, namespace_, name_='AlternativeSystemReplacement', pretty_print=pretty_print)
        for ExistingScheduleAffected_ in self.ExistingScheduleAffected:
            ExistingScheduleAffected_.export(outfile, level, namespace_, name_='ExistingScheduleAffected', pretty_print=pretty_print)
        for ModifiedSchedule_ in self.ModifiedSchedule:
            ModifiedSchedule_.export(outfile, level, namespace_, name_='ModifiedSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExistingSystemReplaced':
            obj_ = ExistingSystemReplacedType.factory()
            obj_.build(child_)
            self.ExistingSystemReplaced.append(obj_)
            obj_.original_tagname_ = 'ExistingSystemReplaced'
        elif nodeName_ == 'AlternativeSystemReplacement':
            obj_ = AlternativeSystemReplacementType.factory()
            obj_.build(child_)
            self.AlternativeSystemReplacement.append(obj_)
            obj_.original_tagname_ = 'AlternativeSystemReplacement'
        elif nodeName_ == 'ExistingScheduleAffected':
            obj_ = ExistingScheduleAffectedType.factory()
            obj_.build(child_)
            self.ExistingScheduleAffected.append(obj_)
            obj_.original_tagname_ = 'ExistingScheduleAffected'
        elif nodeName_ == 'ModifiedSchedule':
            obj_ = ModifiedScheduleType.factory()
            obj_.build(child_)
            self.ModifiedSchedule.append(obj_)
            obj_.original_tagname_ = 'ModifiedSchedule'
# end class ReplacementType


class ExistingSystemReplacedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingSystemReplacedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingSystemReplacedType.subclass:
            return ExistingSystemReplacedType.subclass(*args_, **kwargs_)
        else:
            return ExistingSystemReplacedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingSystemReplacedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingSystemReplacedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingSystemReplacedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingSystemReplacedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingSystemReplacedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingSystemReplacedType


class AlternativeSystemReplacementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlternativeSystemReplacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlternativeSystemReplacementType.subclass:
            return AlternativeSystemReplacementType.subclass(*args_, **kwargs_)
        else:
            return AlternativeSystemReplacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AlternativeSystemReplacementType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeSystemReplacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AlternativeSystemReplacementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AlternativeSystemReplacementType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AlternativeSystemReplacementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AlternativeSystemReplacementType


class ExistingScheduleAffectedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingScheduleAffectedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingScheduleAffectedType.subclass:
            return ExistingScheduleAffectedType.subclass(*args_, **kwargs_)
        else:
            return ExistingScheduleAffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingScheduleAffectedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingScheduleAffectedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingScheduleAffectedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingScheduleAffectedType


class ModifiedScheduleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModifiedScheduleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModifiedScheduleType.subclass:
            return ModifiedScheduleType.subclass(*args_, **kwargs_)
        else:
            return ModifiedScheduleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModifiedScheduleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModifiedScheduleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModifiedScheduleType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModifiedScheduleType


class ModificationRetrocommissioningType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExistingSystemAffected=None, ModifiedSystem=None, ExistingScheduleAffected=None, ModifiedSchedule=None):
        self.original_tagname_ = None
        if ExistingSystemAffected is None:
            self.ExistingSystemAffected = []
        else:
            self.ExistingSystemAffected = ExistingSystemAffected
        if ModifiedSystem is None:
            self.ModifiedSystem = []
        else:
            self.ModifiedSystem = ModifiedSystem
        if ExistingScheduleAffected is None:
            self.ExistingScheduleAffected = []
        else:
            self.ExistingScheduleAffected = ExistingScheduleAffected
        if ModifiedSchedule is None:
            self.ModifiedSchedule = []
        else:
            self.ModifiedSchedule = ModifiedSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModificationRetrocommissioningType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModificationRetrocommissioningType.subclass:
            return ModificationRetrocommissioningType.subclass(*args_, **kwargs_)
        else:
            return ModificationRetrocommissioningType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ExistingSystemAffected or
            self.ModifiedSystem or
            self.ExistingScheduleAffected or
            self.ModifiedSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModificationRetrocommissioningType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModificationRetrocommissioningType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModificationRetrocommissioningType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModificationRetrocommissioningType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModificationRetrocommissioningType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExistingSystemAffected_ in self.ExistingSystemAffected:
            ExistingSystemAffected_.export(outfile, level, namespace_, name_='ExistingSystemAffected', pretty_print=pretty_print)
        for ModifiedSystem_ in self.ModifiedSystem:
            ModifiedSystem_.export(outfile, level, namespace_, name_='ModifiedSystem', pretty_print=pretty_print)
        for ExistingScheduleAffected_ in self.ExistingScheduleAffected:
            ExistingScheduleAffected_.export(outfile, level, namespace_, name_='ExistingScheduleAffected', pretty_print=pretty_print)
        for ModifiedSchedule_ in self.ModifiedSchedule:
            ModifiedSchedule_.export(outfile, level, namespace_, name_='ModifiedSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExistingSystemAffected':
            obj_ = ExistingSystemAffectedType.factory()
            obj_.build(child_)
            self.ExistingSystemAffected.append(obj_)
            obj_.original_tagname_ = 'ExistingSystemAffected'
        elif nodeName_ == 'ModifiedSystem':
            obj_ = ModifiedSystemType.factory()
            obj_.build(child_)
            self.ModifiedSystem.append(obj_)
            obj_.original_tagname_ = 'ModifiedSystem'
        elif nodeName_ == 'ExistingScheduleAffected':
            obj_ = ExistingScheduleAffectedType60.factory()
            obj_.build(child_)
            self.ExistingScheduleAffected.append(obj_)
            obj_.original_tagname_ = 'ExistingScheduleAffected'
        elif nodeName_ == 'ModifiedSchedule':
            obj_ = ModifiedScheduleType61.factory()
            obj_.build(child_)
            self.ModifiedSchedule.append(obj_)
            obj_.original_tagname_ = 'ModifiedSchedule'
# end class ModificationRetrocommissioningType


class ExistingSystemAffectedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingSystemAffectedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingSystemAffectedType.subclass:
            return ExistingSystemAffectedType.subclass(*args_, **kwargs_)
        else:
            return ExistingSystemAffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingSystemAffectedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingSystemAffectedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingSystemAffectedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingSystemAffectedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingSystemAffectedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingSystemAffectedType


class ModifiedSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModifiedSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModifiedSystemType.subclass:
            return ModifiedSystemType.subclass(*args_, **kwargs_)
        else:
            return ModifiedSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModifiedSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModifiedSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModifiedSystemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModifiedSystemType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModifiedSystemType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModifiedSystemType


class ExistingScheduleAffectedType60(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingScheduleAffectedType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingScheduleAffectedType60.subclass:
            return ExistingScheduleAffectedType60.subclass(*args_, **kwargs_)
        else:
            return ExistingScheduleAffectedType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType60', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingScheduleAffectedType60')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingScheduleAffectedType60', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingScheduleAffectedType60'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType60', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingScheduleAffectedType60


class ModifiedScheduleType61(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModifiedScheduleType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModifiedScheduleType61.subclass:
            return ModifiedScheduleType61.subclass(*args_, **kwargs_)
        else:
            return ModifiedScheduleType61(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType61', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModifiedScheduleType61')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModifiedScheduleType61', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModifiedScheduleType61'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType61', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModifiedScheduleType61


class AdditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AlternativeSystemAdded=None, ExistingScheduleAffected=None, ModifiedSchedule=None):
        self.original_tagname_ = None
        if AlternativeSystemAdded is None:
            self.AlternativeSystemAdded = []
        else:
            self.AlternativeSystemAdded = AlternativeSystemAdded
        if ExistingScheduleAffected is None:
            self.ExistingScheduleAffected = []
        else:
            self.ExistingScheduleAffected = ExistingScheduleAffected
        if ModifiedSchedule is None:
            self.ModifiedSchedule = []
        else:
            self.ModifiedSchedule = ModifiedSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionType.subclass:
            return AdditionType.subclass(*args_, **kwargs_)
        else:
            return AdditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AlternativeSystemAdded or
            self.ExistingScheduleAffected or
            self.ModifiedSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AdditionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AdditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AdditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AdditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AlternativeSystemAdded_ in self.AlternativeSystemAdded:
            AlternativeSystemAdded_.export(outfile, level, namespace_, name_='AlternativeSystemAdded', pretty_print=pretty_print)
        for ExistingScheduleAffected_ in self.ExistingScheduleAffected:
            ExistingScheduleAffected_.export(outfile, level, namespace_, name_='ExistingScheduleAffected', pretty_print=pretty_print)
        for ModifiedSchedule_ in self.ModifiedSchedule:
            ModifiedSchedule_.export(outfile, level, namespace_, name_='ModifiedSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AlternativeSystemAdded':
            obj_ = AlternativeSystemAddedType.factory()
            obj_.build(child_)
            self.AlternativeSystemAdded.append(obj_)
            obj_.original_tagname_ = 'AlternativeSystemAdded'
        elif nodeName_ == 'ExistingScheduleAffected':
            obj_ = ExistingScheduleAffectedType62.factory()
            obj_.build(child_)
            self.ExistingScheduleAffected.append(obj_)
            obj_.original_tagname_ = 'ExistingScheduleAffected'
        elif nodeName_ == 'ModifiedSchedule':
            obj_ = ModifiedScheduleType63.factory()
            obj_.build(child_)
            self.ModifiedSchedule.append(obj_)
            obj_.original_tagname_ = 'ModifiedSchedule'
# end class AdditionType


class AlternativeSystemAddedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlternativeSystemAddedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlternativeSystemAddedType.subclass:
            return AlternativeSystemAddedType.subclass(*args_, **kwargs_)
        else:
            return AlternativeSystemAddedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AlternativeSystemAddedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeSystemAddedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AlternativeSystemAddedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AlternativeSystemAddedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AlternativeSystemAddedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AlternativeSystemAddedType


class ExistingScheduleAffectedType62(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingScheduleAffectedType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingScheduleAffectedType62.subclass:
            return ExistingScheduleAffectedType62.subclass(*args_, **kwargs_)
        else:
            return ExistingScheduleAffectedType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType62', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingScheduleAffectedType62')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingScheduleAffectedType62', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingScheduleAffectedType62'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType62', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingScheduleAffectedType62


class ModifiedScheduleType63(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModifiedScheduleType63)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModifiedScheduleType63.subclass:
            return ModifiedScheduleType63.subclass(*args_, **kwargs_)
        else:
            return ModifiedScheduleType63(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType63', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModifiedScheduleType63')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModifiedScheduleType63', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModifiedScheduleType63'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType63', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModifiedScheduleType63


class RemovalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExistingSystemRemoved=None, ExistingScheduleAffected=None, ModifiedSchedule=None):
        self.original_tagname_ = None
        if ExistingSystemRemoved is None:
            self.ExistingSystemRemoved = []
        else:
            self.ExistingSystemRemoved = ExistingSystemRemoved
        if ExistingScheduleAffected is None:
            self.ExistingScheduleAffected = []
        else:
            self.ExistingScheduleAffected = ExistingScheduleAffected
        if ModifiedSchedule is None:
            self.ModifiedSchedule = []
        else:
            self.ModifiedSchedule = ModifiedSchedule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RemovalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RemovalType.subclass:
            return RemovalType.subclass(*args_, **kwargs_)
        else:
            return RemovalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ExistingSystemRemoved or
            self.ExistingScheduleAffected or
            self.ModifiedSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RemovalType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemovalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RemovalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RemovalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RemovalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExistingSystemRemoved_ in self.ExistingSystemRemoved:
            ExistingSystemRemoved_.export(outfile, level, namespace_, name_='ExistingSystemRemoved', pretty_print=pretty_print)
        for ExistingScheduleAffected_ in self.ExistingScheduleAffected:
            ExistingScheduleAffected_.export(outfile, level, namespace_, name_='ExistingScheduleAffected', pretty_print=pretty_print)
        for ModifiedSchedule_ in self.ModifiedSchedule:
            ModifiedSchedule_.export(outfile, level, namespace_, name_='ModifiedSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExistingSystemRemoved':
            obj_ = ExistingSystemRemovedType.factory()
            obj_.build(child_)
            self.ExistingSystemRemoved.append(obj_)
            obj_.original_tagname_ = 'ExistingSystemRemoved'
        elif nodeName_ == 'ExistingScheduleAffected':
            obj_ = ExistingScheduleAffectedType64.factory()
            obj_.build(child_)
            self.ExistingScheduleAffected.append(obj_)
            obj_.original_tagname_ = 'ExistingScheduleAffected'
        elif nodeName_ == 'ModifiedSchedule':
            obj_ = ModifiedScheduleType65.factory()
            obj_.build(child_)
            self.ModifiedSchedule.append(obj_)
            obj_.original_tagname_ = 'ModifiedSchedule'
# end class RemovalType


class ExistingSystemRemovedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingSystemRemovedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingSystemRemovedType.subclass:
            return ExistingSystemRemovedType.subclass(*args_, **kwargs_)
        else:
            return ExistingSystemRemovedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingSystemRemovedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingSystemRemovedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingSystemRemovedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingSystemRemovedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingSystemRemovedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingSystemRemovedType


class ExistingScheduleAffectedType64(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingScheduleAffectedType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingScheduleAffectedType64.subclass:
            return ExistingScheduleAffectedType64.subclass(*args_, **kwargs_)
        else:
            return ExistingScheduleAffectedType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType64', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingScheduleAffectedType64')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ExistingScheduleAffectedType64', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ExistingScheduleAffectedType64'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ExistingScheduleAffectedType64', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExistingScheduleAffectedType64


class ModifiedScheduleType65(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModifiedScheduleType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModifiedScheduleType65.subclass:
            return ModifiedScheduleType65.subclass(*args_, **kwargs_)
        else:
            return ModifiedScheduleType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType65', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModifiedScheduleType65')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ModifiedScheduleType65', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ModifiedScheduleType65'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ModifiedScheduleType65', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ModifiedScheduleType65


class PremisesAffectedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, MeasureCoverage=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.MeasureCoverage = MeasureCoverage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PremisesAffectedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PremisesAffectedType.subclass:
            return PremisesAffectedType.subclass(*args_, **kwargs_)
        else:
            return PremisesAffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MeasureCoverage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PremisesAffectedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PremisesAffectedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PremisesAffectedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PremisesAffectedType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PremisesAffectedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureCoverage is not None:
            self.MeasureCoverage.export(outfile, level, namespace_, name_='MeasureCoverage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureCoverage':
            obj_ = MeasureCoverageType.factory()
            obj_.build(child_)
            self.MeasureCoverage = obj_
            obj_.original_tagname_ = 'MeasureCoverage'
# end class PremisesAffectedType


class MeasureCoverageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureCoverageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureCoverageType.subclass:
            return MeasureCoverageType.subclass(*args_, **kwargs_)
        else:
            return MeasureCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasureCoverageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureCoverageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasureCoverageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasureCoverageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasureCoverageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureCoverageType


class TechnologyCategoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BoilerPlantImprovements=None, ChillerPlantImprovements=None, BuildingAutomationSystems=None, OtherHVAC=None, LightingImprovements=None, BuildingEnvelopeModifications=None, ChilledWaterHotWaterAndSteamDistributionSystems=None, ElectricMotorsAndDrives=None, Refrigeration=None, DistributedGeneration=None, RenewableEnergySystems=None, EnergyDistributionSystems=None, WaterAndSewerConservationSystems=None, ElectricalPeakShavingLoadShifting=None, EnergyCostReductionThroughRateAdjustments=None, EnergyRelatedProcessImprovements=None, AdvancedMeteringSystems=None, PlugLoadReductions=None, FutureOtherECMs=None, HealthAndSafety=None, Uncategorized=None):
        self.original_tagname_ = None
        self.BoilerPlantImprovements = BoilerPlantImprovements
        self.ChillerPlantImprovements = ChillerPlantImprovements
        self.BuildingAutomationSystems = BuildingAutomationSystems
        self.OtherHVAC = OtherHVAC
        self.LightingImprovements = LightingImprovements
        self.BuildingEnvelopeModifications = BuildingEnvelopeModifications
        self.ChilledWaterHotWaterAndSteamDistributionSystems = ChilledWaterHotWaterAndSteamDistributionSystems
        self.ElectricMotorsAndDrives = ElectricMotorsAndDrives
        self.Refrigeration = Refrigeration
        self.DistributedGeneration = DistributedGeneration
        self.RenewableEnergySystems = RenewableEnergySystems
        self.EnergyDistributionSystems = EnergyDistributionSystems
        self.WaterAndSewerConservationSystems = WaterAndSewerConservationSystems
        self.ElectricalPeakShavingLoadShifting = ElectricalPeakShavingLoadShifting
        self.EnergyCostReductionThroughRateAdjustments = EnergyCostReductionThroughRateAdjustments
        self.EnergyRelatedProcessImprovements = EnergyRelatedProcessImprovements
        self.AdvancedMeteringSystems = AdvancedMeteringSystems
        self.PlugLoadReductions = PlugLoadReductions
        self.FutureOtherECMs = FutureOtherECMs
        self.HealthAndSafety = HealthAndSafety
        self.Uncategorized = Uncategorized
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TechnologyCategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TechnologyCategoryType.subclass:
            return TechnologyCategoryType.subclass(*args_, **kwargs_)
        else:
            return TechnologyCategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.BoilerPlantImprovements is not None or
            self.ChillerPlantImprovements is not None or
            self.BuildingAutomationSystems is not None or
            self.OtherHVAC is not None or
            self.LightingImprovements is not None or
            self.BuildingEnvelopeModifications is not None or
            self.ChilledWaterHotWaterAndSteamDistributionSystems is not None or
            self.ElectricMotorsAndDrives is not None or
            self.Refrigeration is not None or
            self.DistributedGeneration is not None or
            self.RenewableEnergySystems is not None or
            self.EnergyDistributionSystems is not None or
            self.WaterAndSewerConservationSystems is not None or
            self.ElectricalPeakShavingLoadShifting is not None or
            self.EnergyCostReductionThroughRateAdjustments is not None or
            self.EnergyRelatedProcessImprovements is not None or
            self.AdvancedMeteringSystems is not None or
            self.PlugLoadReductions is not None or
            self.FutureOtherECMs is not None or
            self.HealthAndSafety is not None or
            self.Uncategorized is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TechnologyCategoryType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TechnologyCategoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TechnologyCategoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TechnologyCategoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TechnologyCategoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BoilerPlantImprovements is not None:
            self.BoilerPlantImprovements.export(outfile, level, namespace_, name_='BoilerPlantImprovements', pretty_print=pretty_print)
        if self.ChillerPlantImprovements is not None:
            self.ChillerPlantImprovements.export(outfile, level, namespace_, name_='ChillerPlantImprovements', pretty_print=pretty_print)
        if self.BuildingAutomationSystems is not None:
            self.BuildingAutomationSystems.export(outfile, level, namespace_, name_='BuildingAutomationSystems', pretty_print=pretty_print)
        if self.OtherHVAC is not None:
            self.OtherHVAC.export(outfile, level, namespace_, name_='OtherHVAC', pretty_print=pretty_print)
        if self.LightingImprovements is not None:
            self.LightingImprovements.export(outfile, level, namespace_, name_='LightingImprovements', pretty_print=pretty_print)
        if self.BuildingEnvelopeModifications is not None:
            self.BuildingEnvelopeModifications.export(outfile, level, namespace_, name_='BuildingEnvelopeModifications', pretty_print=pretty_print)
        if self.ChilledWaterHotWaterAndSteamDistributionSystems is not None:
            self.ChilledWaterHotWaterAndSteamDistributionSystems.export(outfile, level, namespace_, name_='ChilledWaterHotWaterAndSteamDistributionSystems', pretty_print=pretty_print)
        if self.ElectricMotorsAndDrives is not None:
            self.ElectricMotorsAndDrives.export(outfile, level, namespace_, name_='ElectricMotorsAndDrives', pretty_print=pretty_print)
        if self.Refrigeration is not None:
            self.Refrigeration.export(outfile, level, namespace_, name_='Refrigeration', pretty_print=pretty_print)
        if self.DistributedGeneration is not None:
            self.DistributedGeneration.export(outfile, level, namespace_, name_='DistributedGeneration', pretty_print=pretty_print)
        if self.RenewableEnergySystems is not None:
            self.RenewableEnergySystems.export(outfile, level, namespace_, name_='RenewableEnergySystems', pretty_print=pretty_print)
        if self.EnergyDistributionSystems is not None:
            self.EnergyDistributionSystems.export(outfile, level, namespace_, name_='EnergyDistributionSystems', pretty_print=pretty_print)
        if self.WaterAndSewerConservationSystems is not None:
            self.WaterAndSewerConservationSystems.export(outfile, level, namespace_, name_='WaterAndSewerConservationSystems', pretty_print=pretty_print)
        if self.ElectricalPeakShavingLoadShifting is not None:
            self.ElectricalPeakShavingLoadShifting.export(outfile, level, namespace_, name_='ElectricalPeakShavingLoadShifting', pretty_print=pretty_print)
        if self.EnergyCostReductionThroughRateAdjustments is not None:
            self.EnergyCostReductionThroughRateAdjustments.export(outfile, level, namespace_, name_='EnergyCostReductionThroughRateAdjustments', pretty_print=pretty_print)
        if self.EnergyRelatedProcessImprovements is not None:
            self.EnergyRelatedProcessImprovements.export(outfile, level, namespace_, name_='EnergyRelatedProcessImprovements', pretty_print=pretty_print)
        if self.AdvancedMeteringSystems is not None:
            self.AdvancedMeteringSystems.export(outfile, level, namespace_, name_='AdvancedMeteringSystems', pretty_print=pretty_print)
        if self.PlugLoadReductions is not None:
            self.PlugLoadReductions.export(outfile, level, namespace_, name_='PlugLoadReductions', pretty_print=pretty_print)
        if self.FutureOtherECMs is not None:
            self.FutureOtherECMs.export(outfile, level, namespace_, name_='FutureOtherECMs', pretty_print=pretty_print)
        if self.HealthAndSafety is not None:
            self.HealthAndSafety.export(outfile, level, namespace_, name_='HealthAndSafety', pretty_print=pretty_print)
        if self.Uncategorized is not None:
            self.Uncategorized.export(outfile, level, namespace_, name_='Uncategorized', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BoilerPlantImprovements':
            obj_ = BoilerPlantImprovementsType.factory()
            obj_.build(child_)
            self.BoilerPlantImprovements = obj_
            obj_.original_tagname_ = 'BoilerPlantImprovements'
        elif nodeName_ == 'ChillerPlantImprovements':
            obj_ = ChillerPlantImprovementsType.factory()
            obj_.build(child_)
            self.ChillerPlantImprovements = obj_
            obj_.original_tagname_ = 'ChillerPlantImprovements'
        elif nodeName_ == 'BuildingAutomationSystems':
            obj_ = BuildingAutomationSystemsType.factory()
            obj_.build(child_)
            self.BuildingAutomationSystems = obj_
            obj_.original_tagname_ = 'BuildingAutomationSystems'
        elif nodeName_ == 'OtherHVAC':
            obj_ = OtherHVACType68.factory()
            obj_.build(child_)
            self.OtherHVAC = obj_
            obj_.original_tagname_ = 'OtherHVAC'
        elif nodeName_ == 'LightingImprovements':
            obj_ = LightingImprovementsType.factory()
            obj_.build(child_)
            self.LightingImprovements = obj_
            obj_.original_tagname_ = 'LightingImprovements'
        elif nodeName_ == 'BuildingEnvelopeModifications':
            obj_ = BuildingEnvelopeModificationsType.factory()
            obj_.build(child_)
            self.BuildingEnvelopeModifications = obj_
            obj_.original_tagname_ = 'BuildingEnvelopeModifications'
        elif nodeName_ == 'ChilledWaterHotWaterAndSteamDistributionSystems':
            obj_ = ChilledWaterHotWaterAndSteamDistributionSystemsType.factory()
            obj_.build(child_)
            self.ChilledWaterHotWaterAndSteamDistributionSystems = obj_
            obj_.original_tagname_ = 'ChilledWaterHotWaterAndSteamDistributionSystems'
        elif nodeName_ == 'ElectricMotorsAndDrives':
            obj_ = ElectricMotorsAndDrivesType.factory()
            obj_.build(child_)
            self.ElectricMotorsAndDrives = obj_
            obj_.original_tagname_ = 'ElectricMotorsAndDrives'
        elif nodeName_ == 'Refrigeration':
            obj_ = RefrigerationType.factory()
            obj_.build(child_)
            self.Refrigeration = obj_
            obj_.original_tagname_ = 'Refrigeration'
        elif nodeName_ == 'DistributedGeneration':
            obj_ = DistributedGenerationType.factory()
            obj_.build(child_)
            self.DistributedGeneration = obj_
            obj_.original_tagname_ = 'DistributedGeneration'
        elif nodeName_ == 'RenewableEnergySystems':
            obj_ = RenewableEnergySystemsType.factory()
            obj_.build(child_)
            self.RenewableEnergySystems = obj_
            obj_.original_tagname_ = 'RenewableEnergySystems'
        elif nodeName_ == 'EnergyDistributionSystems':
            obj_ = EnergyDistributionSystemsType.factory()
            obj_.build(child_)
            self.EnergyDistributionSystems = obj_
            obj_.original_tagname_ = 'EnergyDistributionSystems'
        elif nodeName_ == 'WaterAndSewerConservationSystems':
            obj_ = WaterAndSewerConservationSystemsType.factory()
            obj_.build(child_)
            self.WaterAndSewerConservationSystems = obj_
            obj_.original_tagname_ = 'WaterAndSewerConservationSystems'
        elif nodeName_ == 'ElectricalPeakShavingLoadShifting':
            obj_ = ElectricalPeakShavingLoadShiftingType.factory()
            obj_.build(child_)
            self.ElectricalPeakShavingLoadShifting = obj_
            obj_.original_tagname_ = 'ElectricalPeakShavingLoadShifting'
        elif nodeName_ == 'EnergyCostReductionThroughRateAdjustments':
            obj_ = EnergyCostReductionThroughRateAdjustmentsType.factory()
            obj_.build(child_)
            self.EnergyCostReductionThroughRateAdjustments = obj_
            obj_.original_tagname_ = 'EnergyCostReductionThroughRateAdjustments'
        elif nodeName_ == 'EnergyRelatedProcessImprovements':
            obj_ = EnergyRelatedProcessImprovementsType.factory()
            obj_.build(child_)
            self.EnergyRelatedProcessImprovements = obj_
            obj_.original_tagname_ = 'EnergyRelatedProcessImprovements'
        elif nodeName_ == 'AdvancedMeteringSystems':
            obj_ = AdvancedMeteringSystemsType.factory()
            obj_.build(child_)
            self.AdvancedMeteringSystems = obj_
            obj_.original_tagname_ = 'AdvancedMeteringSystems'
        elif nodeName_ == 'PlugLoadReductions':
            obj_ = PlugLoadReductionsType.factory()
            obj_.build(child_)
            self.PlugLoadReductions = obj_
            obj_.original_tagname_ = 'PlugLoadReductions'
        elif nodeName_ == 'FutureOtherECMs':
            obj_ = FutureOtherECMsType.factory()
            obj_.build(child_)
            self.FutureOtherECMs = obj_
            obj_.original_tagname_ = 'FutureOtherECMs'
        elif nodeName_ == 'HealthAndSafety':
            obj_ = HealthAndSafetyType.factory()
            obj_.build(child_)
            self.HealthAndSafety = obj_
            obj_.original_tagname_ = 'HealthAndSafety'
        elif nodeName_ == 'Uncategorized':
            obj_ = UncategorizedType.factory()
            obj_.build(child_)
            self.Uncategorized = obj_
            obj_.original_tagname_ = 'Uncategorized'
# end class TechnologyCategoryType


class BoilerPlantImprovementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerPlantImprovementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerPlantImprovementsType.subclass:
            return BoilerPlantImprovementsType.subclass(*args_, **kwargs_)
        else:
            return BoilerPlantImprovementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType(self, value):
        # Validate type MeasureNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Replace boiler', 'Replace burner', 'Decentralize boiler', 'Insulate boiler room', 'Add energy recovery', 'Convert gas-fired unit to boiler loop', 'Convert system from steam to hot water', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerPlantImprovementsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerPlantImprovementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerPlantImprovementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerPlantImprovementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerPlantImprovementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType
            self.validate_MeasureNameType(self.MeasureName[-1])
# end class BoilerPlantImprovementsType


class ChillerPlantImprovementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChillerPlantImprovementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChillerPlantImprovementsType.subclass:
            return ChillerPlantImprovementsType.subclass(*args_, **kwargs_)
        else:
            return ChillerPlantImprovementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType66(self, value):
        # Validate type MeasureNameType66, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Add energy recovery', 'Install VSD on electric centrifugal chillers', 'Replace chiller', 'Install gas cooling', 'Add or repair economizer cycle', 'Add or replace cooling tower', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType66' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ChillerPlantImprovementsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChillerPlantImprovementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ChillerPlantImprovementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ChillerPlantImprovementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ChillerPlantImprovementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType66
            self.validate_MeasureNameType66(self.MeasureName[-1])
# end class ChillerPlantImprovementsType


class BuildingAutomationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BuildingAutomationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BuildingAutomationSystemsType.subclass:
            return BuildingAutomationSystemsType.subclass(*args_, **kwargs_)
        else:
            return BuildingAutomationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType67(self, value):
        # Validate type MeasureNameType67, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Add heat recovery', 'Add or upgrade BAS/EMS/EMCS', 'Add or upgrade controls', 'Convert pneumatic controls to DDC', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType67' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BuildingAutomationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildingAutomationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BuildingAutomationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BuildingAutomationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BuildingAutomationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType67
            self.validate_MeasureNameType67(self.MeasureName[-1])
# end class BuildingAutomationSystemsType


class OtherHVACType68(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherHVACType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherHVACType68.subclass:
            return OtherHVACType68.subclass(*args_, **kwargs_)
        else:
            return OtherHVACType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType69(self, value):
        # Validate type MeasureNameType69, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Replace or modify AHU', 'Improve distribution fans', 'Improve ventilation fans', 'Convert CV system to VAV system', 'Upgrade operating protocols, calibration, and/or sequencing', 'Repair leaks / seal ducts', 'Add duct insulation', 'Balance ventilation/distribution system', 'Repair or replace HVAC damper and controller', 'Replace burner', 'Replace package units', 'Replace packaged terminal units', 'Install passive solar heating', 'Replace AC and heating units with ground coupled heat pump systems', 'Add energy recovery', 'Add or replace cooling tower', 'Install gas cooling', 'Add or repair economizer', 'Add enhanced dehumidification', 'Install solar ventilation preheating system', 'Clean and/or repair', 'Implement training and/or documentation', 'Other heating', 'Other cooling', 'Other ventilation', 'Other distribution', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType69' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherHVACType68', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherHVACType68')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherHVACType68', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherHVACType68'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherHVACType68', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType69
            self.validate_MeasureNameType69(self.MeasureName[-1])
# end class OtherHVACType68


class LightingImprovementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightingImprovementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightingImprovementsType.subclass:
            return LightingImprovementsType.subclass(*args_, **kwargs_)
        else:
            return LightingImprovementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType70(self, value):
        # Validate type MeasureNameType70, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Retrofit with CFLs', 'Retrofit with T-5', 'Retrofit with T-8', 'Install spectrally enhanced lighting', 'Retrofit with fiber optic lighting technologies', 'Retrofit with light emitting diode technologies', 'Add daylight controls', 'Add occupancy sensors', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType70' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightingImprovementsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightingImprovementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightingImprovementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightingImprovementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightingImprovementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType70
            self.validate_MeasureNameType70(self.MeasureName[-1])
# end class LightingImprovementsType


class BuildingEnvelopeModificationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BuildingEnvelopeModificationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BuildingEnvelopeModificationsType.subclass:
            return BuildingEnvelopeModificationsType.subclass(*args_, **kwargs_)
        else:
            return BuildingEnvelopeModificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType71(self, value):
        # Validate type MeasureNameType71, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Air seal envelope', 'Increase wall insulation', 'Insulate thermal bypasses', 'Increase ceiling insulation', 'Increase roof insulation', 'Insulate attic hatch / stair box', 'Add attic/knee wall insulation', 'Install cool/green roof', 'Add shading devices', 'Add window films', 'Install or replace solar screens', 'Replace glazing', 'Replace windows', 'Increase floor insulation', 'Insulate foundation', 'Clean and/or repair', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType71' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BuildingEnvelopeModificationsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BuildingEnvelopeModificationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BuildingEnvelopeModificationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BuildingEnvelopeModificationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BuildingEnvelopeModificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType71
            self.validate_MeasureNameType71(self.MeasureName[-1])
# end class BuildingEnvelopeModificationsType


class ChilledWaterHotWaterAndSteamDistributionSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChilledWaterHotWaterAndSteamDistributionSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChilledWaterHotWaterAndSteamDistributionSystemsType.subclass:
            return ChilledWaterHotWaterAndSteamDistributionSystemsType.subclass(*args_, **kwargs_)
        else:
            return ChilledWaterHotWaterAndSteamDistributionSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType72(self, value):
        # Validate type MeasureNameType72, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Add pipe insulation', 'Repair and/or replace steam traps', 'Retrofit and replace chiller plant pumping, piping, and controls', 'Repair or replace existing condensate return systems or install new condensate return systems', 'Add recirculating pumps', 'Replace or upgrade water heater', 'Add energy recovery', 'Install solar hot water system', 'Separate DHW from heating', 'Replace with higher efficiency pump', 'Replace with variable speed pump', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType72' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ChilledWaterHotWaterAndSteamDistributionSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChilledWaterHotWaterAndSteamDistributionSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ChilledWaterHotWaterAndSteamDistributionSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ChilledWaterHotWaterAndSteamDistributionSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ChilledWaterHotWaterAndSteamDistributionSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType72
            self.validate_MeasureNameType72(self.MeasureName[-1])
# end class ChilledWaterHotWaterAndSteamDistributionSystemsType


class ElectricMotorsAndDrivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricMotorsAndDrivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricMotorsAndDrivesType.subclass:
            return ElectricMotorsAndDrivesType.subclass(*args_, **kwargs_)
        else:
            return ElectricMotorsAndDrivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType73(self, value):
        # Validate type MeasureNameType73, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Add drive controls', 'Replace with higher efficiency', 'Add VSD motor controller', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType73' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricMotorsAndDrivesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricMotorsAndDrivesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricMotorsAndDrivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricMotorsAndDrivesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricMotorsAndDrivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType73
            self.validate_MeasureNameType73(self.MeasureName[-1])
# end class ElectricMotorsAndDrivesType


class RefrigerationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationType.subclass:
            return RefrigerationType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType74(self, value):
        # Validate type MeasureNameType74, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Replace ice/refrigeration equipment with high efficiency units', 'Replace air-cooled ice/refrigeration equipment', 'Replace refrigerators', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType74' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType74
            self.validate_MeasureNameType74(self.MeasureName[-1])
# end class RefrigerationType


class DistributedGenerationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistributedGenerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistributedGenerationType.subclass:
            return DistributedGenerationType.subclass(*args_, **kwargs_)
        else:
            return DistributedGenerationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType75(self, value):
        # Validate type MeasureNameType75, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Install CHP/cogeneration systems', 'Install fuel cells', 'Install microturbines', 'Convert fuels', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType75' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DistributedGenerationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistributedGenerationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DistributedGenerationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DistributedGenerationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DistributedGenerationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType75
            self.validate_MeasureNameType75(self.MeasureName[-1])
# end class DistributedGenerationType


class RenewableEnergySystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RenewableEnergySystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RenewableEnergySystemsType.subclass:
            return RenewableEnergySystemsType.subclass(*args_, **kwargs_)
        else:
            return RenewableEnergySystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType76(self, value):
        # Validate type MeasureNameType76, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Install landfill gas, wastewater treatment plant digester gas, or coal bed methane power plant', 'Install photovoltaic system', 'Install wind energy system', 'Install wood waste or other organic waste stream heating or power plant', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType76' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RenewableEnergySystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RenewableEnergySystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RenewableEnergySystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RenewableEnergySystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RenewableEnergySystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType76
            self.validate_MeasureNameType76(self.MeasureName[-1])
# end class RenewableEnergySystemsType


class EnergyDistributionSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyDistributionSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyDistributionSystemsType.subclass:
            return EnergyDistributionSystemsType.subclass(*args_, **kwargs_)
        else:
            return EnergyDistributionSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType77(self, value):
        # Validate type MeasureNameType77, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Implement power factor corrections', 'Implement power quality upgrades', 'Upgrade transformers', 'Install gas distribution systems', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType77' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyDistributionSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyDistributionSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyDistributionSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyDistributionSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyDistributionSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType77
            self.validate_MeasureNameType77(self.MeasureName[-1])
# end class EnergyDistributionSystemsType


class WaterAndSewerConservationSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterAndSewerConservationSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterAndSewerConservationSystemsType.subclass:
            return WaterAndSewerConservationSystemsType.subclass(*args_, **kwargs_)
        else:
            return WaterAndSewerConservationSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType78(self, value):
        # Validate type MeasureNameType78, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Install low-flow faucets and showerheads', 'Install low-flow plumbing equipment', 'Install on-site sewer treatment systems', 'Implement water efficient irrigation', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType78' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterAndSewerConservationSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterAndSewerConservationSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterAndSewerConservationSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterAndSewerConservationSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterAndSewerConservationSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType78
            self.validate_MeasureNameType78(self.MeasureName[-1])
# end class WaterAndSewerConservationSystemsType


class ElectricalPeakShavingLoadShiftingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricalPeakShavingLoadShiftingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricalPeakShavingLoadShiftingType.subclass:
            return ElectricalPeakShavingLoadShiftingType.subclass(*args_, **kwargs_)
        else:
            return ElectricalPeakShavingLoadShiftingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType79(self, value):
        # Validate type MeasureNameType79, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Install thermal energy storage', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType79' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricalPeakShavingLoadShiftingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricalPeakShavingLoadShiftingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricalPeakShavingLoadShiftingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricalPeakShavingLoadShiftingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricalPeakShavingLoadShiftingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType79
            self.validate_MeasureNameType79(self.MeasureName[-1])
# end class ElectricalPeakShavingLoadShiftingType


class EnergyCostReductionThroughRateAdjustmentsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCostReductionThroughRateAdjustmentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCostReductionThroughRateAdjustmentsType.subclass:
            return EnergyCostReductionThroughRateAdjustmentsType.subclass(*args_, **kwargs_)
        else:
            return EnergyCostReductionThroughRateAdjustmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType80(self, value):
        # Validate type MeasureNameType80, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Change to more favorable rate schedule', 'Energy cost reduction through rate adjustments - uncategorized', 'Energy service billing and meter auditing recommendations', 'Change to lower energy cost supplier(s)', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType80' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyCostReductionThroughRateAdjustmentsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyCostReductionThroughRateAdjustmentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyCostReductionThroughRateAdjustmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyCostReductionThroughRateAdjustmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyCostReductionThroughRateAdjustmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType80
            self.validate_MeasureNameType80(self.MeasureName[-1])
# end class EnergyCostReductionThroughRateAdjustmentsType


class EnergyRelatedProcessImprovementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyRelatedProcessImprovementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyRelatedProcessImprovementsType.subclass:
            return EnergyRelatedProcessImprovementsType.subclass(*args_, **kwargs_)
        else:
            return EnergyRelatedProcessImprovementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType81(self, value):
        # Validate type MeasureNameType81, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Implement industrial process improvements', 'Implement production and/or manufacturing improvements', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType81' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyRelatedProcessImprovementsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyRelatedProcessImprovementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyRelatedProcessImprovementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyRelatedProcessImprovementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyRelatedProcessImprovementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType81
            self.validate_MeasureNameType81(self.MeasureName[-1])
# end class EnergyRelatedProcessImprovementsType


class AdvancedMeteringSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancedMeteringSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancedMeteringSystemsType.subclass:
            return AdvancedMeteringSystemsType.subclass(*args_, **kwargs_)
        else:
            return AdvancedMeteringSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType82(self, value):
        # Validate type MeasureNameType82, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Install advanced metering systems', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType82' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AdvancedMeteringSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdvancedMeteringSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AdvancedMeteringSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AdvancedMeteringSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AdvancedMeteringSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType82
            self.validate_MeasureNameType82(self.MeasureName[-1])
# end class AdvancedMeteringSystemsType


class PlugLoadReductionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadReductionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadReductionsType.subclass:
            return PlugLoadReductionsType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadReductionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType83(self, value):
        # Validate type MeasureNameType83, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Replace with ENERGY STAR rated', 'Install plug load controls', 'De-lamp vending machines', 'Improve data center efficiency', 'Clean and/or repair', 'Implement training and/or documentation', 'Upgrade operating protocols, calibration, and/or sequencing', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType83' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadReductionsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadReductionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadReductionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadReductionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadReductionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType83
            self.validate_MeasureNameType83(self.MeasureName[-1])
# end class PlugLoadReductionsType


class FutureOtherECMsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureOtherECMsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureOtherECMsType.subclass:
            return FutureOtherECMsType.subclass(*args_, **kwargs_)
        else:
            return FutureOtherECMsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType84(self, value):
        # Validate type MeasureNameType84, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType84' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FutureOtherECMsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureOtherECMsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FutureOtherECMsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FutureOtherECMsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FutureOtherECMsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType84
            self.validate_MeasureNameType84(self.MeasureName[-1])
# end class FutureOtherECMsType


class HealthAndSafetyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HealthAndSafetyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HealthAndSafetyType.subclass:
            return HealthAndSafetyType.subclass(*args_, **kwargs_)
        else:
            return HealthAndSafetyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HealthAndSafetyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HealthAndSafetyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HealthAndSafetyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HealthAndSafetyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HealthAndSafetyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
# end class HealthAndSafetyType


class UncategorizedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureName=None):
        self.original_tagname_ = None
        if MeasureName is None:
            self.MeasureName = []
        else:
            self.MeasureName = MeasureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UncategorizedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UncategorizedType.subclass:
            return UncategorizedType.subclass(*args_, **kwargs_)
        else:
            return UncategorizedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_MeasureNameType85(self, value):
        # Validate type MeasureNameType85, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MeasureNameType85' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MeasureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UncategorizedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UncategorizedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UncategorizedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UncategorizedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UncategorizedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasureName_ in self.MeasureName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasureName>%s</%sMeasureName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(MeasureName_), input_name='MeasureName')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureName':
            MeasureName_ = child_.text
            MeasureName_ = self.gds_validate_string(MeasureName_, node, 'MeasureName')
            self.MeasureName.append(MeasureName_)
            # validate type MeasureNameType85
            self.validate_MeasureNameType85(self.MeasureName[-1])
# end class UncategorizedType


class MeasureSavingsAnalysisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasureRank=None, ReferenceCase=None, CalculationMethod=None, AnnualSavingsSiteEnergy=None, AnnualSavingsSourceEnergy=None, AnnualSavingsCost=None, AnnualSavingsByFuel=None, SummerPeakElectricityReduction=None, WinterPeakElectricityReduction=None, AnnualDemandSavingsCost=None, AnnualWaterSavings=None, AnnualWaterCostSavings=None, OMCostAnnualSavings=None, OtherCostAnnualSavings=None, EquipmentDisposalAndSalvageCosts=None, FundingFromIncentives=None, FundingFromTaxCredits=None, NPVofTaxImplications=None, CostEffectivenessScreeningMethod=None, SimplePayback=None, NetPresentValue=None, InternalRateOfReturn=None):
        self.original_tagname_ = None
        self.MeasureRank = MeasureRank
        self.ReferenceCase = ReferenceCase
        self.CalculationMethod = CalculationMethod
        self.AnnualSavingsSiteEnergy = AnnualSavingsSiteEnergy
        self.AnnualSavingsSourceEnergy = AnnualSavingsSourceEnergy
        self.AnnualSavingsCost = AnnualSavingsCost
        if AnnualSavingsByFuel is None:
            self.AnnualSavingsByFuel = []
        else:
            self.AnnualSavingsByFuel = AnnualSavingsByFuel
        self.SummerPeakElectricityReduction = SummerPeakElectricityReduction
        self.WinterPeakElectricityReduction = WinterPeakElectricityReduction
        self.AnnualDemandSavingsCost = AnnualDemandSavingsCost
        self.AnnualWaterSavings = AnnualWaterSavings
        self.AnnualWaterCostSavings = AnnualWaterCostSavings
        self.OMCostAnnualSavings = OMCostAnnualSavings
        self.OtherCostAnnualSavings = OtherCostAnnualSavings
        self.EquipmentDisposalAndSalvageCosts = EquipmentDisposalAndSalvageCosts
        self.FundingFromIncentives = FundingFromIncentives
        self.FundingFromTaxCredits = FundingFromTaxCredits
        self.NPVofTaxImplications = NPVofTaxImplications
        self.CostEffectivenessScreeningMethod = CostEffectivenessScreeningMethod
        self.validate_CostEffectivenessScreeningMethod(self.CostEffectivenessScreeningMethod)
        self.SimplePayback = SimplePayback
        self.NetPresentValue = NetPresentValue
        self.InternalRateOfReturn = InternalRateOfReturn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureSavingsAnalysisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureSavingsAnalysisType.subclass:
            return MeasureSavingsAnalysisType.subclass(*args_, **kwargs_)
        else:
            return MeasureSavingsAnalysisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CostEffectivenessScreeningMethod(self, value):
        # Validate type CostEffectivenessScreeningMethod, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MeasureRank is not None or
            self.ReferenceCase is not None or
            self.CalculationMethod is not None or
            self.AnnualSavingsSiteEnergy is not None or
            self.AnnualSavingsSourceEnergy is not None or
            self.AnnualSavingsCost is not None or
            self.AnnualSavingsByFuel or
            self.SummerPeakElectricityReduction is not None or
            self.WinterPeakElectricityReduction is not None or
            self.AnnualDemandSavingsCost is not None or
            self.AnnualWaterSavings is not None or
            self.AnnualWaterCostSavings is not None or
            self.OMCostAnnualSavings is not None or
            self.OtherCostAnnualSavings is not None or
            self.EquipmentDisposalAndSalvageCosts is not None or
            self.FundingFromIncentives is not None or
            self.FundingFromTaxCredits is not None or
            self.NPVofTaxImplications is not None or
            self.CostEffectivenessScreeningMethod is not None or
            self.SimplePayback is not None or
            self.NetPresentValue is not None or
            self.InternalRateOfReturn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasureSavingsAnalysisType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureSavingsAnalysisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasureSavingsAnalysisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasureSavingsAnalysisType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasureSavingsAnalysisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureRank is not None:
            self.MeasureRank.export(outfile, level, namespace_, name_='MeasureRank', pretty_print=pretty_print)
        if self.ReferenceCase is not None:
            self.ReferenceCase.export(outfile, level, namespace_='auc:', name_='ReferenceCase', pretty_print=pretty_print)
        if self.CalculationMethod is not None:
            self.CalculationMethod.export(outfile, level, namespace_='auc:', name_='CalculationMethod', pretty_print=pretty_print)
        if self.AnnualSavingsSiteEnergy is not None:
            self.AnnualSavingsSiteEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSiteEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsSourceEnergy is not None:
            self.AnnualSavingsSourceEnergy.export(outfile, level, namespace_, name_='AnnualSavingsSourceEnergy', pretty_print=pretty_print)
        if self.AnnualSavingsCost is not None:
            self.AnnualSavingsCost.export(outfile, level, namespace_, name_='AnnualSavingsCost', pretty_print=pretty_print)
        for AnnualSavingsByFuel_ in self.AnnualSavingsByFuel:
            AnnualSavingsByFuel_.export(outfile, level, namespace_, name_='AnnualSavingsByFuel', pretty_print=pretty_print)
        if self.SummerPeakElectricityReduction is not None:
            self.SummerPeakElectricityReduction.export(outfile, level, namespace_, name_='SummerPeakElectricityReduction', pretty_print=pretty_print)
        if self.WinterPeakElectricityReduction is not None:
            self.WinterPeakElectricityReduction.export(outfile, level, namespace_, name_='WinterPeakElectricityReduction', pretty_print=pretty_print)
        if self.AnnualDemandSavingsCost is not None:
            self.AnnualDemandSavingsCost.export(outfile, level, namespace_, name_='AnnualDemandSavingsCost', pretty_print=pretty_print)
        if self.AnnualWaterSavings is not None:
            self.AnnualWaterSavings.export(outfile, level, namespace_, name_='AnnualWaterSavings', pretty_print=pretty_print)
        if self.AnnualWaterCostSavings is not None:
            self.AnnualWaterCostSavings.export(outfile, level, namespace_, name_='AnnualWaterCostSavings', pretty_print=pretty_print)
        if self.OMCostAnnualSavings is not None:
            self.OMCostAnnualSavings.export(outfile, level, namespace_, name_='OMCostAnnualSavings', pretty_print=pretty_print)
        if self.OtherCostAnnualSavings is not None:
            self.OtherCostAnnualSavings.export(outfile, level, namespace_, name_='OtherCostAnnualSavings', pretty_print=pretty_print)
        if self.EquipmentDisposalAndSalvageCosts is not None:
            self.EquipmentDisposalAndSalvageCosts.export(outfile, level, namespace_, name_='EquipmentDisposalAndSalvageCosts', pretty_print=pretty_print)
        if self.FundingFromIncentives is not None:
            self.FundingFromIncentives.export(outfile, level, namespace_, name_='FundingFromIncentives', pretty_print=pretty_print)
        if self.FundingFromTaxCredits is not None:
            self.FundingFromTaxCredits.export(outfile, level, namespace_, name_='FundingFromTaxCredits', pretty_print=pretty_print)
        if self.NPVofTaxImplications is not None:
            self.NPVofTaxImplications.export(outfile, level, namespace_, name_='NPVofTaxImplications', pretty_print=pretty_print)
        if self.CostEffectivenessScreeningMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCostEffectivenessScreeningMethod>%s</%sCostEffectivenessScreeningMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CostEffectivenessScreeningMethod), input_name='CostEffectivenessScreeningMethod')), namespace_, eol_))
        if self.SimplePayback is not None:
            self.SimplePayback.export(outfile, level, namespace_, name_='SimplePayback', pretty_print=pretty_print)
        if self.NetPresentValue is not None:
            self.NetPresentValue.export(outfile, level, namespace_, name_='NetPresentValue', pretty_print=pretty_print)
        if self.InternalRateOfReturn is not None:
            self.InternalRateOfReturn.export(outfile, level, namespace_, name_='InternalRateOfReturn', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasureRank':
            obj_ = MeasureRankType.factory()
            obj_.build(child_)
            self.MeasureRank = obj_
            obj_.original_tagname_ = 'MeasureRank'
        elif nodeName_ == 'ReferenceCase':
            obj_ = ReferenceCase.factory()
            obj_.build(child_)
            self.ReferenceCase = obj_
            obj_.original_tagname_ = 'ReferenceCase'
        elif nodeName_ == 'CalculationMethod':
            obj_ = CalculationMethodType.factory()
            obj_.build(child_)
            self.CalculationMethod = obj_
            obj_.original_tagname_ = 'CalculationMethod'
        elif nodeName_ == 'AnnualSavingsSiteEnergy':
            obj_ = AnnualSavingsSiteEnergyType86.factory()
            obj_.build(child_)
            self.AnnualSavingsSiteEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSiteEnergy'
        elif nodeName_ == 'AnnualSavingsSourceEnergy':
            obj_ = AnnualSavingsSourceEnergyType87.factory()
            obj_.build(child_)
            self.AnnualSavingsSourceEnergy = obj_
            obj_.original_tagname_ = 'AnnualSavingsSourceEnergy'
        elif nodeName_ == 'AnnualSavingsCost':
            obj_ = AnnualSavingsCostType88.factory()
            obj_.build(child_)
            self.AnnualSavingsCost = obj_
            obj_.original_tagname_ = 'AnnualSavingsCost'
        elif nodeName_ == 'AnnualSavingsByFuel':
            obj_ = AnnualSavingsByFuelType89.factory()
            obj_.build(child_)
            self.AnnualSavingsByFuel.append(obj_)
            obj_.original_tagname_ = 'AnnualSavingsByFuel'
        elif nodeName_ == 'SummerPeakElectricityReduction':
            obj_ = SummerPeakElectricityReductionType91.factory()
            obj_.build(child_)
            self.SummerPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'SummerPeakElectricityReduction'
        elif nodeName_ == 'WinterPeakElectricityReduction':
            obj_ = WinterPeakElectricityReductionType92.factory()
            obj_.build(child_)
            self.WinterPeakElectricityReduction = obj_
            obj_.original_tagname_ = 'WinterPeakElectricityReduction'
        elif nodeName_ == 'AnnualDemandSavingsCost':
            obj_ = AnnualDemandSavingsCostType.factory()
            obj_.build(child_)
            self.AnnualDemandSavingsCost = obj_
            obj_.original_tagname_ = 'AnnualDemandSavingsCost'
        elif nodeName_ == 'AnnualWaterSavings':
            obj_ = AnnualWaterSavingsType93.factory()
            obj_.build(child_)
            self.AnnualWaterSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterSavings'
        elif nodeName_ == 'AnnualWaterCostSavings':
            obj_ = AnnualWaterCostSavingsType94.factory()
            obj_.build(child_)
            self.AnnualWaterCostSavings = obj_
            obj_.original_tagname_ = 'AnnualWaterCostSavings'
        elif nodeName_ == 'OMCostAnnualSavings':
            obj_ = OMCostAnnualSavingsType95.factory()
            obj_.build(child_)
            self.OMCostAnnualSavings = obj_
            obj_.original_tagname_ = 'OMCostAnnualSavings'
        elif nodeName_ == 'OtherCostAnnualSavings':
            obj_ = OtherCostAnnualSavingsType.factory()
            obj_.build(child_)
            self.OtherCostAnnualSavings = obj_
            obj_.original_tagname_ = 'OtherCostAnnualSavings'
        elif nodeName_ == 'EquipmentDisposalAndSalvageCosts':
            obj_ = EquipmentDisposalAndSalvageCostsType96.factory()
            obj_.build(child_)
            self.EquipmentDisposalAndSalvageCosts = obj_
            obj_.original_tagname_ = 'EquipmentDisposalAndSalvageCosts'
        elif nodeName_ == 'FundingFromIncentives':
            obj_ = FundingFromIncentivesType97.factory()
            obj_.build(child_)
            self.FundingFromIncentives = obj_
            obj_.original_tagname_ = 'FundingFromIncentives'
        elif nodeName_ == 'FundingFromTaxCredits':
            obj_ = FundingFromTaxCreditsType98.factory()
            obj_.build(child_)
            self.FundingFromTaxCredits = obj_
            obj_.original_tagname_ = 'FundingFromTaxCredits'
        elif nodeName_ == 'NPVofTaxImplications':
            obj_ = NPVofTaxImplicationsType99.factory()
            obj_.build(child_)
            self.NPVofTaxImplications = obj_
            obj_.original_tagname_ = 'NPVofTaxImplications'
        elif nodeName_ == 'CostEffectivenessScreeningMethod':
            CostEffectivenessScreeningMethod_ = child_.text
            CostEffectivenessScreeningMethod_ = self.gds_validate_string(CostEffectivenessScreeningMethod_, node, 'CostEffectivenessScreeningMethod')
            self.CostEffectivenessScreeningMethod = CostEffectivenessScreeningMethod_
            # validate type CostEffectivenessScreeningMethod
            self.validate_CostEffectivenessScreeningMethod(self.CostEffectivenessScreeningMethod)
        elif nodeName_ == 'SimplePayback':
            obj_ = SimplePaybackType100.factory()
            obj_.build(child_)
            self.SimplePayback = obj_
            obj_.original_tagname_ = 'SimplePayback'
        elif nodeName_ == 'NetPresentValue':
            obj_ = NetPresentValueType101.factory()
            obj_.build(child_)
            self.NetPresentValue = obj_
            obj_.original_tagname_ = 'NetPresentValue'
        elif nodeName_ == 'InternalRateOfReturn':
            obj_ = InternalRateOfReturnType102.factory()
            obj_.build(child_)
            self.InternalRateOfReturn = obj_
            obj_.original_tagname_ = 'InternalRateOfReturn'
# end class MeasureSavingsAnalysisType


class MeasureRankType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureRankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureRankType.subclass:
            return MeasureRankType.subclass(*args_, **kwargs_)
        else:
            return MeasureRankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasureRankType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureRankType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasureRankType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasureRankType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasureRankType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureRankType


class AnnualSavingsSiteEnergyType86(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSiteEnergyType86)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSiteEnergyType86.subclass:
            return AnnualSavingsSiteEnergyType86.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSiteEnergyType86(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType86', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSiteEnergyType86')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSiteEnergyType86', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSiteEnergyType86'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSiteEnergyType86', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSiteEnergyType86


class AnnualSavingsSourceEnergyType87(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsSourceEnergyType87)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsSourceEnergyType87.subclass:
            return AnnualSavingsSourceEnergyType87.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsSourceEnergyType87(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType87', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsSourceEnergyType87')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsSourceEnergyType87', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsSourceEnergyType87'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsSourceEnergyType87', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsSourceEnergyType87


class AnnualSavingsCostType88(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsCostType88)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsCostType88.subclass:
            return AnnualSavingsCostType88.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsCostType88(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType88', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsCostType88')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsCostType88', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsCostType88'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsCostType88', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsCostType88


class AnnualSavingsByFuelType89(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyResource=None, ResourceUnits=None, AnnualSavingsNativeUnits=None):
        self.original_tagname_ = None
        self.EnergyResource = EnergyResource
        self.validate_EnergyResource(self.EnergyResource)
        self.ResourceUnits = ResourceUnits
        self.validate_ResourceUnits(self.ResourceUnits)
        self.AnnualSavingsNativeUnits = AnnualSavingsNativeUnits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsByFuelType89)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsByFuelType89.subclass:
            return AnnualSavingsByFuelType89.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsByFuelType89(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnergyResource(self, value):
        # Validate type EnergyResource, a restriction on xs:string.
        pass
    def validate_ResourceUnits(self, value):
        # Validate type ResourceUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.EnergyResource is not None or
            self.ResourceUnits is not None or
            self.AnnualSavingsNativeUnits is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsByFuelType89', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsByFuelType89')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsByFuelType89', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsByFuelType89'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsByFuelType89', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyResource>%s</%sEnergyResource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyResource), input_name='EnergyResource')), namespace_, eol_))
        if self.ResourceUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceUnits>%s</%sResourceUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ResourceUnits), input_name='ResourceUnits')), namespace_, eol_))
        if self.AnnualSavingsNativeUnits is not None:
            self.AnnualSavingsNativeUnits.export(outfile, level, namespace_, name_='AnnualSavingsNativeUnits', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyResource':
            EnergyResource_ = child_.text
            EnergyResource_ = self.gds_validate_string(EnergyResource_, node, 'EnergyResource')
            self.EnergyResource = EnergyResource_
            # validate type EnergyResource
            self.validate_EnergyResource(self.EnergyResource)
        elif nodeName_ == 'ResourceUnits':
            ResourceUnits_ = child_.text
            ResourceUnits_ = self.gds_validate_string(ResourceUnits_, node, 'ResourceUnits')
            self.ResourceUnits = ResourceUnits_
            # validate type ResourceUnits
            self.validate_ResourceUnits(self.ResourceUnits)
        elif nodeName_ == 'AnnualSavingsNativeUnits':
            obj_ = AnnualSavingsNativeUnitsType90.factory()
            obj_.build(child_)
            self.AnnualSavingsNativeUnits = obj_
            obj_.original_tagname_ = 'AnnualSavingsNativeUnits'
# end class AnnualSavingsByFuelType89


class AnnualSavingsNativeUnitsType90(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualSavingsNativeUnitsType90)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualSavingsNativeUnitsType90.subclass:
            return AnnualSavingsNativeUnitsType90.subclass(*args_, **kwargs_)
        else:
            return AnnualSavingsNativeUnitsType90(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualSavingsNativeUnitsType90', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualSavingsNativeUnitsType90')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualSavingsNativeUnitsType90', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualSavingsNativeUnitsType90'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualSavingsNativeUnitsType90', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualSavingsNativeUnitsType90


class SummerPeakElectricityReductionType91(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummerPeakElectricityReductionType91)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummerPeakElectricityReductionType91.subclass:
            return SummerPeakElectricityReductionType91.subclass(*args_, **kwargs_)
        else:
            return SummerPeakElectricityReductionType91(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType91', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SummerPeakElectricityReductionType91')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SummerPeakElectricityReductionType91', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SummerPeakElectricityReductionType91'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SummerPeakElectricityReductionType91', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SummerPeakElectricityReductionType91


class WinterPeakElectricityReductionType92(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WinterPeakElectricityReductionType92)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WinterPeakElectricityReductionType92.subclass:
            return WinterPeakElectricityReductionType92.subclass(*args_, **kwargs_)
        else:
            return WinterPeakElectricityReductionType92(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType92', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WinterPeakElectricityReductionType92')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WinterPeakElectricityReductionType92', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WinterPeakElectricityReductionType92'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WinterPeakElectricityReductionType92', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WinterPeakElectricityReductionType92


class AnnualDemandSavingsCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualDemandSavingsCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualDemandSavingsCostType.subclass:
            return AnnualDemandSavingsCostType.subclass(*args_, **kwargs_)
        else:
            return AnnualDemandSavingsCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualDemandSavingsCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualDemandSavingsCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualDemandSavingsCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualDemandSavingsCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualDemandSavingsCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualDemandSavingsCostType


class AnnualWaterSavingsType93(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterSavingsType93)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterSavingsType93.subclass:
            return AnnualWaterSavingsType93.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterSavingsType93(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType93', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterSavingsType93')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterSavingsType93', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterSavingsType93'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterSavingsType93', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterSavingsType93


class AnnualWaterCostSavingsType94(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualWaterCostSavingsType94)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualWaterCostSavingsType94.subclass:
            return AnnualWaterCostSavingsType94.subclass(*args_, **kwargs_)
        else:
            return AnnualWaterCostSavingsType94(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType94', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualWaterCostSavingsType94')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualWaterCostSavingsType94', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualWaterCostSavingsType94'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualWaterCostSavingsType94', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualWaterCostSavingsType94


class OMCostAnnualSavingsType95(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OMCostAnnualSavingsType95)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OMCostAnnualSavingsType95.subclass:
            return OMCostAnnualSavingsType95.subclass(*args_, **kwargs_)
        else:
            return OMCostAnnualSavingsType95(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OMCostAnnualSavingsType95', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OMCostAnnualSavingsType95')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OMCostAnnualSavingsType95', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OMCostAnnualSavingsType95'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OMCostAnnualSavingsType95', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OMCostAnnualSavingsType95


class OtherCostAnnualSavingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherCostAnnualSavingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherCostAnnualSavingsType.subclass:
            return OtherCostAnnualSavingsType.subclass(*args_, **kwargs_)
        else:
            return OtherCostAnnualSavingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherCostAnnualSavingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherCostAnnualSavingsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherCostAnnualSavingsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherCostAnnualSavingsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherCostAnnualSavingsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OtherCostAnnualSavingsType


class EquipmentDisposalAndSalvageCostsType96(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EquipmentDisposalAndSalvageCostsType96)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EquipmentDisposalAndSalvageCostsType96.subclass:
            return EquipmentDisposalAndSalvageCostsType96.subclass(*args_, **kwargs_)
        else:
            return EquipmentDisposalAndSalvageCostsType96(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType96', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EquipmentDisposalAndSalvageCostsType96')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType96', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType96'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EquipmentDisposalAndSalvageCostsType96', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EquipmentDisposalAndSalvageCostsType96


class FundingFromIncentivesType97(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FundingFromIncentivesType97)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FundingFromIncentivesType97.subclass:
            return FundingFromIncentivesType97.subclass(*args_, **kwargs_)
        else:
            return FundingFromIncentivesType97(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FundingFromIncentivesType97', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FundingFromIncentivesType97')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FundingFromIncentivesType97', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FundingFromIncentivesType97'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FundingFromIncentivesType97', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FundingFromIncentivesType97


class FundingFromTaxCreditsType98(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FundingFromTaxCreditsType98)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FundingFromTaxCreditsType98.subclass:
            return FundingFromTaxCreditsType98.subclass(*args_, **kwargs_)
        else:
            return FundingFromTaxCreditsType98(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FundingFromTaxCreditsType98', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FundingFromTaxCreditsType98')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FundingFromTaxCreditsType98', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FundingFromTaxCreditsType98'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FundingFromTaxCreditsType98', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FundingFromTaxCreditsType98


class NPVofTaxImplicationsType99(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NPVofTaxImplicationsType99)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NPVofTaxImplicationsType99.subclass:
            return NPVofTaxImplicationsType99.subclass(*args_, **kwargs_)
        else:
            return NPVofTaxImplicationsType99(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NPVofTaxImplicationsType99', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NPVofTaxImplicationsType99')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NPVofTaxImplicationsType99', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NPVofTaxImplicationsType99'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NPVofTaxImplicationsType99', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NPVofTaxImplicationsType99


class SimplePaybackType100(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePaybackType100)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePaybackType100.subclass:
            return SimplePaybackType100.subclass(*args_, **kwargs_)
        else:
            return SimplePaybackType100(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimplePaybackType100', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePaybackType100')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimplePaybackType100', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimplePaybackType100'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimplePaybackType100', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SimplePaybackType100


class NetPresentValueType101(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetPresentValueType101)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetPresentValueType101.subclass:
            return NetPresentValueType101.subclass(*args_, **kwargs_)
        else:
            return NetPresentValueType101(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetPresentValueType101', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetPresentValueType101')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetPresentValueType101', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetPresentValueType101'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetPresentValueType101', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetPresentValueType101


class InternalRateOfReturnType102(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternalRateOfReturnType102)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternalRateOfReturnType102.subclass:
            return InternalRateOfReturnType102.subclass(*args_, **kwargs_)
        else:
            return InternalRateOfReturnType102(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType102', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternalRateOfReturnType102')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InternalRateOfReturnType102', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InternalRateOfReturnType102'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InternalRateOfReturnType102', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InternalRateOfReturnType102


class MVCostType103(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MVCostType103)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MVCostType103.subclass:
            return MVCostType103.subclass(*args_, **kwargs_)
        else:
            return MVCostType103(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MVCostType103', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MVCostType103')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MVCostType103', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MVCostType103'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MVCostType103', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MVCostType103


class UsefulLifeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsefulLifeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsefulLifeType.subclass:
            return UsefulLifeType.subclass(*args_, **kwargs_)
        else:
            return UsefulLifeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UsefulLifeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsefulLifeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UsefulLifeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UsefulLifeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UsefulLifeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UsefulLifeType


class MeasureFirstCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureFirstCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureFirstCostType.subclass:
            return MeasureFirstCostType.subclass(*args_, **kwargs_)
        else:
            return MeasureFirstCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasureFirstCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureFirstCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasureFirstCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasureFirstCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasureFirstCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasureFirstCostType


class CapitalReplacementCostType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CapitalReplacementCostType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CapitalReplacementCostType.subclass:
            return CapitalReplacementCostType.subclass(*args_, **kwargs_)
        else:
            return CapitalReplacementCostType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CapitalReplacementCostType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapitalReplacementCostType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CapitalReplacementCostType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CapitalReplacementCostType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CapitalReplacementCostType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CapitalReplacementCostType


class ResidualValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidualValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidualValueType.subclass:
            return ResidualValueType.subclass(*args_, **kwargs_)
        else:
            return ResidualValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ResidualValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResidualValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ResidualValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ResidualValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ResidualValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ResidualValueType


class PlantsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HeatingPlantType=None, CoolingPlantType=None, CondenserPlant=None):
        self.original_tagname_ = None
        if HeatingPlantType is None:
            self.HeatingPlantType = []
        else:
            self.HeatingPlantType = HeatingPlantType
        if CoolingPlantType is None:
            self.CoolingPlantType = []
        else:
            self.CoolingPlantType = CoolingPlantType
        if CondenserPlant is None:
            self.CondenserPlant = []
        else:
            self.CondenserPlant = CondenserPlant
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlantsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlantsType.subclass:
            return PlantsType.subclass(*args_, **kwargs_)
        else:
            return PlantsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HeatingPlantType or
            self.CoolingPlantType or
            self.CondenserPlant
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlantsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlantsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlantsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlantsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlantsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HeatingPlantType_ in self.HeatingPlantType:
            HeatingPlantType_.export(outfile, level, namespace_, name_='HeatingPlantType', pretty_print=pretty_print)
        for CoolingPlantType_ in self.CoolingPlantType:
            CoolingPlantType_.export(outfile, level, namespace_, name_='CoolingPlantType', pretty_print=pretty_print)
        for CondenserPlant_ in self.CondenserPlant:
            CondenserPlant_.export(outfile, level, namespace_, name_='CondenserPlant', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatingPlantType':
            obj_ = HeatingPlantTypeType.factory()
            obj_.build(child_)
            self.HeatingPlantType.append(obj_)
            obj_.original_tagname_ = 'HeatingPlantType'
        elif nodeName_ == 'CoolingPlantType':
            obj_ = CoolingPlantTypeType.factory()
            obj_.build(child_)
            self.CoolingPlantType.append(obj_)
            obj_.original_tagname_ = 'CoolingPlantType'
        elif nodeName_ == 'CondenserPlant':
            obj_ = CondenserPlantType.factory()
            obj_.build(child_)
            self.CondenserPlant.append(obj_)
            obj_.original_tagname_ = 'CondenserPlant'
# end class PlantsType


class HeatingPlantTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, Boiler=None, DistrictHeating=None, SolarThermal=None, OtherCombination=None, NoHeating=None, Unknown=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.Boiler = Boiler
        self.DistrictHeating = DistrictHeating
        self.SolarThermal = SolarThermal
        self.OtherCombination = OtherCombination
        self.NoHeating = NoHeating
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingPlantTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingPlantTypeType.subclass:
            return HeatingPlantTypeType.subclass(*args_, **kwargs_)
        else:
            return HeatingPlantTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Boiler is not None or
            self.DistrictHeating is not None or
            self.SolarThermal is not None or
            self.OtherCombination is not None or
            self.NoHeating is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingPlantTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingPlantTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingPlantTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingPlantTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingPlantTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Boiler is not None:
            self.Boiler.export(outfile, level, namespace_, name_='Boiler', pretty_print=pretty_print)
        if self.DistrictHeating is not None:
            self.DistrictHeating.export(outfile, level, namespace_, name_='DistrictHeating', pretty_print=pretty_print)
        if self.SolarThermal is not None:
            self.SolarThermal.export(outfile, level, namespace_, name_='SolarThermal', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.NoHeating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoHeating>%s</%sNoHeating>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NoHeating), input_name='NoHeating')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boiler':
            obj_ = BoilerType104.factory()
            obj_.build(child_)
            self.Boiler = obj_
            obj_.original_tagname_ = 'Boiler'
        elif nodeName_ == 'DistrictHeating':
            obj_ = DistrictHeatingType105.factory()
            obj_.build(child_)
            self.DistrictHeating = obj_
            obj_.original_tagname_ = 'DistrictHeating'
        elif nodeName_ == 'SolarThermal':
            obj_ = SolarThermalType.factory()
            obj_.build(child_)
            self.SolarThermal = obj_
            obj_.original_tagname_ = 'SolarThermal'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'NoHeating':
            NoHeating_ = child_.text
            NoHeating_ = self.gds_validate_string(NoHeating_, node, 'NoHeating')
            self.NoHeating = NoHeating_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class HeatingPlantTypeType


class NoHeating(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoHeating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoHeating.subclass:
            return NoHeating.subclass(*args_, **kwargs_)
        else:
            return NoHeating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NoHeating', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoHeating')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NoHeating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NoHeating'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NoHeating', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoHeating


class BoilerType104(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BoilerType=None, BurnerType=None, BurnerTurndownRatio=None, IgnitionType=None, DraftType=None, CondensingOperation=None, HeatingStaging=None, InputCapacity=None, OutputCapacity=None, CapacityUnits=None, NumberOfHeatingStages=None, HeatingStageCapacityFraction=None, Priority=None, AnnualHeatingEfficiencyValue=None, AnnualHeatingEfficiencyUnit=None, CombustionEfficiency=None, ThermalEfficiency=None, ThirdPartyCertification=None, BoilerInsulationRValue=None, BoilerInsulationThickness=None, HotWaterBoilerMinimumFlowRate=None, HotWaterBoilerMaximumFlowRate=None, BoilerEWT=None, BoilerLWT=None, HotWaterResetControl=None, SteamBoilerMinimumOperatingPressure=None, SteamBoilerMaximumOperatingPressure=None, BoilerPercentCondensateReturn=None, Quantity=None):
        self.original_tagname_ = None
        self.BoilerType = BoilerType
        self.validate_BoilerTypeType(self.BoilerType)
        self.BurnerType = BurnerType
        self.validate_BurnerType(self.BurnerType)
        self.BurnerTurndownRatio = BurnerTurndownRatio
        self.IgnitionType = IgnitionType
        self.validate_IgnitionType(self.IgnitionType)
        self.DraftType = DraftType
        self.validate_DraftType(self.DraftType)
        self.CondensingOperation = CondensingOperation
        self.HeatingStaging = HeatingStaging
        self.validate_HeatingStaging(self.HeatingStaging)
        self.InputCapacity = InputCapacity
        self.OutputCapacity = OutputCapacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.NumberOfHeatingStages = NumberOfHeatingStages
        self.HeatingStageCapacityFraction = HeatingStageCapacityFraction
        self.Priority = Priority
        self.validate_Priority(self.Priority)
        self.AnnualHeatingEfficiencyValue = AnnualHeatingEfficiencyValue
        self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit
        self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        self.CombustionEfficiency = CombustionEfficiency
        self.ThermalEfficiency = ThermalEfficiency
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.BoilerInsulationRValue = BoilerInsulationRValue
        self.BoilerInsulationThickness = BoilerInsulationThickness
        self.HotWaterBoilerMinimumFlowRate = HotWaterBoilerMinimumFlowRate
        self.HotWaterBoilerMaximumFlowRate = HotWaterBoilerMaximumFlowRate
        self.BoilerEWT = BoilerEWT
        self.BoilerLWT = BoilerLWT
        self.HotWaterResetControl = HotWaterResetControl
        self.validate_HotWaterResetControlType(self.HotWaterResetControl)
        self.SteamBoilerMinimumOperatingPressure = SteamBoilerMinimumOperatingPressure
        self.SteamBoilerMaximumOperatingPressure = SteamBoilerMaximumOperatingPressure
        self.BoilerPercentCondensateReturn = BoilerPercentCondensateReturn
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerType104)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerType104.subclass:
            return BoilerType104.subclass(*args_, **kwargs_)
        else:
            return BoilerType104(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BoilerTypeType(self, value):
        # Validate type BoilerTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Steam', 'Hot water', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BoilerTypeType' % {"value" : value.encode("utf-8")} )
    def validate_BurnerType(self, value):
        # Validate type BurnerType, a restriction on xs:string.
        pass
    def validate_IgnitionType(self, value):
        # Validate type IgnitionType, a restriction on xs:string.
        pass
    def validate_DraftType(self, value):
        # Validate type DraftType, a restriction on xs:string.
        pass
    def validate_HeatingStaging(self, value):
        # Validate type HeatingStaging, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_Priority(self, value):
        # Validate type Priority, a restriction on xs:string.
        pass
    def validate_AnnualHeatingEfficiencyUnit(self, value):
        # Validate type AnnualHeatingEfficiencyUnit, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_HotWaterResetControlType(self, value):
        # Validate type HotWaterResetControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['During the day', 'At night', 'During sleeping and unoccupied hours', 'Seasonal', 'Never-rarely', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HotWaterResetControlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BoilerType is not None or
            self.BurnerType is not None or
            self.BurnerTurndownRatio is not None or
            self.IgnitionType is not None or
            self.DraftType is not None or
            self.CondensingOperation is not None or
            self.HeatingStaging is not None or
            self.InputCapacity is not None or
            self.OutputCapacity is not None or
            self.CapacityUnits is not None or
            self.NumberOfHeatingStages is not None or
            self.HeatingStageCapacityFraction is not None or
            self.Priority is not None or
            self.AnnualHeatingEfficiencyValue is not None or
            self.AnnualHeatingEfficiencyUnit is not None or
            self.CombustionEfficiency is not None or
            self.ThermalEfficiency is not None or
            self.ThirdPartyCertification is not None or
            self.BoilerInsulationRValue is not None or
            self.BoilerInsulationThickness is not None or
            self.HotWaterBoilerMinimumFlowRate is not None or
            self.HotWaterBoilerMaximumFlowRate is not None or
            self.BoilerEWT is not None or
            self.BoilerLWT is not None or
            self.HotWaterResetControl is not None or
            self.SteamBoilerMinimumOperatingPressure is not None or
            self.SteamBoilerMaximumOperatingPressure is not None or
            self.BoilerPercentCondensateReturn is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerType104', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerType104')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerType104', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerType104'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerType104', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BoilerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBoilerType>%s</%sBoilerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BoilerType), input_name='BoilerType')), namespace_, eol_))
        if self.BurnerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBurnerType>%s</%sBurnerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BurnerType), input_name='BurnerType')), namespace_, eol_))
        if self.BurnerTurndownRatio is not None:
            self.BurnerTurndownRatio.export(outfile, level, namespace_, name_='BurnerTurndownRatio', pretty_print=pretty_print)
        if self.IgnitionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIgnitionType>%s</%sIgnitionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IgnitionType), input_name='IgnitionType')), namespace_, eol_))
        if self.DraftType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDraftType>%s</%sDraftType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DraftType), input_name='DraftType')), namespace_, eol_))
        if self.CondensingOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCondensingOperation>%s</%sCondensingOperation>%s' % (namespace_, self.gds_format_boolean(self.CondensingOperation, input_name='CondensingOperation'), namespace_, eol_))
        if self.HeatingStaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatingStaging>%s</%sHeatingStaging>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatingStaging), input_name='HeatingStaging')), namespace_, eol_))
        if self.InputCapacity is not None:
            self.InputCapacity.export(outfile, level, namespace_, name_='InputCapacity', pretty_print=pretty_print)
        if self.OutputCapacity is not None:
            self.OutputCapacity.export(outfile, level, namespace_, name_='OutputCapacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.NumberOfHeatingStages is not None:
            self.NumberOfHeatingStages.export(outfile, level, namespace_, name_='NumberOfHeatingStages', pretty_print=pretty_print)
        if self.HeatingStageCapacityFraction is not None:
            self.HeatingStageCapacityFraction.export(outfile, level, namespace_, name_='HeatingStageCapacityFraction', pretty_print=pretty_print)
        if self.Priority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPriority>%s</%sPriority>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Priority), input_name='Priority')), namespace_, eol_))
        if self.AnnualHeatingEfficiencyValue is not None:
            self.AnnualHeatingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualHeatingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualHeatingEfficiencyUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualHeatingEfficiencyUnit>%s</%sAnnualHeatingEfficiencyUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualHeatingEfficiencyUnit), input_name='AnnualHeatingEfficiencyUnit')), namespace_, eol_))
        if self.CombustionEfficiency is not None:
            self.CombustionEfficiency.export(outfile, level, namespace_, name_='CombustionEfficiency', pretty_print=pretty_print)
        if self.ThermalEfficiency is not None:
            self.ThermalEfficiency.export(outfile, level, namespace_, name_='ThermalEfficiency', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.BoilerInsulationRValue is not None:
            self.BoilerInsulationRValue.export(outfile, level, namespace_, name_='BoilerInsulationRValue', pretty_print=pretty_print)
        if self.BoilerInsulationThickness is not None:
            self.BoilerInsulationThickness.export(outfile, level, namespace_, name_='BoilerInsulationThickness', pretty_print=pretty_print)
        if self.HotWaterBoilerMinimumFlowRate is not None:
            self.HotWaterBoilerMinimumFlowRate.export(outfile, level, namespace_, name_='HotWaterBoilerMinimumFlowRate', pretty_print=pretty_print)
        if self.HotWaterBoilerMaximumFlowRate is not None:
            self.HotWaterBoilerMaximumFlowRate.export(outfile, level, namespace_, name_='HotWaterBoilerMaximumFlowRate', pretty_print=pretty_print)
        if self.BoilerEWT is not None:
            self.BoilerEWT.export(outfile, level, namespace_, name_='BoilerEWT', pretty_print=pretty_print)
        if self.BoilerLWT is not None:
            self.BoilerLWT.export(outfile, level, namespace_, name_='BoilerLWT', pretty_print=pretty_print)
        if self.HotWaterResetControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHotWaterResetControl>%s</%sHotWaterResetControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HotWaterResetControl), input_name='HotWaterResetControl')), namespace_, eol_))
        if self.SteamBoilerMinimumOperatingPressure is not None:
            self.SteamBoilerMinimumOperatingPressure.export(outfile, level, namespace_, name_='SteamBoilerMinimumOperatingPressure', pretty_print=pretty_print)
        if self.SteamBoilerMaximumOperatingPressure is not None:
            self.SteamBoilerMaximumOperatingPressure.export(outfile, level, namespace_, name_='SteamBoilerMaximumOperatingPressure', pretty_print=pretty_print)
        if self.BoilerPercentCondensateReturn is not None:
            self.BoilerPercentCondensateReturn.export(outfile, level, namespace_, name_='BoilerPercentCondensateReturn', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BoilerType':
            BoilerType_ = child_.text
            BoilerType_ = self.gds_validate_string(BoilerType_, node, 'BoilerType')
            self.BoilerType = BoilerType_
            # validate type BoilerTypeType
            self.validate_BoilerTypeType(self.BoilerType)
        elif nodeName_ == 'BurnerType':
            BurnerType_ = child_.text
            BurnerType_ = self.gds_validate_string(BurnerType_, node, 'BurnerType')
            self.BurnerType = BurnerType_
            # validate type BurnerType
            self.validate_BurnerType(self.BurnerType)
        elif nodeName_ == 'BurnerTurndownRatio':
            obj_ = BurnerTurndownRatioType.factory()
            obj_.build(child_)
            self.BurnerTurndownRatio = obj_
            obj_.original_tagname_ = 'BurnerTurndownRatio'
        elif nodeName_ == 'IgnitionType':
            IgnitionType_ = child_.text
            IgnitionType_ = self.gds_validate_string(IgnitionType_, node, 'IgnitionType')
            self.IgnitionType = IgnitionType_
            # validate type IgnitionType
            self.validate_IgnitionType(self.IgnitionType)
        elif nodeName_ == 'DraftType':
            DraftType_ = child_.text
            DraftType_ = self.gds_validate_string(DraftType_, node, 'DraftType')
            self.DraftType = DraftType_
            # validate type DraftType
            self.validate_DraftType(self.DraftType)
        elif nodeName_ == 'CondensingOperation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CondensingOperation')
            self.CondensingOperation = ival_
        elif nodeName_ == 'HeatingStaging':
            HeatingStaging_ = child_.text
            HeatingStaging_ = self.gds_validate_string(HeatingStaging_, node, 'HeatingStaging')
            self.HeatingStaging = HeatingStaging_
            # validate type HeatingStaging
            self.validate_HeatingStaging(self.HeatingStaging)
        elif nodeName_ == 'InputCapacity':
            obj_ = InputCapacityType.factory()
            obj_.build(child_)
            self.InputCapacity = obj_
            obj_.original_tagname_ = 'InputCapacity'
        elif nodeName_ == 'OutputCapacity':
            obj_ = OutputCapacityType.factory()
            obj_.build(child_)
            self.OutputCapacity = obj_
            obj_.original_tagname_ = 'OutputCapacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'NumberOfHeatingStages':
            obj_ = NumberOfHeatingStagesType.factory()
            obj_.build(child_)
            self.NumberOfHeatingStages = obj_
            obj_.original_tagname_ = 'NumberOfHeatingStages'
        elif nodeName_ == 'HeatingStageCapacityFraction':
            obj_ = HeatingStageCapacityFractionType.factory()
            obj_.build(child_)
            self.HeatingStageCapacityFraction = obj_
            obj_.original_tagname_ = 'HeatingStageCapacityFraction'
        elif nodeName_ == 'Priority':
            Priority_ = child_.text
            Priority_ = self.gds_validate_string(Priority_, node, 'Priority')
            self.Priority = Priority_
            # validate type Priority
            self.validate_Priority(self.Priority)
        elif nodeName_ == 'AnnualHeatingEfficiencyValue':
            obj_ = AnnualHeatingEfficiencyValueType.factory()
            obj_.build(child_)
            self.AnnualHeatingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualHeatingEfficiencyValue'
        elif nodeName_ == 'AnnualHeatingEfficiencyUnit':
            AnnualHeatingEfficiencyUnit_ = child_.text
            AnnualHeatingEfficiencyUnit_ = self.gds_validate_string(AnnualHeatingEfficiencyUnit_, node, 'AnnualHeatingEfficiencyUnit')
            self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit_
            # validate type AnnualHeatingEfficiencyUnit
            self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        elif nodeName_ == 'CombustionEfficiency':
            obj_ = CombustionEfficiencyType.factory()
            obj_.build(child_)
            self.CombustionEfficiency = obj_
            obj_.original_tagname_ = 'CombustionEfficiency'
        elif nodeName_ == 'ThermalEfficiency':
            obj_ = ThermalEfficiencyType.factory()
            obj_.build(child_)
            self.ThermalEfficiency = obj_
            obj_.original_tagname_ = 'ThermalEfficiency'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'BoilerInsulationRValue':
            obj_ = BoilerInsulationRValueType.factory()
            obj_.build(child_)
            self.BoilerInsulationRValue = obj_
            obj_.original_tagname_ = 'BoilerInsulationRValue'
        elif nodeName_ == 'BoilerInsulationThickness':
            obj_ = BoilerInsulationThicknessType.factory()
            obj_.build(child_)
            self.BoilerInsulationThickness = obj_
            obj_.original_tagname_ = 'BoilerInsulationThickness'
        elif nodeName_ == 'HotWaterBoilerMinimumFlowRate':
            obj_ = HotWaterBoilerMinimumFlowRateType.factory()
            obj_.build(child_)
            self.HotWaterBoilerMinimumFlowRate = obj_
            obj_.original_tagname_ = 'HotWaterBoilerMinimumFlowRate'
        elif nodeName_ == 'HotWaterBoilerMaximumFlowRate':
            obj_ = HotWaterBoilerMaximumFlowRateType.factory()
            obj_.build(child_)
            self.HotWaterBoilerMaximumFlowRate = obj_
            obj_.original_tagname_ = 'HotWaterBoilerMaximumFlowRate'
        elif nodeName_ == 'BoilerEWT':
            obj_ = BoilerEWTType.factory()
            obj_.build(child_)
            self.BoilerEWT = obj_
            obj_.original_tagname_ = 'BoilerEWT'
        elif nodeName_ == 'BoilerLWT':
            obj_ = BoilerLWTType.factory()
            obj_.build(child_)
            self.BoilerLWT = obj_
            obj_.original_tagname_ = 'BoilerLWT'
        elif nodeName_ == 'HotWaterResetControl':
            HotWaterResetControl_ = child_.text
            HotWaterResetControl_ = self.gds_validate_string(HotWaterResetControl_, node, 'HotWaterResetControl')
            self.HotWaterResetControl = HotWaterResetControl_
            # validate type HotWaterResetControlType
            self.validate_HotWaterResetControlType(self.HotWaterResetControl)
        elif nodeName_ == 'SteamBoilerMinimumOperatingPressure':
            obj_ = SteamBoilerMinimumOperatingPressureType.factory()
            obj_.build(child_)
            self.SteamBoilerMinimumOperatingPressure = obj_
            obj_.original_tagname_ = 'SteamBoilerMinimumOperatingPressure'
        elif nodeName_ == 'SteamBoilerMaximumOperatingPressure':
            obj_ = SteamBoilerMaximumOperatingPressureType.factory()
            obj_.build(child_)
            self.SteamBoilerMaximumOperatingPressure = obj_
            obj_.original_tagname_ = 'SteamBoilerMaximumOperatingPressure'
        elif nodeName_ == 'BoilerPercentCondensateReturn':
            obj_ = BoilerPercentCondensateReturnType.factory()
            obj_.build(child_)
            self.BoilerPercentCondensateReturn = obj_
            obj_.original_tagname_ = 'BoilerPercentCondensateReturn'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class BoilerType104


class BurnerTurndownRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BurnerTurndownRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BurnerTurndownRatioType.subclass:
            return BurnerTurndownRatioType.subclass(*args_, **kwargs_)
        else:
            return BurnerTurndownRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BurnerTurndownRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BurnerTurndownRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BurnerTurndownRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BurnerTurndownRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BurnerTurndownRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BurnerTurndownRatioType


class InputCapacityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputCapacityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputCapacityType.subclass:
            return InputCapacityType.subclass(*args_, **kwargs_)
        else:
            return InputCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InputCapacityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InputCapacityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InputCapacityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InputCapacityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InputCapacityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InputCapacityType


class OutputCapacityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputCapacityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputCapacityType.subclass:
            return OutputCapacityType.subclass(*args_, **kwargs_)
        else:
            return OutputCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutputCapacityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputCapacityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutputCapacityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutputCapacityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutputCapacityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutputCapacityType


class NumberOfHeatingStagesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfHeatingStagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfHeatingStagesType.subclass:
            return NumberOfHeatingStagesType.subclass(*args_, **kwargs_)
        else:
            return NumberOfHeatingStagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfHeatingStagesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfHeatingStagesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfHeatingStagesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfHeatingStagesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfHeatingStagesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfHeatingStagesType


class HeatingStageCapacityFractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingStageCapacityFractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingStageCapacityFractionType.subclass:
            return HeatingStageCapacityFractionType.subclass(*args_, **kwargs_)
        else:
            return HeatingStageCapacityFractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingStageCapacityFractionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingStageCapacityFractionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingStageCapacityFractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingStageCapacityFractionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingStageCapacityFractionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingStageCapacityFractionType


class AnnualHeatingEfficiencyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingEfficiencyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingEfficiencyValueType.subclass:
            return AnnualHeatingEfficiencyValueType.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingEfficiencyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingEfficiencyValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingEfficiencyValueType


class CombustionEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombustionEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombustionEfficiencyType.subclass:
            return CombustionEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return CombustionEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CombustionEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombustionEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CombustionEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CombustionEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CombustionEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CombustionEfficiencyType


class ThermalEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalEfficiencyType.subclass:
            return ThermalEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return ThermalEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ThermalEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ThermalEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ThermalEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ThermalEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalEfficiencyType


class BoilerInsulationRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerInsulationRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerInsulationRValueType.subclass:
            return BoilerInsulationRValueType.subclass(*args_, **kwargs_)
        else:
            return BoilerInsulationRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerInsulationRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerInsulationRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerInsulationRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerInsulationRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerInsulationRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerInsulationRValueType


class BoilerInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerInsulationThicknessType.subclass:
            return BoilerInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return BoilerInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerInsulationThicknessType


class HotWaterBoilerMinimumFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HotWaterBoilerMinimumFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HotWaterBoilerMinimumFlowRateType.subclass:
            return HotWaterBoilerMinimumFlowRateType.subclass(*args_, **kwargs_)
        else:
            return HotWaterBoilerMinimumFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMinimumFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HotWaterBoilerMinimumFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HotWaterBoilerMinimumFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HotWaterBoilerMinimumFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMinimumFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HotWaterBoilerMinimumFlowRateType


class HotWaterBoilerMaximumFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HotWaterBoilerMaximumFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HotWaterBoilerMaximumFlowRateType.subclass:
            return HotWaterBoilerMaximumFlowRateType.subclass(*args_, **kwargs_)
        else:
            return HotWaterBoilerMaximumFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HotWaterBoilerMaximumFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HotWaterBoilerMaximumFlowRateType


class BoilerEWTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerEWTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerEWTType.subclass:
            return BoilerEWTType.subclass(*args_, **kwargs_)
        else:
            return BoilerEWTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerEWTType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerEWTType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerEWTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerEWTType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerEWTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerEWTType


class BoilerLWTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerLWTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerLWTType.subclass:
            return BoilerLWTType.subclass(*args_, **kwargs_)
        else:
            return BoilerLWTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerLWTType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerLWTType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerLWTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerLWTType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerLWTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerLWTType


class SteamBoilerMinimumOperatingPressureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SteamBoilerMinimumOperatingPressureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SteamBoilerMinimumOperatingPressureType.subclass:
            return SteamBoilerMinimumOperatingPressureType.subclass(*args_, **kwargs_)
        else:
            return SteamBoilerMinimumOperatingPressureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SteamBoilerMinimumOperatingPressureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SteamBoilerMinimumOperatingPressureType


class SteamBoilerMaximumOperatingPressureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SteamBoilerMaximumOperatingPressureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SteamBoilerMaximumOperatingPressureType.subclass:
            return SteamBoilerMaximumOperatingPressureType.subclass(*args_, **kwargs_)
        else:
            return SteamBoilerMaximumOperatingPressureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SteamBoilerMaximumOperatingPressureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SteamBoilerMaximumOperatingPressureType


class BoilerPercentCondensateReturnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerPercentCondensateReturnType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerPercentCondensateReturnType.subclass:
            return BoilerPercentCondensateReturnType.subclass(*args_, **kwargs_)
        else:
            return BoilerPercentCondensateReturnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerPercentCondensateReturnType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerPercentCondensateReturnType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerPercentCondensateReturnType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerPercentCondensateReturnType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerPercentCondensateReturnType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerPercentCondensateReturnType


class DistrictHeatingType105(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DistrictHeatingType=None, OutputCapacity=None, CapacityUnits=None, AnnualHeatingEfficiencyValue=None, AnnualHeatingEfficiencyUnit=None, HotWaterBoilerMaximumFlowRate=None, BoilerLWT=None, SteamBoilerMinimumOperatingPressure=None, SteamBoilerMaximumOperatingPressure=None, Quantity=None):
        self.original_tagname_ = None
        self.DistrictHeatingType = DistrictHeatingType
        self.validate_DistrictHeatingTypeType(self.DistrictHeatingType)
        self.OutputCapacity = OutputCapacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.AnnualHeatingEfficiencyValue = AnnualHeatingEfficiencyValue
        self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit
        self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        self.HotWaterBoilerMaximumFlowRate = HotWaterBoilerMaximumFlowRate
        self.BoilerLWT = BoilerLWT
        self.SteamBoilerMinimumOperatingPressure = SteamBoilerMinimumOperatingPressure
        self.SteamBoilerMaximumOperatingPressure = SteamBoilerMaximumOperatingPressure
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistrictHeatingType105)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistrictHeatingType105.subclass:
            return DistrictHeatingType105.subclass(*args_, **kwargs_)
        else:
            return DistrictHeatingType105(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DistrictHeatingTypeType(self, value):
        # Validate type DistrictHeatingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hot water', 'Direct steam', 'Steam to hot water heat exchanger', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DistrictHeatingTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_AnnualHeatingEfficiencyUnit(self, value):
        # Validate type AnnualHeatingEfficiencyUnit, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DistrictHeatingType is not None or
            self.OutputCapacity is not None or
            self.CapacityUnits is not None or
            self.AnnualHeatingEfficiencyValue is not None or
            self.AnnualHeatingEfficiencyUnit is not None or
            self.HotWaterBoilerMaximumFlowRate is not None or
            self.BoilerLWT is not None or
            self.SteamBoilerMinimumOperatingPressure is not None or
            self.SteamBoilerMaximumOperatingPressure is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DistrictHeatingType105', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistrictHeatingType105')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DistrictHeatingType105', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DistrictHeatingType105'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DistrictHeatingType105', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DistrictHeatingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDistrictHeatingType>%s</%sDistrictHeatingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DistrictHeatingType), input_name='DistrictHeatingType')), namespace_, eol_))
        if self.OutputCapacity is not None:
            self.OutputCapacity.export(outfile, level, namespace_, name_='OutputCapacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.AnnualHeatingEfficiencyValue is not None:
            self.AnnualHeatingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualHeatingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualHeatingEfficiencyUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualHeatingEfficiencyUnit>%s</%sAnnualHeatingEfficiencyUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualHeatingEfficiencyUnit), input_name='AnnualHeatingEfficiencyUnit')), namespace_, eol_))
        if self.HotWaterBoilerMaximumFlowRate is not None:
            self.HotWaterBoilerMaximumFlowRate.export(outfile, level, namespace_, name_='HotWaterBoilerMaximumFlowRate', pretty_print=pretty_print)
        if self.BoilerLWT is not None:
            self.BoilerLWT.export(outfile, level, namespace_, name_='BoilerLWT', pretty_print=pretty_print)
        if self.SteamBoilerMinimumOperatingPressure is not None:
            self.SteamBoilerMinimumOperatingPressure.export(outfile, level, namespace_, name_='SteamBoilerMinimumOperatingPressure', pretty_print=pretty_print)
        if self.SteamBoilerMaximumOperatingPressure is not None:
            self.SteamBoilerMaximumOperatingPressure.export(outfile, level, namespace_, name_='SteamBoilerMaximumOperatingPressure', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DistrictHeatingType':
            DistrictHeatingType_ = child_.text
            DistrictHeatingType_ = self.gds_validate_string(DistrictHeatingType_, node, 'DistrictHeatingType')
            self.DistrictHeatingType = DistrictHeatingType_
            # validate type DistrictHeatingTypeType
            self.validate_DistrictHeatingTypeType(self.DistrictHeatingType)
        elif nodeName_ == 'OutputCapacity':
            obj_ = OutputCapacityType106.factory()
            obj_.build(child_)
            self.OutputCapacity = obj_
            obj_.original_tagname_ = 'OutputCapacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'AnnualHeatingEfficiencyValue':
            obj_ = AnnualHeatingEfficiencyValueType107.factory()
            obj_.build(child_)
            self.AnnualHeatingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualHeatingEfficiencyValue'
        elif nodeName_ == 'AnnualHeatingEfficiencyUnit':
            AnnualHeatingEfficiencyUnit_ = child_.text
            AnnualHeatingEfficiencyUnit_ = self.gds_validate_string(AnnualHeatingEfficiencyUnit_, node, 'AnnualHeatingEfficiencyUnit')
            self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit_
            # validate type AnnualHeatingEfficiencyUnit
            self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        elif nodeName_ == 'HotWaterBoilerMaximumFlowRate':
            obj_ = HotWaterBoilerMaximumFlowRateType108.factory()
            obj_.build(child_)
            self.HotWaterBoilerMaximumFlowRate = obj_
            obj_.original_tagname_ = 'HotWaterBoilerMaximumFlowRate'
        elif nodeName_ == 'BoilerLWT':
            obj_ = BoilerLWTType109.factory()
            obj_.build(child_)
            self.BoilerLWT = obj_
            obj_.original_tagname_ = 'BoilerLWT'
        elif nodeName_ == 'SteamBoilerMinimumOperatingPressure':
            obj_ = SteamBoilerMinimumOperatingPressureType110.factory()
            obj_.build(child_)
            self.SteamBoilerMinimumOperatingPressure = obj_
            obj_.original_tagname_ = 'SteamBoilerMinimumOperatingPressure'
        elif nodeName_ == 'SteamBoilerMaximumOperatingPressure':
            obj_ = SteamBoilerMaximumOperatingPressureType111.factory()
            obj_.build(child_)
            self.SteamBoilerMaximumOperatingPressure = obj_
            obj_.original_tagname_ = 'SteamBoilerMaximumOperatingPressure'
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class DistrictHeatingType105


class OutputCapacityType106(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputCapacityType106)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputCapacityType106.subclass:
            return OutputCapacityType106.subclass(*args_, **kwargs_)
        else:
            return OutputCapacityType106(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutputCapacityType106', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputCapacityType106')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutputCapacityType106', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutputCapacityType106'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutputCapacityType106', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutputCapacityType106


class AnnualHeatingEfficiencyValueType107(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingEfficiencyValueType107)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingEfficiencyValueType107.subclass:
            return AnnualHeatingEfficiencyValueType107.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingEfficiencyValueType107(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType107', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingEfficiencyValueType107')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType107', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType107'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType107', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingEfficiencyValueType107


class HotWaterBoilerMaximumFlowRateType108(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HotWaterBoilerMaximumFlowRateType108)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HotWaterBoilerMaximumFlowRateType108.subclass:
            return HotWaterBoilerMaximumFlowRateType108.subclass(*args_, **kwargs_)
        else:
            return HotWaterBoilerMaximumFlowRateType108(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType108', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HotWaterBoilerMaximumFlowRateType108')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType108', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType108'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HotWaterBoilerMaximumFlowRateType108', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HotWaterBoilerMaximumFlowRateType108


class BoilerLWTType109(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoilerLWTType109)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoilerLWTType109.subclass:
            return BoilerLWTType109.subclass(*args_, **kwargs_)
        else:
            return BoilerLWTType109(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BoilerLWTType109', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoilerLWTType109')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BoilerLWTType109', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BoilerLWTType109'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BoilerLWTType109', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BoilerLWTType109


class SteamBoilerMinimumOperatingPressureType110(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SteamBoilerMinimumOperatingPressureType110)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SteamBoilerMinimumOperatingPressureType110.subclass:
            return SteamBoilerMinimumOperatingPressureType110.subclass(*args_, **kwargs_)
        else:
            return SteamBoilerMinimumOperatingPressureType110(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType110', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SteamBoilerMinimumOperatingPressureType110')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType110', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType110'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SteamBoilerMinimumOperatingPressureType110', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SteamBoilerMinimumOperatingPressureType110


class SteamBoilerMaximumOperatingPressureType111(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SteamBoilerMaximumOperatingPressureType111)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SteamBoilerMaximumOperatingPressureType111.subclass:
            return SteamBoilerMaximumOperatingPressureType111.subclass(*args_, **kwargs_)
        else:
            return SteamBoilerMaximumOperatingPressureType111(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType111', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SteamBoilerMaximumOperatingPressureType111')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType111', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType111'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SteamBoilerMaximumOperatingPressureType111', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SteamBoilerMaximumOperatingPressureType111


class SolarThermalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OutputCapacity=None, CapacityUnits=None, AnnualHeatingEfficiencyValue=None, AnnualHeatingEfficiencyUnit=None, Quantity=None):
        self.original_tagname_ = None
        self.OutputCapacity = OutputCapacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.AnnualHeatingEfficiencyValue = AnnualHeatingEfficiencyValue
        self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit
        self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarThermalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarThermalType.subclass:
            return SolarThermalType.subclass(*args_, **kwargs_)
        else:
            return SolarThermalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_AnnualHeatingEfficiencyUnit(self, value):
        # Validate type AnnualHeatingEfficiencyUnit, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.OutputCapacity is not None or
            self.CapacityUnits is not None or
            self.AnnualHeatingEfficiencyValue is not None or
            self.AnnualHeatingEfficiencyUnit is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarThermalType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarThermalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarThermalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarThermalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarThermalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OutputCapacity is not None:
            self.OutputCapacity.export(outfile, level, namespace_, name_='OutputCapacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.AnnualHeatingEfficiencyValue is not None:
            self.AnnualHeatingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualHeatingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualHeatingEfficiencyUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualHeatingEfficiencyUnit>%s</%sAnnualHeatingEfficiencyUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualHeatingEfficiencyUnit), input_name='AnnualHeatingEfficiencyUnit')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OutputCapacity':
            obj_ = OutputCapacityType112.factory()
            obj_.build(child_)
            self.OutputCapacity = obj_
            obj_.original_tagname_ = 'OutputCapacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'AnnualHeatingEfficiencyValue':
            obj_ = AnnualHeatingEfficiencyValueType113.factory()
            obj_.build(child_)
            self.AnnualHeatingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualHeatingEfficiencyValue'
        elif nodeName_ == 'AnnualHeatingEfficiencyUnit':
            AnnualHeatingEfficiencyUnit_ = child_.text
            AnnualHeatingEfficiencyUnit_ = self.gds_validate_string(AnnualHeatingEfficiencyUnit_, node, 'AnnualHeatingEfficiencyUnit')
            self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit_
            # validate type AnnualHeatingEfficiencyUnit
            self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class SolarThermalType


class OutputCapacityType112(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputCapacityType112)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputCapacityType112.subclass:
            return OutputCapacityType112.subclass(*args_, **kwargs_)
        else:
            return OutputCapacityType112(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutputCapacityType112', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputCapacityType112')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutputCapacityType112', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutputCapacityType112'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutputCapacityType112', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutputCapacityType112


class AnnualHeatingEfficiencyValueType113(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingEfficiencyValueType113)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingEfficiencyValueType113.subclass:
            return AnnualHeatingEfficiencyValueType113.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingEfficiencyValueType113(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType113', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingEfficiencyValueType113')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType113', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType113'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType113', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingEfficiencyValueType113


class HeatingAndCoolingSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZoningSystemType=None, HeatingSource=None, CoolingSource=None, Delivery=None):
        self.original_tagname_ = None
        self.ZoningSystemType = ZoningSystemType
        self.validate_ZoningSystemTypeType(self.ZoningSystemType)
        if HeatingSource is None:
            self.HeatingSource = []
        else:
            self.HeatingSource = HeatingSource
        if CoolingSource is None:
            self.CoolingSource = []
        else:
            self.CoolingSource = CoolingSource
        if Delivery is None:
            self.Delivery = []
        else:
            self.Delivery = Delivery
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingAndCoolingSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingAndCoolingSystemsType.subclass:
            return HeatingAndCoolingSystemsType.subclass(*args_, **kwargs_)
        else:
            return HeatingAndCoolingSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ZoningSystemTypeType(self, value):
        # Validate type ZoningSystemTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Single zone', 'Multi zone', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ZoningSystemTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ZoningSystemType is not None or
            self.HeatingSource or
            self.CoolingSource or
            self.Delivery
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingAndCoolingSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingAndCoolingSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingAndCoolingSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingAndCoolingSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingAndCoolingSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZoningSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZoningSystemType>%s</%sZoningSystemType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ZoningSystemType), input_name='ZoningSystemType')), namespace_, eol_))
        for HeatingSource_ in self.HeatingSource:
            HeatingSource_.export(outfile, level, namespace_, name_='HeatingSource', pretty_print=pretty_print)
        for CoolingSource_ in self.CoolingSource:
            CoolingSource_.export(outfile, level, namespace_, name_='CoolingSource', pretty_print=pretty_print)
        for Delivery_ in self.Delivery:
            Delivery_.export(outfile, level, namespace_, name_='Delivery', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZoningSystemType':
            ZoningSystemType_ = child_.text
            ZoningSystemType_ = self.gds_validate_string(ZoningSystemType_, node, 'ZoningSystemType')
            self.ZoningSystemType = ZoningSystemType_
            # validate type ZoningSystemTypeType
            self.validate_ZoningSystemTypeType(self.ZoningSystemType)
        elif nodeName_ == 'HeatingSource':
            obj_ = HeatingSourceType114.factory()
            obj_.build(child_)
            self.HeatingSource.append(obj_)
            obj_.original_tagname_ = 'HeatingSource'
        elif nodeName_ == 'CoolingSource':
            obj_ = CoolingSourceType125.factory()
            obj_.build(child_)
            self.CoolingSource.append(obj_)
            obj_.original_tagname_ = 'CoolingSource'
        elif nodeName_ == 'Delivery':
            obj_ = DeliveryType126.factory()
            obj_.build(child_)
            self.Delivery.append(obj_)
            obj_.original_tagname_ = 'Delivery'
# end class HeatingAndCoolingSystemsType


class HeatingSourceType114(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, HeatingSourceType=None, HeatingMedium=None, AnnualHeatingEfficiencyValue=None, AnnualHeatingEfficiencyUnit=None, InputCapacity=None, OutputCapacity=None, CapacityUnits=None, HeatingStaging=None, NumberOfHeatingStages=None, HeatingStageCapacityFraction=None, PrimaryFuel=None, ControlTechnology=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.HeatingSourceType = HeatingSourceType
        self.HeatingMedium = HeatingMedium
        self.validate_HeatingMediumType(self.HeatingMedium)
        self.AnnualHeatingEfficiencyValue = AnnualHeatingEfficiencyValue
        self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit
        self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        self.InputCapacity = InputCapacity
        self.OutputCapacity = OutputCapacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.HeatingStaging = HeatingStaging
        self.validate_HeatingStaging(self.HeatingStaging)
        self.NumberOfHeatingStages = NumberOfHeatingStages
        self.HeatingStageCapacityFraction = HeatingStageCapacityFraction
        self.PrimaryFuel = PrimaryFuel
        self.validate_FuelTypes(self.PrimaryFuel)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingSourceType114)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingSourceType114.subclass:
            return HeatingSourceType114.subclass(*args_, **kwargs_)
        else:
            return HeatingSourceType114(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HeatingMediumType(self, value):
        # Validate type HeatingMediumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hot water', 'Steam', 'Refrigerant', 'Air', 'Glycol', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeatingMediumType' % {"value" : value.encode("utf-8")} )
    def validate_AnnualHeatingEfficiencyUnit(self, value):
        # Validate type AnnualHeatingEfficiencyUnit, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_HeatingStaging(self, value):
        # Validate type HeatingStaging, a restriction on xs:string.
        pass
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.HeatingSourceType is not None or
            self.HeatingMedium is not None or
            self.AnnualHeatingEfficiencyValue is not None or
            self.AnnualHeatingEfficiencyUnit is not None or
            self.InputCapacity is not None or
            self.OutputCapacity is not None or
            self.CapacityUnits is not None or
            self.HeatingStaging is not None or
            self.NumberOfHeatingStages is not None or
            self.HeatingStageCapacityFraction is not None or
            self.PrimaryFuel is not None or
            self.ControlTechnology is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingSourceType114', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingSourceType114')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingSourceType114', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingSourceType114'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingSourceType114', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeatingSourceType is not None:
            self.HeatingSourceType.export(outfile, level, namespace_, name_='HeatingSourceType', pretty_print=pretty_print)
        if self.HeatingMedium is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatingMedium>%s</%sHeatingMedium>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatingMedium), input_name='HeatingMedium')), namespace_, eol_))
        if self.AnnualHeatingEfficiencyValue is not None:
            self.AnnualHeatingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualHeatingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualHeatingEfficiencyUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualHeatingEfficiencyUnit>%s</%sAnnualHeatingEfficiencyUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualHeatingEfficiencyUnit), input_name='AnnualHeatingEfficiencyUnit')), namespace_, eol_))
        if self.InputCapacity is not None:
            self.InputCapacity.export(outfile, level, namespace_, name_='InputCapacity', pretty_print=pretty_print)
        if self.OutputCapacity is not None:
            self.OutputCapacity.export(outfile, level, namespace_, name_='OutputCapacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.HeatingStaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatingStaging>%s</%sHeatingStaging>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatingStaging), input_name='HeatingStaging')), namespace_, eol_))
        if self.NumberOfHeatingStages is not None:
            self.NumberOfHeatingStages.export(outfile, level, namespace_, name_='NumberOfHeatingStages', pretty_print=pretty_print)
        if self.HeatingStageCapacityFraction is not None:
            self.HeatingStageCapacityFraction.export(outfile, level, namespace_, name_='HeatingStageCapacityFraction', pretty_print=pretty_print)
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatingSourceType':
            obj_ = HeatingSourceTypeType.factory()
            obj_.build(child_)
            self.HeatingSourceType = obj_
            obj_.original_tagname_ = 'HeatingSourceType'
        elif nodeName_ == 'HeatingMedium':
            HeatingMedium_ = child_.text
            HeatingMedium_ = self.gds_validate_string(HeatingMedium_, node, 'HeatingMedium')
            self.HeatingMedium = HeatingMedium_
            # validate type HeatingMediumType
            self.validate_HeatingMediumType(self.HeatingMedium)
        elif nodeName_ == 'AnnualHeatingEfficiencyValue':
            obj_ = AnnualHeatingEfficiencyValueType120.factory()
            obj_.build(child_)
            self.AnnualHeatingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualHeatingEfficiencyValue'
        elif nodeName_ == 'AnnualHeatingEfficiencyUnit':
            AnnualHeatingEfficiencyUnit_ = child_.text
            AnnualHeatingEfficiencyUnit_ = self.gds_validate_string(AnnualHeatingEfficiencyUnit_, node, 'AnnualHeatingEfficiencyUnit')
            self.AnnualHeatingEfficiencyUnit = AnnualHeatingEfficiencyUnit_
            # validate type AnnualHeatingEfficiencyUnit
            self.validate_AnnualHeatingEfficiencyUnit(self.AnnualHeatingEfficiencyUnit)
        elif nodeName_ == 'InputCapacity':
            obj_ = InputCapacityType121.factory()
            obj_.build(child_)
            self.InputCapacity = obj_
            obj_.original_tagname_ = 'InputCapacity'
        elif nodeName_ == 'OutputCapacity':
            obj_ = OutputCapacityType122.factory()
            obj_.build(child_)
            self.OutputCapacity = obj_
            obj_.original_tagname_ = 'OutputCapacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'HeatingStaging':
            HeatingStaging_ = child_.text
            HeatingStaging_ = self.gds_validate_string(HeatingStaging_, node, 'HeatingStaging')
            self.HeatingStaging = HeatingStaging_
            # validate type HeatingStaging
            self.validate_HeatingStaging(self.HeatingStaging)
        elif nodeName_ == 'NumberOfHeatingStages':
            obj_ = NumberOfHeatingStagesType123.factory()
            obj_.build(child_)
            self.NumberOfHeatingStages = obj_
            obj_.original_tagname_ = 'NumberOfHeatingStages'
        elif nodeName_ == 'HeatingStageCapacityFraction':
            obj_ = HeatingStageCapacityFractionType124.factory()
            obj_.build(child_)
            self.HeatingStageCapacityFraction = obj_
            obj_.original_tagname_ = 'HeatingStageCapacityFraction'
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.PrimaryFuel)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class HeatingSourceType114


class HeatingSourceTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SourceHeatingPlantID=None, Furnace=None, HeatPump=None, OtherCombination=None, NoHeating=None, Unknown=None):
        self.original_tagname_ = None
        self.SourceHeatingPlantID = SourceHeatingPlantID
        self.Furnace = Furnace
        self.HeatPump = HeatPump
        self.OtherCombination = OtherCombination
        self.NoHeating = NoHeating
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingSourceTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingSourceTypeType.subclass:
            return HeatingSourceTypeType.subclass(*args_, **kwargs_)
        else:
            return HeatingSourceTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SourceHeatingPlantID is not None or
            self.Furnace is not None or
            self.HeatPump is not None or
            self.OtherCombination is not None or
            self.NoHeating is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingSourceTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingSourceTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingSourceTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingSourceTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingSourceTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SourceHeatingPlantID is not None:
            self.SourceHeatingPlantID.export(outfile, level, namespace_, name_='SourceHeatingPlantID', pretty_print=pretty_print)
        if self.Furnace is not None:
            self.Furnace.export(outfile, level, namespace_, name_='Furnace', pretty_print=pretty_print)
        if self.HeatPump is not None:
            self.HeatPump.export(outfile, level, namespace_, name_='HeatPump', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.NoHeating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoHeating>%s</%sNoHeating>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NoHeating), input_name='NoHeating')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SourceHeatingPlantID':
            obj_ = SourceHeatingPlantIDType.factory()
            obj_.build(child_)
            self.SourceHeatingPlantID = obj_
            obj_.original_tagname_ = 'SourceHeatingPlantID'
        elif nodeName_ == 'Furnace':
            obj_ = FurnaceType115.factory()
            obj_.build(child_)
            self.Furnace = obj_
            obj_.original_tagname_ = 'Furnace'
        elif nodeName_ == 'HeatPump':
            obj_ = HeatPumpType119.factory()
            obj_.build(child_)
            self.HeatPump = obj_
            obj_.original_tagname_ = 'HeatPump'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'NoHeating':
            NoHeating_ = child_.text
            NoHeating_ = self.gds_validate_string(NoHeating_, node, 'NoHeating')
            self.NoHeating = NoHeating_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class HeatingSourceTypeType


class SourceHeatingPlantIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceHeatingPlantIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceHeatingPlantIDType.subclass:
            return SourceHeatingPlantIDType.subclass(*args_, **kwargs_)
        else:
            return SourceHeatingPlantIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceHeatingPlantIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceHeatingPlantIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceHeatingPlantIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceHeatingPlantIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceHeatingPlantIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceHeatingPlantIDType


class FurnaceType115(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FurnaceType=None, BurnerType=None, BurnerTurndownRatio=None, IgnitionType=None, DraftType=None, CondensingOperation=None, CombustionEfficiency=None, ThermalEfficiency=None, ThirdPartyCertification=None):
        self.original_tagname_ = None
        self.FurnaceType = FurnaceType
        self.validate_FurnaceTypeType(self.FurnaceType)
        self.BurnerType = BurnerType
        self.validate_BurnerType(self.BurnerType)
        self.BurnerTurndownRatio = BurnerTurndownRatio
        self.IgnitionType = IgnitionType
        self.validate_IgnitionType(self.IgnitionType)
        self.DraftType = DraftType
        self.validate_DraftType(self.DraftType)
        self.CondensingOperation = CondensingOperation
        self.CombustionEfficiency = CombustionEfficiency
        self.ThermalEfficiency = ThermalEfficiency
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FurnaceType115)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FurnaceType115.subclass:
            return FurnaceType115.subclass(*args_, **kwargs_)
        else:
            return FurnaceType115(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FurnaceTypeType(self, value):
        # Validate type FurnaceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Warm air', 'Fireplace', 'Heating stove', 'Built-in heater', 'Individual space heater', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FurnaceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_BurnerType(self, value):
        # Validate type BurnerType, a restriction on xs:string.
        pass
    def validate_IgnitionType(self, value):
        # Validate type IgnitionType, a restriction on xs:string.
        pass
    def validate_DraftType(self, value):
        # Validate type DraftType, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FurnaceType is not None or
            self.BurnerType is not None or
            self.BurnerTurndownRatio is not None or
            self.IgnitionType is not None or
            self.DraftType is not None or
            self.CondensingOperation is not None or
            self.CombustionEfficiency is not None or
            self.ThermalEfficiency is not None or
            self.ThirdPartyCertification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FurnaceType115', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FurnaceType115')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FurnaceType115', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FurnaceType115'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FurnaceType115', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FurnaceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFurnaceType>%s</%sFurnaceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FurnaceType), input_name='FurnaceType')), namespace_, eol_))
        if self.BurnerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBurnerType>%s</%sBurnerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BurnerType), input_name='BurnerType')), namespace_, eol_))
        if self.BurnerTurndownRatio is not None:
            self.BurnerTurndownRatio.export(outfile, level, namespace_, name_='BurnerTurndownRatio', pretty_print=pretty_print)
        if self.IgnitionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIgnitionType>%s</%sIgnitionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.IgnitionType), input_name='IgnitionType')), namespace_, eol_))
        if self.DraftType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDraftType>%s</%sDraftType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DraftType), input_name='DraftType')), namespace_, eol_))
        if self.CondensingOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCondensingOperation>%s</%sCondensingOperation>%s' % (namespace_, self.gds_format_boolean(self.CondensingOperation, input_name='CondensingOperation'), namespace_, eol_))
        if self.CombustionEfficiency is not None:
            self.CombustionEfficiency.export(outfile, level, namespace_, name_='CombustionEfficiency', pretty_print=pretty_print)
        if self.ThermalEfficiency is not None:
            self.ThermalEfficiency.export(outfile, level, namespace_, name_='ThermalEfficiency', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FurnaceType':
            FurnaceType_ = child_.text
            FurnaceType_ = self.gds_validate_string(FurnaceType_, node, 'FurnaceType')
            self.FurnaceType = FurnaceType_
            # validate type FurnaceTypeType
            self.validate_FurnaceTypeType(self.FurnaceType)
        elif nodeName_ == 'BurnerType':
            BurnerType_ = child_.text
            BurnerType_ = self.gds_validate_string(BurnerType_, node, 'BurnerType')
            self.BurnerType = BurnerType_
            # validate type BurnerType
            self.validate_BurnerType(self.BurnerType)
        elif nodeName_ == 'BurnerTurndownRatio':
            obj_ = BurnerTurndownRatioType116.factory()
            obj_.build(child_)
            self.BurnerTurndownRatio = obj_
            obj_.original_tagname_ = 'BurnerTurndownRatio'
        elif nodeName_ == 'IgnitionType':
            IgnitionType_ = child_.text
            IgnitionType_ = self.gds_validate_string(IgnitionType_, node, 'IgnitionType')
            self.IgnitionType = IgnitionType_
            # validate type IgnitionType
            self.validate_IgnitionType(self.IgnitionType)
        elif nodeName_ == 'DraftType':
            DraftType_ = child_.text
            DraftType_ = self.gds_validate_string(DraftType_, node, 'DraftType')
            self.DraftType = DraftType_
            # validate type DraftType
            self.validate_DraftType(self.DraftType)
        elif nodeName_ == 'CondensingOperation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CondensingOperation')
            self.CondensingOperation = ival_
        elif nodeName_ == 'CombustionEfficiency':
            obj_ = CombustionEfficiencyType117.factory()
            obj_.build(child_)
            self.CombustionEfficiency = obj_
            obj_.original_tagname_ = 'CombustionEfficiency'
        elif nodeName_ == 'ThermalEfficiency':
            obj_ = ThermalEfficiencyType118.factory()
            obj_.build(child_)
            self.ThermalEfficiency = obj_
            obj_.original_tagname_ = 'ThermalEfficiency'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
# end class FurnaceType115


class BurnerTurndownRatioType116(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BurnerTurndownRatioType116)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BurnerTurndownRatioType116.subclass:
            return BurnerTurndownRatioType116.subclass(*args_, **kwargs_)
        else:
            return BurnerTurndownRatioType116(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BurnerTurndownRatioType116', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BurnerTurndownRatioType116')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BurnerTurndownRatioType116', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BurnerTurndownRatioType116'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BurnerTurndownRatioType116', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BurnerTurndownRatioType116


class CombustionEfficiencyType117(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombustionEfficiencyType117)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombustionEfficiencyType117.subclass:
            return CombustionEfficiencyType117.subclass(*args_, **kwargs_)
        else:
            return CombustionEfficiencyType117(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CombustionEfficiencyType117', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombustionEfficiencyType117')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CombustionEfficiencyType117', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CombustionEfficiencyType117'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CombustionEfficiencyType117', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CombustionEfficiencyType117


class ThermalEfficiencyType118(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThermalEfficiencyType118)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThermalEfficiencyType118.subclass:
            return ThermalEfficiencyType118.subclass(*args_, **kwargs_)
        else:
            return ThermalEfficiencyType118(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ThermalEfficiencyType118', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermalEfficiencyType118')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ThermalEfficiencyType118', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ThermalEfficiencyType118'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ThermalEfficiencyType118', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ThermalEfficiencyType118


class HeatPumpType119(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HeatPumpType=None, HeatPumpBackupHeatingSwitchoverTemperature=None, HeatPumpBackupSystemFuel=None, HeatPumpBackupAFUE=None, ThirdPartyCertification=None, CoolingSourceID=None, LinkedHeatingPlantID=None):
        self.original_tagname_ = None
        self.HeatPumpType = HeatPumpType
        self.validate_HeatPumpTypeType(self.HeatPumpType)
        self.HeatPumpBackupHeatingSwitchoverTemperature = HeatPumpBackupHeatingSwitchoverTemperature
        self.HeatPumpBackupSystemFuel = HeatPumpBackupSystemFuel
        self.validate_FuelTypes(self.HeatPumpBackupSystemFuel)
        self.HeatPumpBackupAFUE = HeatPumpBackupAFUE
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.CoolingSourceID = CoolingSourceID
        self.LinkedHeatingPlantID = LinkedHeatingPlantID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatPumpType119)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatPumpType119.subclass:
            return HeatPumpType119.subclass(*args_, **kwargs_)
        else:
            return HeatPumpType119(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HeatPumpTypeType(self, value):
        # Validate type HeatPumpTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Split', 'Packaged Terminal', 'Packaged Unitary', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeatPumpTypeType' % {"value" : value.encode("utf-8")} )
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.HeatPumpType is not None or
            self.HeatPumpBackupHeatingSwitchoverTemperature is not None or
            self.HeatPumpBackupSystemFuel is not None or
            self.HeatPumpBackupAFUE is not None or
            self.ThirdPartyCertification is not None or
            self.CoolingSourceID is not None or
            self.LinkedHeatingPlantID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatPumpType119', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatPumpType119')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatPumpType119', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatPumpType119'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatPumpType119', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeatPumpType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatPumpType>%s</%sHeatPumpType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatPumpType), input_name='HeatPumpType')), namespace_, eol_))
        if self.HeatPumpBackupHeatingSwitchoverTemperature is not None:
            self.HeatPumpBackupHeatingSwitchoverTemperature.export(outfile, level, namespace_, name_='HeatPumpBackupHeatingSwitchoverTemperature', pretty_print=pretty_print)
        if self.HeatPumpBackupSystemFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatPumpBackupSystemFuel>%s</%sHeatPumpBackupSystemFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatPumpBackupSystemFuel), input_name='HeatPumpBackupSystemFuel')), namespace_, eol_))
        if self.HeatPumpBackupAFUE is not None:
            self.HeatPumpBackupAFUE.export(outfile, level, namespace_, name_='HeatPumpBackupAFUE', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.CoolingSourceID is not None:
            self.CoolingSourceID.export(outfile, level, namespace_, name_='CoolingSourceID', pretty_print=pretty_print)
        if self.LinkedHeatingPlantID is not None:
            self.LinkedHeatingPlantID.export(outfile, level, namespace_, name_='LinkedHeatingPlantID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatPumpType':
            HeatPumpType_ = child_.text
            HeatPumpType_ = self.gds_validate_string(HeatPumpType_, node, 'HeatPumpType')
            self.HeatPumpType = HeatPumpType_
            # validate type HeatPumpTypeType
            self.validate_HeatPumpTypeType(self.HeatPumpType)
        elif nodeName_ == 'HeatPumpBackupHeatingSwitchoverTemperature':
            obj_ = HeatPumpBackupHeatingSwitchoverTemperatureType.factory()
            obj_.build(child_)
            self.HeatPumpBackupHeatingSwitchoverTemperature = obj_
            obj_.original_tagname_ = 'HeatPumpBackupHeatingSwitchoverTemperature'
        elif nodeName_ == 'HeatPumpBackupSystemFuel':
            HeatPumpBackupSystemFuel_ = child_.text
            HeatPumpBackupSystemFuel_ = self.gds_validate_string(HeatPumpBackupSystemFuel_, node, 'HeatPumpBackupSystemFuel')
            self.HeatPumpBackupSystemFuel = HeatPumpBackupSystemFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.HeatPumpBackupSystemFuel)
        elif nodeName_ == 'HeatPumpBackupAFUE':
            obj_ = HeatPumpBackupAFUEType.factory()
            obj_.build(child_)
            self.HeatPumpBackupAFUE = obj_
            obj_.original_tagname_ = 'HeatPumpBackupAFUE'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'CoolingSourceID':
            obj_ = CoolingSourceIDType.factory()
            obj_.build(child_)
            self.CoolingSourceID = obj_
            obj_.original_tagname_ = 'CoolingSourceID'
        elif nodeName_ == 'LinkedHeatingPlantID':
            obj_ = LinkedHeatingPlantIDType.factory()
            obj_.build(child_)
            self.LinkedHeatingPlantID = obj_
            obj_.original_tagname_ = 'LinkedHeatingPlantID'
# end class HeatPumpType119


class HeatPumpBackupHeatingSwitchoverTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatPumpBackupHeatingSwitchoverTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatPumpBackupHeatingSwitchoverTemperatureType.subclass:
            return HeatPumpBackupHeatingSwitchoverTemperatureType.subclass(*args_, **kwargs_)
        else:
            return HeatPumpBackupHeatingSwitchoverTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatPumpBackupHeatingSwitchoverTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatPumpBackupHeatingSwitchoverTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatPumpBackupHeatingSwitchoverTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatPumpBackupHeatingSwitchoverTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatPumpBackupHeatingSwitchoverTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatPumpBackupHeatingSwitchoverTemperatureType


class HeatPumpBackupAFUEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatPumpBackupAFUEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatPumpBackupAFUEType.subclass:
            return HeatPumpBackupAFUEType.subclass(*args_, **kwargs_)
        else:
            return HeatPumpBackupAFUEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatPumpBackupAFUEType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatPumpBackupAFUEType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatPumpBackupAFUEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatPumpBackupAFUEType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatPumpBackupAFUEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatPumpBackupAFUEType


class CoolingSourceIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingSourceIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingSourceIDType.subclass:
            return CoolingSourceIDType.subclass(*args_, **kwargs_)
        else:
            return CoolingSourceIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingSourceIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingSourceIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingSourceIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingSourceIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingSourceIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingSourceIDType


class LinkedHeatingPlantIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedHeatingPlantIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedHeatingPlantIDType.subclass:
            return LinkedHeatingPlantIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedHeatingPlantIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedHeatingPlantIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedHeatingPlantIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedHeatingPlantIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedHeatingPlantIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedHeatingPlantIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedHeatingPlantIDType


class AnnualHeatingEfficiencyValueType120(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualHeatingEfficiencyValueType120)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualHeatingEfficiencyValueType120.subclass:
            return AnnualHeatingEfficiencyValueType120.subclass(*args_, **kwargs_)
        else:
            return AnnualHeatingEfficiencyValueType120(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType120', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualHeatingEfficiencyValueType120')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType120', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType120'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualHeatingEfficiencyValueType120', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualHeatingEfficiencyValueType120


class InputCapacityType121(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InputCapacityType121)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InputCapacityType121.subclass:
            return InputCapacityType121.subclass(*args_, **kwargs_)
        else:
            return InputCapacityType121(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InputCapacityType121', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InputCapacityType121')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InputCapacityType121', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InputCapacityType121'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InputCapacityType121', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InputCapacityType121


class OutputCapacityType122(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputCapacityType122)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputCapacityType122.subclass:
            return OutputCapacityType122.subclass(*args_, **kwargs_)
        else:
            return OutputCapacityType122(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutputCapacityType122', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputCapacityType122')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutputCapacityType122', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutputCapacityType122'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutputCapacityType122', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutputCapacityType122


class NumberOfHeatingStagesType123(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfHeatingStagesType123)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfHeatingStagesType123.subclass:
            return NumberOfHeatingStagesType123.subclass(*args_, **kwargs_)
        else:
            return NumberOfHeatingStagesType123(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfHeatingStagesType123', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfHeatingStagesType123')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfHeatingStagesType123', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfHeatingStagesType123'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfHeatingStagesType123', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfHeatingStagesType123


class HeatingStageCapacityFractionType124(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingStageCapacityFractionType124)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingStageCapacityFractionType124.subclass:
            return HeatingStageCapacityFractionType124.subclass(*args_, **kwargs_)
        else:
            return HeatingStageCapacityFractionType124(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingStageCapacityFractionType124', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingStageCapacityFractionType124')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingStageCapacityFractionType124', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingStageCapacityFractionType124'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingStageCapacityFractionType124', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingStageCapacityFractionType124


class CoolingSourceType125(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, CoolingSourceType=None, CoolingMedium=None, AnnualCoolingEfficiencyValue=None, AnnualCoolingEfficiencyUnits=None, Capacity=None, CapacityUnits=None, NumberOfDiscreteCoolingStages=None, CoolingStageCapacity=None, MinimumPartLoadRatio=None, RatedCoolingSensibleHeatRatio=None, ThirdPartyCertification=None, PrimaryFuel=None, ControlTechnology=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.CoolingSourceType = CoolingSourceType
        self.CoolingMedium = CoolingMedium
        self.validate_CoolingMediumType(self.CoolingMedium)
        self.AnnualCoolingEfficiencyValue = AnnualCoolingEfficiencyValue
        self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits
        self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.NumberOfDiscreteCoolingStages = NumberOfDiscreteCoolingStages
        self.CoolingStageCapacity = CoolingStageCapacity
        self.MinimumPartLoadRatio = MinimumPartLoadRatio
        self.RatedCoolingSensibleHeatRatio = RatedCoolingSensibleHeatRatio
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.PrimaryFuel = PrimaryFuel
        self.validate_FuelTypes(self.PrimaryFuel)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingSourceType125)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingSourceType125.subclass:
            return CoolingSourceType125.subclass(*args_, **kwargs_)
        else:
            return CoolingSourceType125(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CoolingMediumType(self, value):
        # Validate type CoolingMediumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Chilled water', 'Refrigerant', 'Air', 'Glycol', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CoolingMediumType' % {"value" : value.encode("utf-8")} )
    def validate_AnnualCoolingEfficiencyUnits(self, value):
        # Validate type AnnualCoolingEfficiencyUnits, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.CoolingSourceType is not None or
            self.CoolingMedium is not None or
            self.AnnualCoolingEfficiencyValue is not None or
            self.AnnualCoolingEfficiencyUnits is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.NumberOfDiscreteCoolingStages is not None or
            self.CoolingStageCapacity is not None or
            self.MinimumPartLoadRatio is not None or
            self.RatedCoolingSensibleHeatRatio is not None or
            self.ThirdPartyCertification is not None or
            self.PrimaryFuel is not None or
            self.ControlTechnology is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingSourceType125', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingSourceType125')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingSourceType125', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingSourceType125'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingSourceType125', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoolingSourceType is not None:
            self.CoolingSourceType.export(outfile, level, namespace_, name_='CoolingSourceType', pretty_print=pretty_print)
        if self.CoolingMedium is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoolingMedium>%s</%sCoolingMedium>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CoolingMedium), input_name='CoolingMedium')), namespace_, eol_))
        if self.AnnualCoolingEfficiencyValue is not None:
            self.AnnualCoolingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualCoolingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualCoolingEfficiencyUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualCoolingEfficiencyUnits>%s</%sAnnualCoolingEfficiencyUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualCoolingEfficiencyUnits), input_name='AnnualCoolingEfficiencyUnits')), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.NumberOfDiscreteCoolingStages is not None:
            self.NumberOfDiscreteCoolingStages.export(outfile, level, namespace_, name_='NumberOfDiscreteCoolingStages', pretty_print=pretty_print)
        if self.CoolingStageCapacity is not None:
            self.CoolingStageCapacity.export(outfile, level, namespace_, name_='CoolingStageCapacity', pretty_print=pretty_print)
        if self.MinimumPartLoadRatio is not None:
            self.MinimumPartLoadRatio.export(outfile, level, namespace_, name_='MinimumPartLoadRatio', pretty_print=pretty_print)
        if self.RatedCoolingSensibleHeatRatio is not None:
            self.RatedCoolingSensibleHeatRatio.export(outfile, level, namespace_, name_='RatedCoolingSensibleHeatRatio', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoolingSourceType':
            obj_ = CoolingSourceTypeType.factory()
            obj_.build(child_)
            self.CoolingSourceType = obj_
            obj_.original_tagname_ = 'CoolingSourceType'
        elif nodeName_ == 'CoolingMedium':
            CoolingMedium_ = child_.text
            CoolingMedium_ = self.gds_validate_string(CoolingMedium_, node, 'CoolingMedium')
            self.CoolingMedium = CoolingMedium_
            # validate type CoolingMediumType
            self.validate_CoolingMediumType(self.CoolingMedium)
        elif nodeName_ == 'AnnualCoolingEfficiencyValue':
            obj_ = AnnualCoolingEfficiencyValueType.factory()
            obj_.build(child_)
            self.AnnualCoolingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualCoolingEfficiencyValue'
        elif nodeName_ == 'AnnualCoolingEfficiencyUnits':
            AnnualCoolingEfficiencyUnits_ = child_.text
            AnnualCoolingEfficiencyUnits_ = self.gds_validate_string(AnnualCoolingEfficiencyUnits_, node, 'AnnualCoolingEfficiencyUnits')
            self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits_
            # validate type AnnualCoolingEfficiencyUnits
            self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'NumberOfDiscreteCoolingStages':
            obj_ = NumberOfDiscreteCoolingStagesType.factory()
            obj_.build(child_)
            self.NumberOfDiscreteCoolingStages = obj_
            obj_.original_tagname_ = 'NumberOfDiscreteCoolingStages'
        elif nodeName_ == 'CoolingStageCapacity':
            obj_ = CoolingStageCapacityType.factory()
            obj_.build(child_)
            self.CoolingStageCapacity = obj_
            obj_.original_tagname_ = 'CoolingStageCapacity'
        elif nodeName_ == 'MinimumPartLoadRatio':
            obj_ = MinimumPartLoadRatioType.factory()
            obj_.build(child_)
            self.MinimumPartLoadRatio = obj_
            obj_.original_tagname_ = 'MinimumPartLoadRatio'
        elif nodeName_ == 'RatedCoolingSensibleHeatRatio':
            obj_ = RatedCoolingSensibleHeatRatioType.factory()
            obj_.build(child_)
            self.RatedCoolingSensibleHeatRatio = obj_
            obj_.original_tagname_ = 'RatedCoolingSensibleHeatRatio'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.PrimaryFuel)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class CoolingSourceType125


class CoolingSourceTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CoolingPlantID=None, DX=None, EvaporativeCooler=None, OtherCombination=None, NoCooling=None, Unknown=None):
        self.original_tagname_ = None
        self.CoolingPlantID = CoolingPlantID
        self.DX = DX
        self.EvaporativeCooler = EvaporativeCooler
        self.OtherCombination = OtherCombination
        self.NoCooling = NoCooling
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingSourceTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingSourceTypeType.subclass:
            return CoolingSourceTypeType.subclass(*args_, **kwargs_)
        else:
            return CoolingSourceTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CoolingPlantID is not None or
            self.DX is not None or
            self.EvaporativeCooler is not None or
            self.OtherCombination is not None or
            self.NoCooling is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingSourceTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingSourceTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingSourceTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingSourceTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingSourceTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoolingPlantID is not None:
            self.CoolingPlantID.export(outfile, level, namespace_, name_='CoolingPlantID', pretty_print=pretty_print)
        if self.DX is not None:
            self.DX.export(outfile, level, namespace_, name_='DX', pretty_print=pretty_print)
        if self.EvaporativeCooler is not None:
            self.EvaporativeCooler.export(outfile, level, namespace_, name_='EvaporativeCooler', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.NoCooling is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoCooling>%s</%sNoCooling>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NoCooling), input_name='NoCooling')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoolingPlantID':
            obj_ = CoolingPlantIDType.factory()
            obj_.build(child_)
            self.CoolingPlantID = obj_
            obj_.original_tagname_ = 'CoolingPlantID'
        elif nodeName_ == 'DX':
            obj_ = DXType.factory()
            obj_.build(child_)
            self.DX = obj_
            obj_.original_tagname_ = 'DX'
        elif nodeName_ == 'EvaporativeCooler':
            obj_ = EvaporativeCoolerType.factory()
            obj_.build(child_)
            self.EvaporativeCooler = obj_
            obj_.original_tagname_ = 'EvaporativeCooler'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'NoCooling':
            NoCooling_ = child_.text
            NoCooling_ = self.gds_validate_string(NoCooling_, node, 'NoCooling')
            self.NoCooling = NoCooling_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class CoolingSourceTypeType


class NoCooling(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoCooling)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoCooling.subclass:
            return NoCooling.subclass(*args_, **kwargs_)
        else:
            return NoCooling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NoCooling', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoCooling')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NoCooling', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NoCooling'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NoCooling', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoCooling


class CoolingPlantIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingPlantIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingPlantIDType.subclass:
            return CoolingPlantIDType.subclass(*args_, **kwargs_)
        else:
            return CoolingPlantIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingPlantIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingPlantIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingPlantIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingPlantIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingPlantIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingPlantIDType


class DXType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DXSystemType=None, CompressorType=None, CompressorStaging=None, CondenserPlantID=None, Refrigerant=None, RefrigerantChargeFactor=None, ActiveDehumidification=None):
        self.original_tagname_ = None
        self.DXSystemType = DXSystemType
        self.validate_DXSystemTypeType(self.DXSystemType)
        self.CompressorType = CompressorType
        self.validate_CompressorTypeType(self.CompressorType)
        self.CompressorStaging = CompressorStaging
        self.validate_CompressorStaging(self.CompressorStaging)
        if CondenserPlantID is None:
            self.CondenserPlantID = []
        else:
            self.CondenserPlantID = CondenserPlantID
        self.Refrigerant = Refrigerant
        self.validate_Refrigerant(self.Refrigerant)
        self.RefrigerantChargeFactor = RefrigerantChargeFactor
        self.ActiveDehumidification = ActiveDehumidification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DXType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DXType.subclass:
            return DXType.subclass(*args_, **kwargs_)
        else:
            return DXType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DXSystemTypeType(self, value):
        # Validate type DXSystemTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Split DX air conditioner', 'Packaged terminal air conditioner (PTAC)', 'Split heat pump', 'Packaged terminal heat pump (PTHP)', 'Variable refrigerant flow', 'Packaged/unitary direct expansion/RTU', 'Packaged/unitary heat pump', 'Single package vertical air conditioner', 'Single package vertical heat pump', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DXSystemTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CompressorTypeType(self, value):
        # Validate type CompressorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Reciprocating', 'Screw', 'Scroll', 'Centrifugal', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CompressorTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CompressorStaging(self, value):
        # Validate type CompressorStaging, a restriction on xs:string.
        pass
    def validate_Refrigerant(self, value):
        # Validate type Refrigerant, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DXSystemType is not None or
            self.CompressorType is not None or
            self.CompressorStaging is not None or
            self.CondenserPlantID or
            self.Refrigerant is not None or
            self.RefrigerantChargeFactor is not None or
            self.ActiveDehumidification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DXType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DXType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DXType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DXType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DXType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DXSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDXSystemType>%s</%sDXSystemType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DXSystemType), input_name='DXSystemType')), namespace_, eol_))
        if self.CompressorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompressorType>%s</%sCompressorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CompressorType), input_name='CompressorType')), namespace_, eol_))
        if self.CompressorStaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompressorStaging>%s</%sCompressorStaging>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CompressorStaging), input_name='CompressorStaging')), namespace_, eol_))
        for CondenserPlantID_ in self.CondenserPlantID:
            CondenserPlantID_.export(outfile, level, namespace_, name_='CondenserPlantID', pretty_print=pretty_print)
        if self.Refrigerant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerant>%s</%sRefrigerant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Refrigerant), input_name='Refrigerant')), namespace_, eol_))
        if self.RefrigerantChargeFactor is not None:
            self.RefrigerantChargeFactor.export(outfile, level, namespace_, name_='RefrigerantChargeFactor', pretty_print=pretty_print)
        if self.ActiveDehumidification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sActiveDehumidification>%s</%sActiveDehumidification>%s' % (namespace_, self.gds_format_boolean(self.ActiveDehumidification, input_name='ActiveDehumidification'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DXSystemType':
            DXSystemType_ = child_.text
            DXSystemType_ = self.gds_validate_string(DXSystemType_, node, 'DXSystemType')
            self.DXSystemType = DXSystemType_
            # validate type DXSystemTypeType
            self.validate_DXSystemTypeType(self.DXSystemType)
        elif nodeName_ == 'CompressorType':
            CompressorType_ = child_.text
            CompressorType_ = self.gds_validate_string(CompressorType_, node, 'CompressorType')
            self.CompressorType = CompressorType_
            # validate type CompressorTypeType
            self.validate_CompressorTypeType(self.CompressorType)
        elif nodeName_ == 'CompressorStaging':
            CompressorStaging_ = child_.text
            CompressorStaging_ = self.gds_validate_string(CompressorStaging_, node, 'CompressorStaging')
            self.CompressorStaging = CompressorStaging_
            # validate type CompressorStaging
            self.validate_CompressorStaging(self.CompressorStaging)
        elif nodeName_ == 'CondenserPlantID':
            obj_ = CondenserPlantIDType.factory()
            obj_.build(child_)
            self.CondenserPlantID.append(obj_)
            obj_.original_tagname_ = 'CondenserPlantID'
        elif nodeName_ == 'Refrigerant':
            Refrigerant_ = child_.text
            Refrigerant_ = self.gds_validate_string(Refrigerant_, node, 'Refrigerant')
            self.Refrigerant = Refrigerant_
            # validate type Refrigerant
            self.validate_Refrigerant(self.Refrigerant)
        elif nodeName_ == 'RefrigerantChargeFactor':
            obj_ = RefrigerantChargeFactorType.factory()
            obj_.build(child_)
            self.RefrigerantChargeFactor = obj_
            obj_.original_tagname_ = 'RefrigerantChargeFactor'
        elif nodeName_ == 'ActiveDehumidification':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ActiveDehumidification')
            self.ActiveDehumidification = ival_
# end class DXType


class CondenserPlantIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserPlantIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserPlantIDType.subclass:
            return CondenserPlantIDType.subclass(*args_, **kwargs_)
        else:
            return CondenserPlantIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserPlantIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserPlantIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserPlantIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondenserPlantIDType


class RefrigerantChargeFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerantChargeFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerantChargeFactorType.subclass:
            return RefrigerantChargeFactorType.subclass(*args_, **kwargs_)
        else:
            return RefrigerantChargeFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerantChargeFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerantChargeFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerantChargeFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerantChargeFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerantChargeFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RefrigerantChargeFactorType


class EvaporativeCoolerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EvaporativeCoolingType=None):
        self.original_tagname_ = None
        self.EvaporativeCoolingType = EvaporativeCoolingType
        self.validate_EvaporativeCoolingTypeType(self.EvaporativeCoolingType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EvaporativeCoolerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EvaporativeCoolerType.subclass:
            return EvaporativeCoolerType.subclass(*args_, **kwargs_)
        else:
            return EvaporativeCoolerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EvaporativeCoolingTypeType(self, value):
        # Validate type EvaporativeCoolingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Direct', 'Direct indirect', 'Indirect', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EvaporativeCoolingTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EvaporativeCoolingType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EvaporativeCoolerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EvaporativeCoolerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EvaporativeCoolerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EvaporativeCoolerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EvaporativeCoolerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EvaporativeCoolingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEvaporativeCoolingType>%s</%sEvaporativeCoolingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EvaporativeCoolingType), input_name='EvaporativeCoolingType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EvaporativeCoolingType':
            EvaporativeCoolingType_ = child_.text
            EvaporativeCoolingType_ = self.gds_validate_string(EvaporativeCoolingType_, node, 'EvaporativeCoolingType')
            self.EvaporativeCoolingType = EvaporativeCoolingType_
            # validate type EvaporativeCoolingTypeType
            self.validate_EvaporativeCoolingTypeType(self.EvaporativeCoolingType)
# end class EvaporativeCoolerType


class AnnualCoolingEfficiencyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualCoolingEfficiencyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualCoolingEfficiencyValueType.subclass:
            return AnnualCoolingEfficiencyValueType.subclass(*args_, **kwargs_)
        else:
            return AnnualCoolingEfficiencyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualCoolingEfficiencyValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualCoolingEfficiencyValueType


class NumberOfDiscreteCoolingStagesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfDiscreteCoolingStagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfDiscreteCoolingStagesType.subclass:
            return NumberOfDiscreteCoolingStagesType.subclass(*args_, **kwargs_)
        else:
            return NumberOfDiscreteCoolingStagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDiscreteCoolingStagesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDiscreteCoolingStagesType


class CoolingStageCapacityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingStageCapacityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingStageCapacityType.subclass:
            return CoolingStageCapacityType.subclass(*args_, **kwargs_)
        else:
            return CoolingStageCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingStageCapacityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingStageCapacityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingStageCapacityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingStageCapacityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingStageCapacityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingStageCapacityType


class MinimumPartLoadRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumPartLoadRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumPartLoadRatioType.subclass:
            return MinimumPartLoadRatioType.subclass(*args_, **kwargs_)
        else:
            return MinimumPartLoadRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumPartLoadRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumPartLoadRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumPartLoadRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumPartLoadRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumPartLoadRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumPartLoadRatioType


class RatedCoolingSensibleHeatRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatedCoolingSensibleHeatRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatedCoolingSensibleHeatRatioType.subclass:
            return RatedCoolingSensibleHeatRatioType.subclass(*args_, **kwargs_)
        else:
            return RatedCoolingSensibleHeatRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatedCoolingSensibleHeatRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RatedCoolingSensibleHeatRatioType


class DeliveryType126(GeneratedsSuper):
    """Defines whether a system is currently present in the building, or if
    it is a proposed alternative or past system."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, DeliveryType=None, HeatingSourceID=None, CoolingSourceID=None, Capacity=None, CapacityUnits=None, PrimaryFuel=None, ControlTechnology=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, ThirdPartyCertification=None, Quantity=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.DeliveryType = DeliveryType
        self.HeatingSourceID = HeatingSourceID
        self.CoolingSourceID = CoolingSourceID
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.PrimaryFuel = PrimaryFuel
        self.validate_FuelTypes(self.PrimaryFuel)
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryType126)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryType126.subclass:
            return DeliveryType126.subclass(*args_, **kwargs_)
        else:
            return DeliveryType126(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DeliveryType is not None or
            self.HeatingSourceID is not None or
            self.CoolingSourceID is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.PrimaryFuel is not None or
            self.ControlTechnology is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.ThirdPartyCertification is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DeliveryType126', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryType126')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DeliveryType126', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DeliveryType126'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DeliveryType126', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeliveryType is not None:
            self.DeliveryType.export(outfile, level, namespace_, name_='DeliveryType', pretty_print=pretty_print)
        if self.HeatingSourceID is not None:
            self.HeatingSourceID.export(outfile, level, namespace_, name_='HeatingSourceID', pretty_print=pretty_print)
        if self.CoolingSourceID is not None:
            self.CoolingSourceID.export(outfile, level, namespace_, name_='CoolingSourceID', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeliveryType':
            obj_ = DeliveryTypeType.factory()
            obj_.build(child_)
            self.DeliveryType = obj_
            obj_.original_tagname_ = 'DeliveryType'
        elif nodeName_ == 'HeatingSourceID':
            obj_ = HeatingSourceIDType.factory()
            obj_.build(child_)
            self.HeatingSourceID = obj_
            obj_.original_tagname_ = 'HeatingSourceID'
        elif nodeName_ == 'CoolingSourceID':
            obj_ = CoolingSourceIDType136.factory()
            obj_.build(child_)
            self.CoolingSourceID = obj_
            obj_.original_tagname_ = 'CoolingSourceID'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.PrimaryFuel)
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class DeliveryType126


class DeliveryTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FanBased=None, Convection=None, Radiant=None, Other=None):
        self.original_tagname_ = None
        self.FanBased = FanBased
        self.Convection = Convection
        self.Radiant = Radiant
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryTypeType.subclass:
            return DeliveryTypeType.subclass(*args_, **kwargs_)
        else:
            return DeliveryTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FanBased is not None or
            self.Convection is not None or
            self.Radiant is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DeliveryTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DeliveryTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DeliveryTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DeliveryTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FanBased is not None:
            self.FanBased.export(outfile, level, namespace_, name_='FanBased', pretty_print=pretty_print)
        if self.Convection is not None:
            self.Convection.export(outfile, level, namespace_, name_='Convection', pretty_print=pretty_print)
        if self.Radiant is not None:
            self.Radiant.export(outfile, level, namespace_, name_='Radiant', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FanBased':
            obj_ = FanBasedType.factory()
            obj_.build(child_)
            self.FanBased = obj_
            obj_.original_tagname_ = 'FanBased'
        elif nodeName_ == 'Convection':
            obj_ = ConvectionType130.factory()
            obj_.build(child_)
            self.Convection = obj_
            obj_.original_tagname_ = 'Convection'
        elif nodeName_ == 'Radiant':
            obj_ = RadiantType133.factory()
            obj_.build(child_)
            self.Radiant = obj_
            obj_.original_tagname_ = 'Radiant'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class DeliveryTypeType


class FanBasedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FanBasedDistributionType=None, AirSideEconomizer=None, HeatingSupplyAirTemperatureControl=None, CoolingSupplyAirTemperature=None, CoolingSupplyAirTemperatureControlType=None, OutsideAirResetMaximumHeatingSupplyTemperature=None, OutsideAirResetMinimumHeatingSupplyTemperature=None, OutsideAirTemperatureUpperLimitHeatingResetControl=None, OutsideAirTemperatureLowerLimitHeatingResetControl=None, OutsideAirResetMaximumCoolingSupplyTemperature=None, OutsideAirResetMinimumCoolingSupplyTemperature=None, OutsideAirTemperatureUpperLimitCoolingResetControl=None, OutsideAirTemperatureLowerLimitCoolingResetControl=None, HeatingSupplyAirTemperature=None, SupplyAirTemperatureResetControl=None, StaticPressureResetControl=None):
        self.original_tagname_ = None
        self.FanBasedDistributionType = FanBasedDistributionType
        self.AirSideEconomizer = AirSideEconomizer
        self.HeatingSupplyAirTemperatureControl = HeatingSupplyAirTemperatureControl
        self.validate_HeatingSupplyAirTemperatureControlType(self.HeatingSupplyAirTemperatureControl)
        self.CoolingSupplyAirTemperature = CoolingSupplyAirTemperature
        self.CoolingSupplyAirTemperatureControlType = CoolingSupplyAirTemperatureControlType
        self.validate_CoolingSupplyAirTemperatureControlTypeType(self.CoolingSupplyAirTemperatureControlType)
        self.OutsideAirResetMaximumHeatingSupplyTemperature = OutsideAirResetMaximumHeatingSupplyTemperature
        self.OutsideAirResetMinimumHeatingSupplyTemperature = OutsideAirResetMinimumHeatingSupplyTemperature
        self.OutsideAirTemperatureUpperLimitHeatingResetControl = OutsideAirTemperatureUpperLimitHeatingResetControl
        self.OutsideAirTemperatureLowerLimitHeatingResetControl = OutsideAirTemperatureLowerLimitHeatingResetControl
        self.OutsideAirResetMaximumCoolingSupplyTemperature = OutsideAirResetMaximumCoolingSupplyTemperature
        self.OutsideAirResetMinimumCoolingSupplyTemperature = OutsideAirResetMinimumCoolingSupplyTemperature
        self.OutsideAirTemperatureUpperLimitCoolingResetControl = OutsideAirTemperatureUpperLimitCoolingResetControl
        self.OutsideAirTemperatureLowerLimitCoolingResetControl = OutsideAirTemperatureLowerLimitCoolingResetControl
        self.HeatingSupplyAirTemperature = HeatingSupplyAirTemperature
        self.SupplyAirTemperatureResetControl = SupplyAirTemperatureResetControl
        self.StaticPressureResetControl = StaticPressureResetControl
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanBasedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanBasedType.subclass:
            return FanBasedType.subclass(*args_, **kwargs_)
        else:
            return FanBasedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HeatingSupplyAirTemperatureControlType(self, value):
        # Validate type HeatingSupplyAirTemperatureControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Coldest Reset', 'Fixed', 'Outside Air Reset', 'Scheduled', 'Staged Setpoint', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HeatingSupplyAirTemperatureControlType' % {"value" : value.encode("utf-8")} )
    def validate_CoolingSupplyAirTemperatureControlTypeType(self, value):
        # Validate type CoolingSupplyAirTemperatureControlTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fixed', 'Outside Air Reset', 'Scheduled', 'Warmest Reset', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CoolingSupplyAirTemperatureControlTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FanBasedDistributionType is not None or
            self.AirSideEconomizer is not None or
            self.HeatingSupplyAirTemperatureControl is not None or
            self.CoolingSupplyAirTemperature is not None or
            self.CoolingSupplyAirTemperatureControlType is not None or
            self.OutsideAirResetMaximumHeatingSupplyTemperature is not None or
            self.OutsideAirResetMinimumHeatingSupplyTemperature is not None or
            self.OutsideAirTemperatureUpperLimitHeatingResetControl is not None or
            self.OutsideAirTemperatureLowerLimitHeatingResetControl is not None or
            self.OutsideAirResetMaximumCoolingSupplyTemperature is not None or
            self.OutsideAirResetMinimumCoolingSupplyTemperature is not None or
            self.OutsideAirTemperatureUpperLimitCoolingResetControl is not None or
            self.OutsideAirTemperatureLowerLimitCoolingResetControl is not None or
            self.HeatingSupplyAirTemperature is not None or
            self.SupplyAirTemperatureResetControl is not None or
            self.StaticPressureResetControl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanBasedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanBasedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanBasedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanBasedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanBasedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FanBasedDistributionType is not None:
            self.FanBasedDistributionType.export(outfile, level, namespace_, name_='FanBasedDistributionType', pretty_print=pretty_print)
        if self.AirSideEconomizer is not None:
            self.AirSideEconomizer.export(outfile, level, namespace_, name_='AirSideEconomizer', pretty_print=pretty_print)
        if self.HeatingSupplyAirTemperatureControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatingSupplyAirTemperatureControl>%s</%sHeatingSupplyAirTemperatureControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatingSupplyAirTemperatureControl), input_name='HeatingSupplyAirTemperatureControl')), namespace_, eol_))
        if self.CoolingSupplyAirTemperature is not None:
            self.CoolingSupplyAirTemperature.export(outfile, level, namespace_, name_='CoolingSupplyAirTemperature', pretty_print=pretty_print)
        if self.CoolingSupplyAirTemperatureControlType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoolingSupplyAirTemperatureControlType>%s</%sCoolingSupplyAirTemperatureControlType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CoolingSupplyAirTemperatureControlType), input_name='CoolingSupplyAirTemperatureControlType')), namespace_, eol_))
        if self.OutsideAirResetMaximumHeatingSupplyTemperature is not None:
            self.OutsideAirResetMaximumHeatingSupplyTemperature.export(outfile, level, namespace_, name_='OutsideAirResetMaximumHeatingSupplyTemperature', pretty_print=pretty_print)
        if self.OutsideAirResetMinimumHeatingSupplyTemperature is not None:
            self.OutsideAirResetMinimumHeatingSupplyTemperature.export(outfile, level, namespace_, name_='OutsideAirResetMinimumHeatingSupplyTemperature', pretty_print=pretty_print)
        if self.OutsideAirTemperatureUpperLimitHeatingResetControl is not None:
            self.OutsideAirTemperatureUpperLimitHeatingResetControl.export(outfile, level, namespace_, name_='OutsideAirTemperatureUpperLimitHeatingResetControl', pretty_print=pretty_print)
        if self.OutsideAirTemperatureLowerLimitHeatingResetControl is not None:
            self.OutsideAirTemperatureLowerLimitHeatingResetControl.export(outfile, level, namespace_, name_='OutsideAirTemperatureLowerLimitHeatingResetControl', pretty_print=pretty_print)
        if self.OutsideAirResetMaximumCoolingSupplyTemperature is not None:
            self.OutsideAirResetMaximumCoolingSupplyTemperature.export(outfile, level, namespace_, name_='OutsideAirResetMaximumCoolingSupplyTemperature', pretty_print=pretty_print)
        if self.OutsideAirResetMinimumCoolingSupplyTemperature is not None:
            self.OutsideAirResetMinimumCoolingSupplyTemperature.export(outfile, level, namespace_, name_='OutsideAirResetMinimumCoolingSupplyTemperature', pretty_print=pretty_print)
        if self.OutsideAirTemperatureUpperLimitCoolingResetControl is not None:
            self.OutsideAirTemperatureUpperLimitCoolingResetControl.export(outfile, level, namespace_, name_='OutsideAirTemperatureUpperLimitCoolingResetControl', pretty_print=pretty_print)
        if self.OutsideAirTemperatureLowerLimitCoolingResetControl is not None:
            self.OutsideAirTemperatureLowerLimitCoolingResetControl.export(outfile, level, namespace_, name_='OutsideAirTemperatureLowerLimitCoolingResetControl', pretty_print=pretty_print)
        if self.HeatingSupplyAirTemperature is not None:
            self.HeatingSupplyAirTemperature.export(outfile, level, namespace_, name_='HeatingSupplyAirTemperature', pretty_print=pretty_print)
        if self.SupplyAirTemperatureResetControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupplyAirTemperatureResetControl>%s</%sSupplyAirTemperatureResetControl>%s' % (namespace_, self.gds_format_boolean(self.SupplyAirTemperatureResetControl, input_name='SupplyAirTemperatureResetControl'), namespace_, eol_))
        if self.StaticPressureResetControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStaticPressureResetControl>%s</%sStaticPressureResetControl>%s' % (namespace_, self.gds_format_boolean(self.StaticPressureResetControl, input_name='StaticPressureResetControl'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FanBasedDistributionType':
            obj_ = FanBasedDistributionTypeType.factory()
            obj_.build(child_)
            self.FanBasedDistributionType = obj_
            obj_.original_tagname_ = 'FanBasedDistributionType'
        elif nodeName_ == 'AirSideEconomizer':
            obj_ = AirSideEconomizerType128.factory()
            obj_.build(child_)
            self.AirSideEconomizer = obj_
            obj_.original_tagname_ = 'AirSideEconomizer'
        elif nodeName_ == 'HeatingSupplyAirTemperatureControl':
            HeatingSupplyAirTemperatureControl_ = child_.text
            HeatingSupplyAirTemperatureControl_ = self.gds_validate_string(HeatingSupplyAirTemperatureControl_, node, 'HeatingSupplyAirTemperatureControl')
            self.HeatingSupplyAirTemperatureControl = HeatingSupplyAirTemperatureControl_
            # validate type HeatingSupplyAirTemperatureControlType
            self.validate_HeatingSupplyAirTemperatureControlType(self.HeatingSupplyAirTemperatureControl)
        elif nodeName_ == 'CoolingSupplyAirTemperature':
            obj_ = CoolingSupplyAirTemperatureType.factory()
            obj_.build(child_)
            self.CoolingSupplyAirTemperature = obj_
            obj_.original_tagname_ = 'CoolingSupplyAirTemperature'
        elif nodeName_ == 'CoolingSupplyAirTemperatureControlType':
            CoolingSupplyAirTemperatureControlType_ = child_.text
            CoolingSupplyAirTemperatureControlType_ = self.gds_validate_string(CoolingSupplyAirTemperatureControlType_, node, 'CoolingSupplyAirTemperatureControlType')
            self.CoolingSupplyAirTemperatureControlType = CoolingSupplyAirTemperatureControlType_
            # validate type CoolingSupplyAirTemperatureControlTypeType
            self.validate_CoolingSupplyAirTemperatureControlTypeType(self.CoolingSupplyAirTemperatureControlType)
        elif nodeName_ == 'OutsideAirResetMaximumHeatingSupplyTemperature':
            obj_ = OutsideAirResetMaximumHeatingSupplyTemperatureType.factory()
            obj_.build(child_)
            self.OutsideAirResetMaximumHeatingSupplyTemperature = obj_
            obj_.original_tagname_ = 'OutsideAirResetMaximumHeatingSupplyTemperature'
        elif nodeName_ == 'OutsideAirResetMinimumHeatingSupplyTemperature':
            obj_ = OutsideAirResetMinimumHeatingSupplyTemperatureType.factory()
            obj_.build(child_)
            self.OutsideAirResetMinimumHeatingSupplyTemperature = obj_
            obj_.original_tagname_ = 'OutsideAirResetMinimumHeatingSupplyTemperature'
        elif nodeName_ == 'OutsideAirTemperatureUpperLimitHeatingResetControl':
            obj_ = OutsideAirTemperatureUpperLimitHeatingResetControlType.factory()
            obj_.build(child_)
            self.OutsideAirTemperatureUpperLimitHeatingResetControl = obj_
            obj_.original_tagname_ = 'OutsideAirTemperatureUpperLimitHeatingResetControl'
        elif nodeName_ == 'OutsideAirTemperatureLowerLimitHeatingResetControl':
            obj_ = OutsideAirTemperatureLowerLimitHeatingResetControlType.factory()
            obj_.build(child_)
            self.OutsideAirTemperatureLowerLimitHeatingResetControl = obj_
            obj_.original_tagname_ = 'OutsideAirTemperatureLowerLimitHeatingResetControl'
        elif nodeName_ == 'OutsideAirResetMaximumCoolingSupplyTemperature':
            obj_ = OutsideAirResetMaximumCoolingSupplyTemperatureType.factory()
            obj_.build(child_)
            self.OutsideAirResetMaximumCoolingSupplyTemperature = obj_
            obj_.original_tagname_ = 'OutsideAirResetMaximumCoolingSupplyTemperature'
        elif nodeName_ == 'OutsideAirResetMinimumCoolingSupplyTemperature':
            obj_ = OutsideAirResetMinimumCoolingSupplyTemperatureType.factory()
            obj_.build(child_)
            self.OutsideAirResetMinimumCoolingSupplyTemperature = obj_
            obj_.original_tagname_ = 'OutsideAirResetMinimumCoolingSupplyTemperature'
        elif nodeName_ == 'OutsideAirTemperatureUpperLimitCoolingResetControl':
            obj_ = OutsideAirTemperatureUpperLimitCoolingResetControlType.factory()
            obj_.build(child_)
            self.OutsideAirTemperatureUpperLimitCoolingResetControl = obj_
            obj_.original_tagname_ = 'OutsideAirTemperatureUpperLimitCoolingResetControl'
        elif nodeName_ == 'OutsideAirTemperatureLowerLimitCoolingResetControl':
            obj_ = OutsideAirTemperatureLowerLimitCoolingResetControlType.factory()
            obj_.build(child_)
            self.OutsideAirTemperatureLowerLimitCoolingResetControl = obj_
            obj_.original_tagname_ = 'OutsideAirTemperatureLowerLimitCoolingResetControl'
        elif nodeName_ == 'HeatingSupplyAirTemperature':
            obj_ = HeatingSupplyAirTemperatureType.factory()
            obj_.build(child_)
            self.HeatingSupplyAirTemperature = obj_
            obj_.original_tagname_ = 'HeatingSupplyAirTemperature'
        elif nodeName_ == 'SupplyAirTemperatureResetControl':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SupplyAirTemperatureResetControl')
            self.SupplyAirTemperatureResetControl = ival_
        elif nodeName_ == 'StaticPressureResetControl':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'StaticPressureResetControl')
            self.StaticPressureResetControl = ival_
# end class FanBasedType


class FanBasedDistributionTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CentralAirDistribution=None, FanCoil=None):
        self.original_tagname_ = None
        self.CentralAirDistribution = CentralAirDistribution
        self.FanCoil = FanCoil
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanBasedDistributionTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanBasedDistributionTypeType.subclass:
            return FanBasedDistributionTypeType.subclass(*args_, **kwargs_)
        else:
            return FanBasedDistributionTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CentralAirDistribution is not None or
            self.FanCoil is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanBasedDistributionTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanBasedDistributionTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanBasedDistributionTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanBasedDistributionTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanBasedDistributionTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CentralAirDistribution is not None:
            self.CentralAirDistribution.export(outfile, level, namespace_, name_='CentralAirDistribution', pretty_print=pretty_print)
        if self.FanCoil is not None:
            self.FanCoil.export(outfile, level, namespace_, name_='FanCoil', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CentralAirDistribution':
            obj_ = CentralAirDistributionType.factory()
            obj_.build(child_)
            self.CentralAirDistribution = obj_
            obj_.original_tagname_ = 'CentralAirDistribution'
        elif nodeName_ == 'FanCoil':
            obj_ = FanCoilType127.factory()
            obj_.build(child_)
            self.FanCoil = obj_
            obj_.original_tagname_ = 'FanCoil'
# end class FanBasedDistributionTypeType


class CentralAirDistributionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AirDeliveryType=None, TerminalUnit=None, ReheatSource=None, ReheatControlMethod=None, ReheatPlantID=None):
        self.original_tagname_ = None
        self.AirDeliveryType = AirDeliveryType
        self.validate_AirDeliveryTypeType(self.AirDeliveryType)
        self.TerminalUnit = TerminalUnit
        self.validate_TerminalUnitType(self.TerminalUnit)
        self.ReheatSource = ReheatSource
        self.validate_ReheatSourceType(self.ReheatSource)
        self.ReheatControlMethod = ReheatControlMethod
        self.validate_ReheatControlMethodType(self.ReheatControlMethod)
        self.ReheatPlantID = ReheatPlantID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CentralAirDistributionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CentralAirDistributionType.subclass:
            return CentralAirDistributionType.subclass(*args_, **kwargs_)
        else:
            return CentralAirDistributionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AirDeliveryTypeType(self, value):
        # Validate type AirDeliveryTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Central fan', 'Induction units', 'Low pressure under floor', 'Local fan', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AirDeliveryTypeType' % {"value" : value.encode("utf-8")} )
    def validate_TerminalUnitType(self, value):
        # Validate type TerminalUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CAV terminal box with reheat', 'VAV terminal box fan powered no reheat', 'VAV terminal box fan powered with reheat', 'VAV terminal box not fan powered no reheat', 'VAV terminal box not fan powered with reheat', 'Automatically controlled register', 'Manually controlled register', 'Uncontrolled register', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TerminalUnitType' % {"value" : value.encode("utf-8")} )
    def validate_ReheatSourceType(self, value):
        # Validate type ReheatSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Heating plant', 'Local electric resistance', 'Local gas', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReheatSourceType' % {"value" : value.encode("utf-8")} )
    def validate_ReheatControlMethodType(self, value):
        # Validate type ReheatControlMethodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dual Maximum', 'Single Maximum', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReheatControlMethodType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AirDeliveryType is not None or
            self.TerminalUnit is not None or
            self.ReheatSource is not None or
            self.ReheatControlMethod is not None or
            self.ReheatPlantID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CentralAirDistributionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CentralAirDistributionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CentralAirDistributionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CentralAirDistributionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CentralAirDistributionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirDeliveryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAirDeliveryType>%s</%sAirDeliveryType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AirDeliveryType), input_name='AirDeliveryType')), namespace_, eol_))
        if self.TerminalUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerminalUnit>%s</%sTerminalUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.TerminalUnit), input_name='TerminalUnit')), namespace_, eol_))
        if self.ReheatSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReheatSource>%s</%sReheatSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReheatSource), input_name='ReheatSource')), namespace_, eol_))
        if self.ReheatControlMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReheatControlMethod>%s</%sReheatControlMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ReheatControlMethod), input_name='ReheatControlMethod')), namespace_, eol_))
        if self.ReheatPlantID is not None:
            self.ReheatPlantID.export(outfile, level, namespace_, name_='ReheatPlantID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirDeliveryType':
            AirDeliveryType_ = child_.text
            AirDeliveryType_ = self.gds_validate_string(AirDeliveryType_, node, 'AirDeliveryType')
            self.AirDeliveryType = AirDeliveryType_
            # validate type AirDeliveryTypeType
            self.validate_AirDeliveryTypeType(self.AirDeliveryType)
        elif nodeName_ == 'TerminalUnit':
            TerminalUnit_ = child_.text
            TerminalUnit_ = self.gds_validate_string(TerminalUnit_, node, 'TerminalUnit')
            self.TerminalUnit = TerminalUnit_
            # validate type TerminalUnitType
            self.validate_TerminalUnitType(self.TerminalUnit)
        elif nodeName_ == 'ReheatSource':
            ReheatSource_ = child_.text
            ReheatSource_ = self.gds_validate_string(ReheatSource_, node, 'ReheatSource')
            self.ReheatSource = ReheatSource_
            # validate type ReheatSourceType
            self.validate_ReheatSourceType(self.ReheatSource)
        elif nodeName_ == 'ReheatControlMethod':
            ReheatControlMethod_ = child_.text
            ReheatControlMethod_ = self.gds_validate_string(ReheatControlMethod_, node, 'ReheatControlMethod')
            self.ReheatControlMethod = ReheatControlMethod_
            # validate type ReheatControlMethodType
            self.validate_ReheatControlMethodType(self.ReheatControlMethod)
        elif nodeName_ == 'ReheatPlantID':
            obj_ = xs_IDREF.factory()
            obj_.build(child_)
            self.ReheatPlantID = obj_
            obj_.original_tagname_ = 'ReheatPlantID'
# end class CentralAirDistributionType


class FanCoilType127(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FanCoilType=None, HVACPipeConfiguration=None, PipeInsulationThickness=None, PipeLocation=None):
        self.original_tagname_ = None
        self.FanCoilType = FanCoilType
        self.validate_FanCoilTypeType(self.FanCoilType)
        self.HVACPipeConfiguration = HVACPipeConfiguration
        self.validate_HVACPipeConfigurationType(self.HVACPipeConfiguration)
        self.PipeInsulationThickness = PipeInsulationThickness
        self.PipeLocation = PipeLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanCoilType127)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanCoilType127.subclass:
            return FanCoilType127.subclass(*args_, **kwargs_)
        else:
            return FanCoilType127(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FanCoilTypeType(self, value):
        # Validate type FanCoilTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Mini-split', 'Multi-split', 'Terminal reheat', 'Fan coil 2 pipe', 'Fan coil 4 pipe', 'VRF terminal units', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FanCoilTypeType' % {"value" : value.encode("utf-8")} )
    def validate_HVACPipeConfigurationType(self, value):
        # Validate type HVACPipeConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1 pipe', '2 pipe', '3 pipe', '4 pipe', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HVACPipeConfigurationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FanCoilType is not None or
            self.HVACPipeConfiguration is not None or
            self.PipeInsulationThickness is not None or
            self.PipeLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanCoilType127', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanCoilType127')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanCoilType127', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanCoilType127'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanCoilType127', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FanCoilType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFanCoilType>%s</%sFanCoilType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FanCoilType), input_name='FanCoilType')), namespace_, eol_))
        if self.HVACPipeConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHVACPipeConfiguration>%s</%sHVACPipeConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HVACPipeConfiguration), input_name='HVACPipeConfiguration')), namespace_, eol_))
        if self.PipeInsulationThickness is not None:
            self.PipeInsulationThickness.export(outfile, level, namespace_, name_='PipeInsulationThickness', pretty_print=pretty_print)
        if self.PipeLocation is not None:
            self.PipeLocation.export(outfile, level, namespace_, name_='PipeLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FanCoilType':
            FanCoilType_ = child_.text
            FanCoilType_ = self.gds_validate_string(FanCoilType_, node, 'FanCoilType')
            self.FanCoilType = FanCoilType_
            # validate type FanCoilTypeType
            self.validate_FanCoilTypeType(self.FanCoilType)
        elif nodeName_ == 'HVACPipeConfiguration':
            HVACPipeConfiguration_ = child_.text
            HVACPipeConfiguration_ = self.gds_validate_string(HVACPipeConfiguration_, node, 'HVACPipeConfiguration')
            self.HVACPipeConfiguration = HVACPipeConfiguration_
            # validate type HVACPipeConfigurationType
            self.validate_HVACPipeConfigurationType(self.HVACPipeConfiguration)
        elif nodeName_ == 'PipeInsulationThickness':
            obj_ = PipeInsulationThicknessType.factory()
            obj_.build(child_)
            self.PipeInsulationThickness = obj_
            obj_.original_tagname_ = 'PipeInsulationThickness'
        elif nodeName_ == 'PipeLocation':
            obj_ = PipeLocationType.factory()
            obj_.build(child_)
            self.PipeLocation = obj_
            obj_.original_tagname_ = 'PipeLocation'
# end class FanCoilType127


class PipeInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeInsulationThicknessType.subclass:
            return PipeInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return PipeInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeInsulationThicknessType


class PipeLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeLocationType.subclass:
            return PipeLocationType.subclass(*args_, **kwargs_)
        else:
            return PipeLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeLocationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeLocationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeLocationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeLocationType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeLocationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeLocationType


class AirSideEconomizerType128(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirSideEconomizerType128)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirSideEconomizerType128.subclass:
            return AirSideEconomizerType128.subclass(*args_, **kwargs_)
        else:
            return AirSideEconomizerType128(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AirSideEconomizerType128', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AirSideEconomizerType128')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AirSideEconomizerType128', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AirSideEconomizerType128'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AirSideEconomizerType128', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType129.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class AirSideEconomizerType128


class TrueType129(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Status=None, AirSideEconomizerType=None, EconomizerControl=None, EconomizerDryBulbControlPoint=None, EconomizerEnthalpyControlPoint=None, EconomizerLowTemperatureLockout=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
        self.AirSideEconomizerType = AirSideEconomizerType
        self.validate_AirSideEconomizerTypeType(self.AirSideEconomizerType)
        self.EconomizerControl = EconomizerControl
        self.validate_EconomizerControlType(self.EconomizerControl)
        self.EconomizerDryBulbControlPoint = EconomizerDryBulbControlPoint
        self.EconomizerEnthalpyControlPoint = EconomizerEnthalpyControlPoint
        self.EconomizerLowTemperatureLockout = EconomizerLowTemperatureLockout
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType129)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType129.subclass:
            return TrueType129.subclass(*args_, **kwargs_)
        else:
            return TrueType129(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AirSideEconomizerTypeType(self, value):
        # Validate type AirSideEconomizerTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dry bulb temperature', 'Enthalpy', 'Demand controlled ventilation', 'Nonintegrated', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AirSideEconomizerTypeType' % {"value" : value.encode("utf-8")} )
    def validate_EconomizerControlType(self, value):
        # Validate type EconomizerControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fixed', 'Differential', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EconomizerControlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AirSideEconomizerType is not None or
            self.EconomizerControl is not None or
            self.EconomizerDryBulbControlPoint is not None or
            self.EconomizerEnthalpyControlPoint is not None or
            self.EconomizerLowTemperatureLockout is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType129', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType129')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType129', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType129'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType129', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AirSideEconomizerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAirSideEconomizerType>%s</%sAirSideEconomizerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AirSideEconomizerType), input_name='AirSideEconomizerType')), namespace_, eol_))
        if self.EconomizerControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEconomizerControl>%s</%sEconomizerControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EconomizerControl), input_name='EconomizerControl')), namespace_, eol_))
        if self.EconomizerDryBulbControlPoint is not None:
            self.EconomizerDryBulbControlPoint.export(outfile, level, namespace_, name_='EconomizerDryBulbControlPoint', pretty_print=pretty_print)
        if self.EconomizerEnthalpyControlPoint is not None:
            self.EconomizerEnthalpyControlPoint.export(outfile, level, namespace_, name_='EconomizerEnthalpyControlPoint', pretty_print=pretty_print)
        if self.EconomizerLowTemperatureLockout is not None:
            self.EconomizerLowTemperatureLockout.export(outfile, level, namespace_, name_='EconomizerLowTemperatureLockout', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AirSideEconomizerType':
            AirSideEconomizerType_ = child_.text
            AirSideEconomizerType_ = self.gds_validate_string(AirSideEconomizerType_, node, 'AirSideEconomizerType')
            self.AirSideEconomizerType = AirSideEconomizerType_
            # validate type AirSideEconomizerTypeType
            self.validate_AirSideEconomizerTypeType(self.AirSideEconomizerType)
        elif nodeName_ == 'EconomizerControl':
            EconomizerControl_ = child_.text
            EconomizerControl_ = self.gds_validate_string(EconomizerControl_, node, 'EconomizerControl')
            self.EconomizerControl = EconomizerControl_
            # validate type EconomizerControlType
            self.validate_EconomizerControlType(self.EconomizerControl)
        elif nodeName_ == 'EconomizerDryBulbControlPoint':
            obj_ = EconomizerDryBulbControlPointType.factory()
            obj_.build(child_)
            self.EconomizerDryBulbControlPoint = obj_
            obj_.original_tagname_ = 'EconomizerDryBulbControlPoint'
        elif nodeName_ == 'EconomizerEnthalpyControlPoint':
            obj_ = EconomizerEnthalpyControlPointType.factory()
            obj_.build(child_)
            self.EconomizerEnthalpyControlPoint = obj_
            obj_.original_tagname_ = 'EconomizerEnthalpyControlPoint'
        elif nodeName_ == 'EconomizerLowTemperatureLockout':
            obj_ = EconomizerLowTemperatureLockoutType.factory()
            obj_.build(child_)
            self.EconomizerLowTemperatureLockout = obj_
            obj_.original_tagname_ = 'EconomizerLowTemperatureLockout'
# end class TrueType129


class EconomizerDryBulbControlPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EconomizerDryBulbControlPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EconomizerDryBulbControlPointType.subclass:
            return EconomizerDryBulbControlPointType.subclass(*args_, **kwargs_)
        else:
            return EconomizerDryBulbControlPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EconomizerDryBulbControlPointType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EconomizerDryBulbControlPointType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EconomizerDryBulbControlPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EconomizerDryBulbControlPointType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EconomizerDryBulbControlPointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EconomizerDryBulbControlPointType


class EconomizerEnthalpyControlPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EconomizerEnthalpyControlPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EconomizerEnthalpyControlPointType.subclass:
            return EconomizerEnthalpyControlPointType.subclass(*args_, **kwargs_)
        else:
            return EconomizerEnthalpyControlPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EconomizerEnthalpyControlPointType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EconomizerEnthalpyControlPointType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EconomizerEnthalpyControlPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EconomizerEnthalpyControlPointType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EconomizerEnthalpyControlPointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EconomizerEnthalpyControlPointType


class EconomizerLowTemperatureLockoutType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EconomizerLowTemperatureLockoutType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EconomizerLowTemperatureLockoutType.subclass:
            return EconomizerLowTemperatureLockoutType.subclass(*args_, **kwargs_)
        else:
            return EconomizerLowTemperatureLockoutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EconomizerLowTemperatureLockoutType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EconomizerLowTemperatureLockoutType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EconomizerLowTemperatureLockoutType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EconomizerLowTemperatureLockoutType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EconomizerLowTemperatureLockoutType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EconomizerLowTemperatureLockoutType


class CoolingSupplyAirTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingSupplyAirTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingSupplyAirTemperatureType.subclass:
            return CoolingSupplyAirTemperatureType.subclass(*args_, **kwargs_)
        else:
            return CoolingSupplyAirTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingSupplyAirTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingSupplyAirTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingSupplyAirTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingSupplyAirTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingSupplyAirTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingSupplyAirTemperatureType


class OutsideAirResetMaximumHeatingSupplyTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirResetMaximumHeatingSupplyTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirResetMaximumHeatingSupplyTemperatureType.subclass:
            return OutsideAirResetMaximumHeatingSupplyTemperatureType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirResetMaximumHeatingSupplyTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMaximumHeatingSupplyTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirResetMaximumHeatingSupplyTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirResetMaximumHeatingSupplyTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirResetMaximumHeatingSupplyTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMaximumHeatingSupplyTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirResetMaximumHeatingSupplyTemperatureType


class OutsideAirResetMinimumHeatingSupplyTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirResetMinimumHeatingSupplyTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirResetMinimumHeatingSupplyTemperatureType.subclass:
            return OutsideAirResetMinimumHeatingSupplyTemperatureType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirResetMinimumHeatingSupplyTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMinimumHeatingSupplyTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirResetMinimumHeatingSupplyTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirResetMinimumHeatingSupplyTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirResetMinimumHeatingSupplyTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMinimumHeatingSupplyTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirResetMinimumHeatingSupplyTemperatureType


class OutsideAirTemperatureUpperLimitHeatingResetControlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirTemperatureUpperLimitHeatingResetControlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirTemperatureUpperLimitHeatingResetControlType.subclass:
            return OutsideAirTemperatureUpperLimitHeatingResetControlType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirTemperatureUpperLimitHeatingResetControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitHeatingResetControlType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirTemperatureUpperLimitHeatingResetControlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitHeatingResetControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitHeatingResetControlType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitHeatingResetControlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirTemperatureUpperLimitHeatingResetControlType


class OutsideAirTemperatureLowerLimitHeatingResetControlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirTemperatureLowerLimitHeatingResetControlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirTemperatureLowerLimitHeatingResetControlType.subclass:
            return OutsideAirTemperatureLowerLimitHeatingResetControlType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirTemperatureLowerLimitHeatingResetControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitHeatingResetControlType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirTemperatureLowerLimitHeatingResetControlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitHeatingResetControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitHeatingResetControlType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitHeatingResetControlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirTemperatureLowerLimitHeatingResetControlType


class OutsideAirResetMaximumCoolingSupplyTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirResetMaximumCoolingSupplyTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirResetMaximumCoolingSupplyTemperatureType.subclass:
            return OutsideAirResetMaximumCoolingSupplyTemperatureType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirResetMaximumCoolingSupplyTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMaximumCoolingSupplyTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirResetMaximumCoolingSupplyTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirResetMaximumCoolingSupplyTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirResetMaximumCoolingSupplyTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMaximumCoolingSupplyTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirResetMaximumCoolingSupplyTemperatureType


class OutsideAirResetMinimumCoolingSupplyTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirResetMinimumCoolingSupplyTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirResetMinimumCoolingSupplyTemperatureType.subclass:
            return OutsideAirResetMinimumCoolingSupplyTemperatureType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirResetMinimumCoolingSupplyTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMinimumCoolingSupplyTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirResetMinimumCoolingSupplyTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirResetMinimumCoolingSupplyTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirResetMinimumCoolingSupplyTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirResetMinimumCoolingSupplyTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirResetMinimumCoolingSupplyTemperatureType


class OutsideAirTemperatureUpperLimitCoolingResetControlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirTemperatureUpperLimitCoolingResetControlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirTemperatureUpperLimitCoolingResetControlType.subclass:
            return OutsideAirTemperatureUpperLimitCoolingResetControlType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirTemperatureUpperLimitCoolingResetControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitCoolingResetControlType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirTemperatureUpperLimitCoolingResetControlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitCoolingResetControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitCoolingResetControlType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureUpperLimitCoolingResetControlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirTemperatureUpperLimitCoolingResetControlType


class OutsideAirTemperatureLowerLimitCoolingResetControlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutsideAirTemperatureLowerLimitCoolingResetControlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutsideAirTemperatureLowerLimitCoolingResetControlType.subclass:
            return OutsideAirTemperatureLowerLimitCoolingResetControlType.subclass(*args_, **kwargs_)
        else:
            return OutsideAirTemperatureLowerLimitCoolingResetControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitCoolingResetControlType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideAirTemperatureLowerLimitCoolingResetControlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitCoolingResetControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitCoolingResetControlType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OutsideAirTemperatureLowerLimitCoolingResetControlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OutsideAirTemperatureLowerLimitCoolingResetControlType


class HeatingSupplyAirTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingSupplyAirTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingSupplyAirTemperatureType.subclass:
            return HeatingSupplyAirTemperatureType.subclass(*args_, **kwargs_)
        else:
            return HeatingSupplyAirTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingSupplyAirTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingSupplyAirTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingSupplyAirTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingSupplyAirTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingSupplyAirTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingSupplyAirTemperatureType


class ConvectionType130(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConvectionType=None, PipeInsulationThickness=None, PipeLocation=None):
        self.original_tagname_ = None
        self.ConvectionType = ConvectionType
        self.validate_ConvectionTypeType(self.ConvectionType)
        self.PipeInsulationThickness = PipeInsulationThickness
        self.PipeLocation = PipeLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConvectionType130)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConvectionType130.subclass:
            return ConvectionType130.subclass(*args_, **kwargs_)
        else:
            return ConvectionType130(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ConvectionTypeType(self, value):
        # Validate type ConvectionTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Perimeter baseboard', 'Chilled beam', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ConvectionTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ConvectionType is not None or
            self.PipeInsulationThickness is not None or
            self.PipeLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConvectionType130', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConvectionType130')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConvectionType130', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConvectionType130'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConvectionType130', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConvectionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConvectionType>%s</%sConvectionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ConvectionType), input_name='ConvectionType')), namespace_, eol_))
        if self.PipeInsulationThickness is not None:
            self.PipeInsulationThickness.export(outfile, level, namespace_, name_='PipeInsulationThickness', pretty_print=pretty_print)
        if self.PipeLocation is not None:
            self.PipeLocation.export(outfile, level, namespace_, name_='PipeLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConvectionType':
            ConvectionType_ = child_.text
            ConvectionType_ = self.gds_validate_string(ConvectionType_, node, 'ConvectionType')
            self.ConvectionType = ConvectionType_
            # validate type ConvectionTypeType
            self.validate_ConvectionTypeType(self.ConvectionType)
        elif nodeName_ == 'PipeInsulationThickness':
            obj_ = PipeInsulationThicknessType131.factory()
            obj_.build(child_)
            self.PipeInsulationThickness = obj_
            obj_.original_tagname_ = 'PipeInsulationThickness'
        elif nodeName_ == 'PipeLocation':
            obj_ = PipeLocationType132.factory()
            obj_.build(child_)
            self.PipeLocation = obj_
            obj_.original_tagname_ = 'PipeLocation'
# end class ConvectionType130


class PipeInsulationThicknessType131(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeInsulationThicknessType131)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeInsulationThicknessType131.subclass:
            return PipeInsulationThicknessType131.subclass(*args_, **kwargs_)
        else:
            return PipeInsulationThicknessType131(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType131', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeInsulationThicknessType131')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeInsulationThicknessType131', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeInsulationThicknessType131'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType131', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeInsulationThicknessType131


class PipeLocationType132(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeLocationType132)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeLocationType132.subclass:
            return PipeLocationType132.subclass(*args_, **kwargs_)
        else:
            return PipeLocationType132(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeLocationType132', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeLocationType132')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeLocationType132', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeLocationType132'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeLocationType132', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeLocationType132


class RadiantType133(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RadiantType=None, PipeInsulationThickness=None, PipeLocation=None):
        self.original_tagname_ = None
        self.RadiantType = RadiantType
        self.validate_RadiantTypeType(self.RadiantType)
        self.PipeInsulationThickness = PipeInsulationThickness
        self.PipeLocation = PipeLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadiantType133)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadiantType133.subclass:
            return RadiantType133.subclass(*args_, **kwargs_)
        else:
            return RadiantType133(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RadiantTypeType(self, value):
        # Validate type RadiantTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Radiator', 'Radiant floor or ceiling', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RadiantTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RadiantType is not None or
            self.PipeInsulationThickness is not None or
            self.PipeLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RadiantType133', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadiantType133')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RadiantType133', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RadiantType133'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RadiantType133', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RadiantType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRadiantType>%s</%sRadiantType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RadiantType), input_name='RadiantType')), namespace_, eol_))
        if self.PipeInsulationThickness is not None:
            self.PipeInsulationThickness.export(outfile, level, namespace_, name_='PipeInsulationThickness', pretty_print=pretty_print)
        if self.PipeLocation is not None:
            self.PipeLocation.export(outfile, level, namespace_, name_='PipeLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RadiantType':
            RadiantType_ = child_.text
            RadiantType_ = self.gds_validate_string(RadiantType_, node, 'RadiantType')
            self.RadiantType = RadiantType_
            # validate type RadiantTypeType
            self.validate_RadiantTypeType(self.RadiantType)
        elif nodeName_ == 'PipeInsulationThickness':
            obj_ = PipeInsulationThicknessType134.factory()
            obj_.build(child_)
            self.PipeInsulationThickness = obj_
            obj_.original_tagname_ = 'PipeInsulationThickness'
        elif nodeName_ == 'PipeLocation':
            obj_ = PipeLocationType135.factory()
            obj_.build(child_)
            self.PipeLocation = obj_
            obj_.original_tagname_ = 'PipeLocation'
# end class RadiantType133


class PipeInsulationThicknessType134(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeInsulationThicknessType134)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeInsulationThicknessType134.subclass:
            return PipeInsulationThicknessType134.subclass(*args_, **kwargs_)
        else:
            return PipeInsulationThicknessType134(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType134', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeInsulationThicknessType134')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeInsulationThicknessType134', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeInsulationThicknessType134'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType134', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeInsulationThicknessType134


class PipeLocationType135(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeLocationType135)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeLocationType135.subclass:
            return PipeLocationType135.subclass(*args_, **kwargs_)
        else:
            return PipeLocationType135(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeLocationType135', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeLocationType135')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeLocationType135', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeLocationType135'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeLocationType135', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeLocationType135


class HeatingSourceIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingSourceIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingSourceIDType.subclass:
            return HeatingSourceIDType.subclass(*args_, **kwargs_)
        else:
            return HeatingSourceIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingSourceIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingSourceIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingSourceIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingSourceIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingSourceIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingSourceIDType


class CoolingSourceIDType136(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingSourceIDType136)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingSourceIDType136.subclass:
            return CoolingSourceIDType136.subclass(*args_, **kwargs_)
        else:
            return CoolingSourceIDType136(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingSourceIDType136', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingSourceIDType136')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingSourceIDType136', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingSourceIDType136'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingSourceIDType136', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingSourceIDType136


class DuctSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DuctSystems=None):
        self.original_tagname_ = None
        if DuctSystems is None:
            self.DuctSystems = []
        else:
            self.DuctSystems = DuctSystems
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctSystemsType.subclass:
            return DuctSystemsType.subclass(*args_, **kwargs_)
        else:
            return DuctSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.DuctSystems
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DuctSystems_ in self.DuctSystems:
            DuctSystems_.export(outfile, level, namespace_, name_='DuctSystems', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DuctSystems':
            obj_ = DuctSystemType.factory()
            obj_.build(child_)
            self.DuctSystems.append(obj_)
            obj_.original_tagname_ = 'DuctSystems'
# end class DuctSystemsType


class OtherHVACSystemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OtherHVACSystem=None):
        self.original_tagname_ = None
        if OtherHVACSystem is None:
            self.OtherHVACSystem = []
        else:
            self.OtherHVACSystem = OtherHVACSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherHVACSystemsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherHVACSystemsType.subclass:
            return OtherHVACSystemsType.subclass(*args_, **kwargs_)
        else:
            return OtherHVACSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.OtherHVACSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherHVACSystemsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherHVACSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherHVACSystemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherHVACSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherHVACSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OtherHVACSystem_ in self.OtherHVACSystem:
            OtherHVACSystem_.export(outfile, level, namespace_, name_='OtherHVACSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherHVACSystem':
            obj_ = OtherHVACSystemType.factory()
            obj_.build(child_)
            self.OtherHVACSystem.append(obj_)
            obj_.original_tagname_ = 'OtherHVACSystem'
# end class OtherHVACSystemsType


class MinimumOutsideAirPercentageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumOutsideAirPercentageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumOutsideAirPercentageType.subclass:
            return MinimumOutsideAirPercentageType.subclass(*args_, **kwargs_)
        else:
            return MinimumOutsideAirPercentageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumOutsideAirPercentageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumOutsideAirPercentageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumOutsideAirPercentageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumOutsideAirPercentageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumOutsideAirPercentageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumOutsideAirPercentageType


class MaximumOAFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaximumOAFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaximumOAFlowRateType.subclass:
            return MaximumOAFlowRateType.subclass(*args_, **kwargs_)
        else:
            return MaximumOAFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MaximumOAFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaximumOAFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MaximumOAFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MaximumOAFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MaximumOAFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MaximumOAFlowRateType


class DuctInsulationRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctInsulationRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctInsulationRValueType.subclass:
            return DuctInsulationRValueType.subclass(*args_, **kwargs_)
        else:
            return DuctInsulationRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctInsulationRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctInsulationRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctInsulationRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctInsulationRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctInsulationRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DuctInsulationRValueType


class DuctSurfaceAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctSurfaceAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctSurfaceAreaType.subclass:
            return DuctSurfaceAreaType.subclass(*args_, **kwargs_)
        else:
            return DuctSurfaceAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctSurfaceAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctSurfaceAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctSurfaceAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctSurfaceAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctSurfaceAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DuctSurfaceAreaType


class SupplyDuctPercentConditionedSpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplyDuctPercentConditionedSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplyDuctPercentConditionedSpaceType.subclass:
            return SupplyDuctPercentConditionedSpaceType.subclass(*args_, **kwargs_)
        else:
            return SupplyDuctPercentConditionedSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SupplyDuctPercentConditionedSpaceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyDuctPercentConditionedSpaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SupplyDuctPercentConditionedSpaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SupplyDuctPercentConditionedSpaceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SupplyDuctPercentConditionedSpaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupplyDuctPercentConditionedSpaceType


class ReturnDuctPercentConditionedSpaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnDuctPercentConditionedSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnDuctPercentConditionedSpaceType.subclass:
            return ReturnDuctPercentConditionedSpaceType.subclass(*args_, **kwargs_)
        else:
            return ReturnDuctPercentConditionedSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ReturnDuctPercentConditionedSpaceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnDuctPercentConditionedSpaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ReturnDuctPercentConditionedSpaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ReturnDuctPercentConditionedSpaceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ReturnDuctPercentConditionedSpaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReturnDuctPercentConditionedSpaceType


class StaticPressureInstalledType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StaticPressureInstalledType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StaticPressureInstalledType.subclass:
            return StaticPressureInstalledType.subclass(*args_, **kwargs_)
        else:
            return StaticPressureInstalledType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StaticPressureInstalledType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticPressureInstalledType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StaticPressureInstalledType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StaticPressureInstalledType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StaticPressureInstalledType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StaticPressureInstalledType


class DuctPressureTestLeakageRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctPressureTestLeakageRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctPressureTestLeakageRateType.subclass:
            return DuctPressureTestLeakageRateType.subclass(*args_, **kwargs_)
        else:
            return DuctPressureTestLeakageRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctPressureTestLeakageRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctPressureTestLeakageRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctPressureTestLeakageRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctPressureTestLeakageRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctPressureTestLeakageRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DuctPressureTestLeakageRateType


class SupplyFractionOfDuctLeakageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplyFractionOfDuctLeakageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplyFractionOfDuctLeakageType.subclass:
            return SupplyFractionOfDuctLeakageType.subclass(*args_, **kwargs_)
        else:
            return SupplyFractionOfDuctLeakageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SupplyFractionOfDuctLeakageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyFractionOfDuctLeakageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SupplyFractionOfDuctLeakageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SupplyFractionOfDuctLeakageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SupplyFractionOfDuctLeakageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupplyFractionOfDuctLeakageType


class DuctPressureTestLeakagePercentageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DuctPressureTestLeakagePercentageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DuctPressureTestLeakagePercentageType.subclass:
            return DuctPressureTestLeakagePercentageType.subclass(*args_, **kwargs_)
        else:
            return DuctPressureTestLeakagePercentageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DuctPressureTestLeakagePercentageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuctPressureTestLeakagePercentageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DuctPressureTestLeakagePercentageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DuctPressureTestLeakagePercentageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DuctPressureTestLeakagePercentageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DuctPressureTestLeakagePercentageType


class HeatingDeliveryIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingDeliveryIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingDeliveryIDType.subclass:
            return HeatingDeliveryIDType.subclass(*args_, **kwargs_)
        else:
            return HeatingDeliveryIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingDeliveryIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingDeliveryIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingDeliveryIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingDeliveryIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingDeliveryIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingDeliveryIDType


class CoolingDeliveryIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingDeliveryIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingDeliveryIDType.subclass:
            return CoolingDeliveryIDType.subclass(*args_, **kwargs_)
        else:
            return CoolingDeliveryIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingDeliveryIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingDeliveryIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingDeliveryIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingDeliveryIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingDeliveryIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingDeliveryIDType


class ChillerType137(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChillerType=None, ChillerCompressorDriver=None, ChillerCompressorType=None, CompressorStaging=None, NumberOfDiscreteCoolingStages=None, CoolingStageCapacity=None, CondenserPlantID=None, Refrigerant=None, RefrigerantChargeFactor=None, AbsorptionHeatSource=None, AbsorptionStages=None, AnnualCoolingEfficiencyValue=None, AnnualCoolingEfficiencyUnits=None, Capacity=None, CapacityUnits=None, MinimumPartLoadRatio=None, RatedCoolingSensibleHeatRatio=None, PartLoadRatioBelowWhichHotGasBypassOperates=None, ThirdPartyCertification=None, ChilledWaterResetControl=None, ChilledWaterSupplyTemperature=None, ActiveDehumidification=None, Quantity=None):
        self.original_tagname_ = None
        self.ChillerType = ChillerType
        self.validate_ChillerTypeType(self.ChillerType)
        self.ChillerCompressorDriver = ChillerCompressorDriver
        self.validate_ChillerCompressorDriverType(self.ChillerCompressorDriver)
        self.ChillerCompressorType = ChillerCompressorType
        self.validate_ChillerCompressorTypeType(self.ChillerCompressorType)
        self.CompressorStaging = CompressorStaging
        self.validate_CompressorStaging(self.CompressorStaging)
        self.NumberOfDiscreteCoolingStages = NumberOfDiscreteCoolingStages
        self.CoolingStageCapacity = CoolingStageCapacity
        if CondenserPlantID is None:
            self.CondenserPlantID = []
        else:
            self.CondenserPlantID = CondenserPlantID
        self.Refrigerant = Refrigerant
        self.validate_Refrigerant(self.Refrigerant)
        self.RefrigerantChargeFactor = RefrigerantChargeFactor
        self.AbsorptionHeatSource = AbsorptionHeatSource
        self.validate_AbsorptionHeatSourceType(self.AbsorptionHeatSource)
        self.AbsorptionStages = AbsorptionStages
        self.validate_AbsorptionStagesType(self.AbsorptionStages)
        self.AnnualCoolingEfficiencyValue = AnnualCoolingEfficiencyValue
        self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits
        self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.MinimumPartLoadRatio = MinimumPartLoadRatio
        self.RatedCoolingSensibleHeatRatio = RatedCoolingSensibleHeatRatio
        self.PartLoadRatioBelowWhichHotGasBypassOperates = PartLoadRatioBelowWhichHotGasBypassOperates
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        self.ChilledWaterResetControl = ChilledWaterResetControl
        self.validate_ChilledWaterResetControlType(self.ChilledWaterResetControl)
        self.ChilledWaterSupplyTemperature = ChilledWaterSupplyTemperature
        self.ActiveDehumidification = ActiveDehumidification
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChillerType137)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChillerType137.subclass:
            return ChillerType137.subclass(*args_, **kwargs_)
        else:
            return ChillerType137(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ChillerTypeType(self, value):
        # Validate type ChillerTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Vapor compression', 'Absorption', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChillerTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ChillerCompressorDriverType(self, value):
        # Validate type ChillerCompressorDriverType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electric Motor', 'Steam', 'Gas Turbine', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChillerCompressorDriverType' % {"value" : value.encode("utf-8")} )
    def validate_ChillerCompressorTypeType(self, value):
        # Validate type ChillerCompressorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Reciprocating', 'Screw', 'Scroll', 'Centrifugal', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChillerCompressorTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CompressorStaging(self, value):
        # Validate type CompressorStaging, a restriction on xs:string.
        pass
    def validate_Refrigerant(self, value):
        # Validate type Refrigerant, a restriction on xs:string.
        pass
    def validate_AbsorptionHeatSourceType(self, value):
        # Validate type AbsorptionHeatSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Steam', 'Solar energy', 'Combustion', 'Waste heat', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AbsorptionHeatSourceType' % {"value" : value.encode("utf-8")} )
    def validate_AbsorptionStagesType(self, value):
        # Validate type AbsorptionStagesType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Single effect', 'Double effect', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AbsorptionStagesType' % {"value" : value.encode("utf-8")} )
    def validate_AnnualCoolingEfficiencyUnits(self, value):
        # Validate type AnnualCoolingEfficiencyUnits, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def validate_ChilledWaterResetControlType(self, value):
        # Validate type ChilledWaterResetControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['During the day', 'At night', 'During sleeping and unoccupied hours', 'Seasonal', 'Never-rarely', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChilledWaterResetControlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ChillerType is not None or
            self.ChillerCompressorDriver is not None or
            self.ChillerCompressorType is not None or
            self.CompressorStaging is not None or
            self.NumberOfDiscreteCoolingStages is not None or
            self.CoolingStageCapacity is not None or
            self.CondenserPlantID or
            self.Refrigerant is not None or
            self.RefrigerantChargeFactor is not None or
            self.AbsorptionHeatSource is not None or
            self.AbsorptionStages is not None or
            self.AnnualCoolingEfficiencyValue is not None or
            self.AnnualCoolingEfficiencyUnits is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.MinimumPartLoadRatio is not None or
            self.RatedCoolingSensibleHeatRatio is not None or
            self.PartLoadRatioBelowWhichHotGasBypassOperates is not None or
            self.ThirdPartyCertification is not None or
            self.ChilledWaterResetControl is not None or
            self.ChilledWaterSupplyTemperature is not None or
            self.ActiveDehumidification is not None or
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ChillerType137', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChillerType137')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ChillerType137', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ChillerType137'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ChillerType137', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChillerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChillerType>%s</%sChillerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChillerType), input_name='ChillerType')), namespace_, eol_))
        if self.ChillerCompressorDriver is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChillerCompressorDriver>%s</%sChillerCompressorDriver>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChillerCompressorDriver), input_name='ChillerCompressorDriver')), namespace_, eol_))
        if self.ChillerCompressorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChillerCompressorType>%s</%sChillerCompressorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChillerCompressorType), input_name='ChillerCompressorType')), namespace_, eol_))
        if self.CompressorStaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCompressorStaging>%s</%sCompressorStaging>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CompressorStaging), input_name='CompressorStaging')), namespace_, eol_))
        if self.NumberOfDiscreteCoolingStages is not None:
            self.NumberOfDiscreteCoolingStages.export(outfile, level, namespace_, name_='NumberOfDiscreteCoolingStages', pretty_print=pretty_print)
        if self.CoolingStageCapacity is not None:
            self.CoolingStageCapacity.export(outfile, level, namespace_, name_='CoolingStageCapacity', pretty_print=pretty_print)
        for CondenserPlantID_ in self.CondenserPlantID:
            CondenserPlantID_.export(outfile, level, namespace_, name_='CondenserPlantID', pretty_print=pretty_print)
        if self.Refrigerant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerant>%s</%sRefrigerant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Refrigerant), input_name='Refrigerant')), namespace_, eol_))
        if self.RefrigerantChargeFactor is not None:
            self.RefrigerantChargeFactor.export(outfile, level, namespace_, name_='RefrigerantChargeFactor', pretty_print=pretty_print)
        if self.AbsorptionHeatSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbsorptionHeatSource>%s</%sAbsorptionHeatSource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AbsorptionHeatSource), input_name='AbsorptionHeatSource')), namespace_, eol_))
        if self.AbsorptionStages is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbsorptionStages>%s</%sAbsorptionStages>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AbsorptionStages), input_name='AbsorptionStages')), namespace_, eol_))
        if self.AnnualCoolingEfficiencyValue is not None:
            self.AnnualCoolingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualCoolingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualCoolingEfficiencyUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualCoolingEfficiencyUnits>%s</%sAnnualCoolingEfficiencyUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualCoolingEfficiencyUnits), input_name='AnnualCoolingEfficiencyUnits')), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.MinimumPartLoadRatio is not None:
            self.MinimumPartLoadRatio.export(outfile, level, namespace_, name_='MinimumPartLoadRatio', pretty_print=pretty_print)
        if self.RatedCoolingSensibleHeatRatio is not None:
            self.RatedCoolingSensibleHeatRatio.export(outfile, level, namespace_, name_='RatedCoolingSensibleHeatRatio', pretty_print=pretty_print)
        if self.PartLoadRatioBelowWhichHotGasBypassOperates is not None:
            self.PartLoadRatioBelowWhichHotGasBypassOperates.export(outfile, level, namespace_, name_='PartLoadRatioBelowWhichHotGasBypassOperates', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
        if self.ChilledWaterResetControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChilledWaterResetControl>%s</%sChilledWaterResetControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ChilledWaterResetControl), input_name='ChilledWaterResetControl')), namespace_, eol_))
        if self.ChilledWaterSupplyTemperature is not None:
            self.ChilledWaterSupplyTemperature.export(outfile, level, namespace_, name_='ChilledWaterSupplyTemperature', pretty_print=pretty_print)
        if self.ActiveDehumidification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sActiveDehumidification>%s</%sActiveDehumidification>%s' % (namespace_, self.gds_format_boolean(self.ActiveDehumidification, input_name='ActiveDehumidification'), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChillerType':
            ChillerType_ = child_.text
            ChillerType_ = self.gds_validate_string(ChillerType_, node, 'ChillerType')
            self.ChillerType = ChillerType_
            # validate type ChillerTypeType
            self.validate_ChillerTypeType(self.ChillerType)
        elif nodeName_ == 'ChillerCompressorDriver':
            ChillerCompressorDriver_ = child_.text
            ChillerCompressorDriver_ = self.gds_validate_string(ChillerCompressorDriver_, node, 'ChillerCompressorDriver')
            self.ChillerCompressorDriver = ChillerCompressorDriver_
            # validate type ChillerCompressorDriverType
            self.validate_ChillerCompressorDriverType(self.ChillerCompressorDriver)
        elif nodeName_ == 'ChillerCompressorType':
            ChillerCompressorType_ = child_.text
            ChillerCompressorType_ = self.gds_validate_string(ChillerCompressorType_, node, 'ChillerCompressorType')
            self.ChillerCompressorType = ChillerCompressorType_
            # validate type ChillerCompressorTypeType
            self.validate_ChillerCompressorTypeType(self.ChillerCompressorType)
        elif nodeName_ == 'CompressorStaging':
            CompressorStaging_ = child_.text
            CompressorStaging_ = self.gds_validate_string(CompressorStaging_, node, 'CompressorStaging')
            self.CompressorStaging = CompressorStaging_
            # validate type CompressorStaging
            self.validate_CompressorStaging(self.CompressorStaging)
        elif nodeName_ == 'NumberOfDiscreteCoolingStages':
            obj_ = NumberOfDiscreteCoolingStagesType138.factory()
            obj_.build(child_)
            self.NumberOfDiscreteCoolingStages = obj_
            obj_.original_tagname_ = 'NumberOfDiscreteCoolingStages'
        elif nodeName_ == 'CoolingStageCapacity':
            obj_ = CoolingStageCapacityType139.factory()
            obj_.build(child_)
            self.CoolingStageCapacity = obj_
            obj_.original_tagname_ = 'CoolingStageCapacity'
        elif nodeName_ == 'CondenserPlantID':
            obj_ = CondenserPlantIDType140.factory()
            obj_.build(child_)
            self.CondenserPlantID.append(obj_)
            obj_.original_tagname_ = 'CondenserPlantID'
        elif nodeName_ == 'Refrigerant':
            Refrigerant_ = child_.text
            Refrigerant_ = self.gds_validate_string(Refrigerant_, node, 'Refrigerant')
            self.Refrigerant = Refrigerant_
            # validate type Refrigerant
            self.validate_Refrigerant(self.Refrigerant)
        elif nodeName_ == 'RefrigerantChargeFactor':
            obj_ = RefrigerantChargeFactorType141.factory()
            obj_.build(child_)
            self.RefrigerantChargeFactor = obj_
            obj_.original_tagname_ = 'RefrigerantChargeFactor'
        elif nodeName_ == 'AbsorptionHeatSource':
            AbsorptionHeatSource_ = child_.text
            AbsorptionHeatSource_ = self.gds_validate_string(AbsorptionHeatSource_, node, 'AbsorptionHeatSource')
            self.AbsorptionHeatSource = AbsorptionHeatSource_
            # validate type AbsorptionHeatSourceType
            self.validate_AbsorptionHeatSourceType(self.AbsorptionHeatSource)
        elif nodeName_ == 'AbsorptionStages':
            AbsorptionStages_ = child_.text
            AbsorptionStages_ = self.gds_validate_string(AbsorptionStages_, node, 'AbsorptionStages')
            self.AbsorptionStages = AbsorptionStages_
            # validate type AbsorptionStagesType
            self.validate_AbsorptionStagesType(self.AbsorptionStages)
        elif nodeName_ == 'AnnualCoolingEfficiencyValue':
            obj_ = AnnualCoolingEfficiencyValueType142.factory()
            obj_.build(child_)
            self.AnnualCoolingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualCoolingEfficiencyValue'
        elif nodeName_ == 'AnnualCoolingEfficiencyUnits':
            AnnualCoolingEfficiencyUnits_ = child_.text
            AnnualCoolingEfficiencyUnits_ = self.gds_validate_string(AnnualCoolingEfficiencyUnits_, node, 'AnnualCoolingEfficiencyUnits')
            self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits_
            # validate type AnnualCoolingEfficiencyUnits
            self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'MinimumPartLoadRatio':
            obj_ = MinimumPartLoadRatioType143.factory()
            obj_.build(child_)
            self.MinimumPartLoadRatio = obj_
            obj_.original_tagname_ = 'MinimumPartLoadRatio'
        elif nodeName_ == 'RatedCoolingSensibleHeatRatio':
            obj_ = RatedCoolingSensibleHeatRatioType144.factory()
            obj_.build(child_)
            self.RatedCoolingSensibleHeatRatio = obj_
            obj_.original_tagname_ = 'RatedCoolingSensibleHeatRatio'
        elif nodeName_ == 'PartLoadRatioBelowWhichHotGasBypassOperates':
            obj_ = PartLoadRatioBelowWhichHotGasBypassOperatesType.factory()
            obj_.build(child_)
            self.PartLoadRatioBelowWhichHotGasBypassOperates = obj_
            obj_.original_tagname_ = 'PartLoadRatioBelowWhichHotGasBypassOperates'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
        elif nodeName_ == 'ChilledWaterResetControl':
            ChilledWaterResetControl_ = child_.text
            ChilledWaterResetControl_ = self.gds_validate_string(ChilledWaterResetControl_, node, 'ChilledWaterResetControl')
            self.ChilledWaterResetControl = ChilledWaterResetControl_
            # validate type ChilledWaterResetControlType
            self.validate_ChilledWaterResetControlType(self.ChilledWaterResetControl)
        elif nodeName_ == 'ChilledWaterSupplyTemperature':
            obj_ = ChilledWaterSupplyTemperatureType.factory()
            obj_.build(child_)
            self.ChilledWaterSupplyTemperature = obj_
            obj_.original_tagname_ = 'ChilledWaterSupplyTemperature'
        elif nodeName_ == 'ActiveDehumidification':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ActiveDehumidification')
            self.ActiveDehumidification = ival_
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class ChillerType137


class NumberOfDiscreteCoolingStagesType138(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfDiscreteCoolingStagesType138)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfDiscreteCoolingStagesType138.subclass:
            return NumberOfDiscreteCoolingStagesType138.subclass(*args_, **kwargs_)
        else:
            return NumberOfDiscreteCoolingStagesType138(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType138', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDiscreteCoolingStagesType138')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType138', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType138'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteCoolingStagesType138', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDiscreteCoolingStagesType138


class CoolingStageCapacityType139(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingStageCapacityType139)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingStageCapacityType139.subclass:
            return CoolingStageCapacityType139.subclass(*args_, **kwargs_)
        else:
            return CoolingStageCapacityType139(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CoolingStageCapacityType139', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoolingStageCapacityType139')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CoolingStageCapacityType139', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CoolingStageCapacityType139'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CoolingStageCapacityType139', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoolingStageCapacityType139


class CondenserPlantIDType140(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserPlantIDType140)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserPlantIDType140.subclass:
            return CondenserPlantIDType140.subclass(*args_, **kwargs_)
        else:
            return CondenserPlantIDType140(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType140', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserPlantIDType140')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserPlantIDType140', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserPlantIDType140'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType140', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondenserPlantIDType140


class RefrigerantChargeFactorType141(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerantChargeFactorType141)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerantChargeFactorType141.subclass:
            return RefrigerantChargeFactorType141.subclass(*args_, **kwargs_)
        else:
            return RefrigerantChargeFactorType141(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerantChargeFactorType141', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerantChargeFactorType141')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerantChargeFactorType141', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerantChargeFactorType141'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerantChargeFactorType141', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RefrigerantChargeFactorType141


class AnnualCoolingEfficiencyValueType142(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualCoolingEfficiencyValueType142)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualCoolingEfficiencyValueType142.subclass:
            return AnnualCoolingEfficiencyValueType142.subclass(*args_, **kwargs_)
        else:
            return AnnualCoolingEfficiencyValueType142(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType142', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualCoolingEfficiencyValueType142')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType142', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType142'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType142', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualCoolingEfficiencyValueType142


class MinimumPartLoadRatioType143(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumPartLoadRatioType143)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumPartLoadRatioType143.subclass:
            return MinimumPartLoadRatioType143.subclass(*args_, **kwargs_)
        else:
            return MinimumPartLoadRatioType143(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumPartLoadRatioType143', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumPartLoadRatioType143')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumPartLoadRatioType143', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumPartLoadRatioType143'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumPartLoadRatioType143', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumPartLoadRatioType143


class RatedCoolingSensibleHeatRatioType144(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatedCoolingSensibleHeatRatioType144)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatedCoolingSensibleHeatRatioType144.subclass:
            return RatedCoolingSensibleHeatRatioType144.subclass(*args_, **kwargs_)
        else:
            return RatedCoolingSensibleHeatRatioType144(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType144', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatedCoolingSensibleHeatRatioType144')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType144', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType144'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType144', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RatedCoolingSensibleHeatRatioType144


class PartLoadRatioBelowWhichHotGasBypassOperatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartLoadRatioBelowWhichHotGasBypassOperatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartLoadRatioBelowWhichHotGasBypassOperatesType.subclass:
            return PartLoadRatioBelowWhichHotGasBypassOperatesType.subclass(*args_, **kwargs_)
        else:
            return PartLoadRatioBelowWhichHotGasBypassOperatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PartLoadRatioBelowWhichHotGasBypassOperatesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartLoadRatioBelowWhichHotGasBypassOperatesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PartLoadRatioBelowWhichHotGasBypassOperatesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PartLoadRatioBelowWhichHotGasBypassOperatesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PartLoadRatioBelowWhichHotGasBypassOperatesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartLoadRatioBelowWhichHotGasBypassOperatesType


class ChilledWaterSupplyTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChilledWaterSupplyTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChilledWaterSupplyTemperatureType.subclass:
            return ChilledWaterSupplyTemperatureType.subclass(*args_, **kwargs_)
        else:
            return ChilledWaterSupplyTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChilledWaterSupplyTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChilledWaterSupplyTemperatureType


class DistrictChilledWaterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AnnualCoolingEfficiencyValue=None, AnnualCoolingEfficiencyUnits=None, Capacity=None, CapacityUnits=None, RatedCoolingSensibleHeatRatio=None, ChilledWaterSupplyTemperature=None, ActiveDehumidification=None):
        self.original_tagname_ = None
        self.AnnualCoolingEfficiencyValue = AnnualCoolingEfficiencyValue
        self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits
        self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.RatedCoolingSensibleHeatRatio = RatedCoolingSensibleHeatRatio
        self.ChilledWaterSupplyTemperature = ChilledWaterSupplyTemperature
        self.ActiveDehumidification = ActiveDehumidification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistrictChilledWaterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistrictChilledWaterType.subclass:
            return DistrictChilledWaterType.subclass(*args_, **kwargs_)
        else:
            return DistrictChilledWaterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AnnualCoolingEfficiencyUnits(self, value):
        # Validate type AnnualCoolingEfficiencyUnits, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.AnnualCoolingEfficiencyValue is not None or
            self.AnnualCoolingEfficiencyUnits is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.RatedCoolingSensibleHeatRatio is not None or
            self.ChilledWaterSupplyTemperature is not None or
            self.ActiveDehumidification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DistrictChilledWaterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistrictChilledWaterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DistrictChilledWaterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DistrictChilledWaterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DistrictChilledWaterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AnnualCoolingEfficiencyValue is not None:
            self.AnnualCoolingEfficiencyValue.export(outfile, level, namespace_, name_='AnnualCoolingEfficiencyValue', pretty_print=pretty_print)
        if self.AnnualCoolingEfficiencyUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnualCoolingEfficiencyUnits>%s</%sAnnualCoolingEfficiencyUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AnnualCoolingEfficiencyUnits), input_name='AnnualCoolingEfficiencyUnits')), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.RatedCoolingSensibleHeatRatio is not None:
            self.RatedCoolingSensibleHeatRatio.export(outfile, level, namespace_, name_='RatedCoolingSensibleHeatRatio', pretty_print=pretty_print)
        if self.ChilledWaterSupplyTemperature is not None:
            self.ChilledWaterSupplyTemperature.export(outfile, level, namespace_, name_='ChilledWaterSupplyTemperature', pretty_print=pretty_print)
        if self.ActiveDehumidification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sActiveDehumidification>%s</%sActiveDehumidification>%s' % (namespace_, self.gds_format_boolean(self.ActiveDehumidification, input_name='ActiveDehumidification'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AnnualCoolingEfficiencyValue':
            obj_ = AnnualCoolingEfficiencyValueType145.factory()
            obj_.build(child_)
            self.AnnualCoolingEfficiencyValue = obj_
            obj_.original_tagname_ = 'AnnualCoolingEfficiencyValue'
        elif nodeName_ == 'AnnualCoolingEfficiencyUnits':
            AnnualCoolingEfficiencyUnits_ = child_.text
            AnnualCoolingEfficiencyUnits_ = self.gds_validate_string(AnnualCoolingEfficiencyUnits_, node, 'AnnualCoolingEfficiencyUnits')
            self.AnnualCoolingEfficiencyUnits = AnnualCoolingEfficiencyUnits_
            # validate type AnnualCoolingEfficiencyUnits
            self.validate_AnnualCoolingEfficiencyUnits(self.AnnualCoolingEfficiencyUnits)
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'RatedCoolingSensibleHeatRatio':
            obj_ = RatedCoolingSensibleHeatRatioType146.factory()
            obj_.build(child_)
            self.RatedCoolingSensibleHeatRatio = obj_
            obj_.original_tagname_ = 'RatedCoolingSensibleHeatRatio'
        elif nodeName_ == 'ChilledWaterSupplyTemperature':
            obj_ = ChilledWaterSupplyTemperatureType147.factory()
            obj_.build(child_)
            self.ChilledWaterSupplyTemperature = obj_
            obj_.original_tagname_ = 'ChilledWaterSupplyTemperature'
        elif nodeName_ == 'ActiveDehumidification':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ActiveDehumidification')
            self.ActiveDehumidification = ival_
# end class DistrictChilledWaterType


class AnnualCoolingEfficiencyValueType145(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnualCoolingEfficiencyValueType145)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnualCoolingEfficiencyValueType145.subclass:
            return AnnualCoolingEfficiencyValueType145.subclass(*args_, **kwargs_)
        else:
            return AnnualCoolingEfficiencyValueType145(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType145', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnualCoolingEfficiencyValueType145')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType145', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType145'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AnnualCoolingEfficiencyValueType145', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnualCoolingEfficiencyValueType145


class RatedCoolingSensibleHeatRatioType146(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatedCoolingSensibleHeatRatioType146)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatedCoolingSensibleHeatRatioType146.subclass:
            return RatedCoolingSensibleHeatRatioType146.subclass(*args_, **kwargs_)
        else:
            return RatedCoolingSensibleHeatRatioType146(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType146', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatedCoolingSensibleHeatRatioType146')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType146', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType146'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatedCoolingSensibleHeatRatioType146', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RatedCoolingSensibleHeatRatioType146


class ChilledWaterSupplyTemperatureType147(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChilledWaterSupplyTemperatureType147)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChilledWaterSupplyTemperatureType147.subclass:
            return ChilledWaterSupplyTemperatureType147.subclass(*args_, **kwargs_)
        else:
            return ChilledWaterSupplyTemperatureType147(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType147', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChilledWaterSupplyTemperatureType147')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType147', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType147'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ChilledWaterSupplyTemperatureType147', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChilledWaterSupplyTemperatureType147


class AirCooledType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EvaporativelyCooledCondenser=None, CondenserFanSpeedOperation=None, CondensingTemperature=None, SplitCondenser=None, DesignAmbientTemperature=None, DesignTemperatureDifference=None):
        self.original_tagname_ = None
        self.EvaporativelyCooledCondenser = EvaporativelyCooledCondenser
        self.CondenserFanSpeedOperation = CondenserFanSpeedOperation
        self.validate_CondenserFanSpeedOperationType(self.CondenserFanSpeedOperation)
        self.CondensingTemperature = CondensingTemperature
        self.SplitCondenser = SplitCondenser
        self.DesignAmbientTemperature = DesignAmbientTemperature
        self.DesignTemperatureDifference = DesignTemperatureDifference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirCooledType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirCooledType.subclass:
            return AirCooledType.subclass(*args_, **kwargs_)
        else:
            return AirCooledType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CondenserFanSpeedOperationType(self, value):
        # Validate type CondenserFanSpeedOperationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Variable Volume', 'Stepped Speed', 'Constant Volume', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CondenserFanSpeedOperationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EvaporativelyCooledCondenser is not None or
            self.CondenserFanSpeedOperation is not None or
            self.CondensingTemperature is not None or
            self.SplitCondenser is not None or
            self.DesignAmbientTemperature is not None or
            self.DesignTemperatureDifference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AirCooledType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AirCooledType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AirCooledType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AirCooledType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AirCooledType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EvaporativelyCooledCondenser is not None:
            self.EvaporativelyCooledCondenser.export(outfile, level, namespace_, name_='EvaporativelyCooledCondenser', pretty_print=pretty_print)
        if self.CondenserFanSpeedOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCondenserFanSpeedOperation>%s</%sCondenserFanSpeedOperation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CondenserFanSpeedOperation), input_name='CondenserFanSpeedOperation')), namespace_, eol_))
        if self.CondensingTemperature is not None:
            self.CondensingTemperature.export(outfile, level, namespace_, name_='CondensingTemperature', pretty_print=pretty_print)
        if self.SplitCondenser is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSplitCondenser>%s</%sSplitCondenser>%s' % (namespace_, self.gds_format_boolean(self.SplitCondenser, input_name='SplitCondenser'), namespace_, eol_))
        if self.DesignAmbientTemperature is not None:
            self.DesignAmbientTemperature.export(outfile, level, namespace_, name_='DesignAmbientTemperature', pretty_print=pretty_print)
        if self.DesignTemperatureDifference is not None:
            self.DesignTemperatureDifference.export(outfile, level, namespace_, name_='DesignTemperatureDifference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EvaporativelyCooledCondenser':
            obj_ = EvaporativelyCooledCondenserType.factory()
            obj_.build(child_)
            self.EvaporativelyCooledCondenser = obj_
            obj_.original_tagname_ = 'EvaporativelyCooledCondenser'
        elif nodeName_ == 'CondenserFanSpeedOperation':
            CondenserFanSpeedOperation_ = child_.text
            CondenserFanSpeedOperation_ = self.gds_validate_string(CondenserFanSpeedOperation_, node, 'CondenserFanSpeedOperation')
            self.CondenserFanSpeedOperation = CondenserFanSpeedOperation_
            # validate type CondenserFanSpeedOperationType
            self.validate_CondenserFanSpeedOperationType(self.CondenserFanSpeedOperation)
        elif nodeName_ == 'CondensingTemperature':
            obj_ = CondensingTemperatureType.factory()
            obj_.build(child_)
            self.CondensingTemperature = obj_
            obj_.original_tagname_ = 'CondensingTemperature'
        elif nodeName_ == 'SplitCondenser':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SplitCondenser')
            self.SplitCondenser = ival_
        elif nodeName_ == 'DesignAmbientTemperature':
            obj_ = DesignAmbientTemperatureType.factory()
            obj_.build(child_)
            self.DesignAmbientTemperature = obj_
            obj_.original_tagname_ = 'DesignAmbientTemperature'
        elif nodeName_ == 'DesignTemperatureDifference':
            obj_ = DesignTemperatureDifferenceType.factory()
            obj_.build(child_)
            self.DesignTemperatureDifference = obj_
            obj_.original_tagname_ = 'DesignTemperatureDifference'
# end class AirCooledType


class EvaporativelyCooledCondenserType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EvaporativelyCooledCondenserType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EvaporativelyCooledCondenserType.subclass:
            return EvaporativelyCooledCondenserType.subclass(*args_, **kwargs_)
        else:
            return EvaporativelyCooledCondenserType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EvaporativelyCooledCondenserType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EvaporativelyCooledCondenserType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EvaporativelyCooledCondenserType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType148.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class EvaporativelyCooledCondenserType


class TrueType148(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, EvaporativelyCooledCondenserMaximumTemperature=None, EvaporativelyCooledCondenserMinimumTemperature=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.EvaporativelyCooledCondenserMaximumTemperature = EvaporativelyCooledCondenserMaximumTemperature
        self.EvaporativelyCooledCondenserMinimumTemperature = EvaporativelyCooledCondenserMinimumTemperature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType148)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType148.subclass:
            return TrueType148.subclass(*args_, **kwargs_)
        else:
            return TrueType148(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.EvaporativelyCooledCondenserMaximumTemperature is not None or
            self.EvaporativelyCooledCondenserMinimumTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType148', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType148')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType148', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType148'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType148', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EvaporativelyCooledCondenserMaximumTemperature is not None:
            self.EvaporativelyCooledCondenserMaximumTemperature.export(outfile, level, namespace_, name_='EvaporativelyCooledCondenserMaximumTemperature', pretty_print=pretty_print)
        if self.EvaporativelyCooledCondenserMinimumTemperature is not None:
            self.EvaporativelyCooledCondenserMinimumTemperature.export(outfile, level, namespace_, name_='EvaporativelyCooledCondenserMinimumTemperature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EvaporativelyCooledCondenserMaximumTemperature':
            obj_ = EvaporativelyCooledCondenserMaximumTemperatureType.factory()
            obj_.build(child_)
            self.EvaporativelyCooledCondenserMaximumTemperature = obj_
            obj_.original_tagname_ = 'EvaporativelyCooledCondenserMaximumTemperature'
        elif nodeName_ == 'EvaporativelyCooledCondenserMinimumTemperature':
            obj_ = EvaporativelyCooledCondenserMinimumTemperatureType.factory()
            obj_.build(child_)
            self.EvaporativelyCooledCondenserMinimumTemperature = obj_
            obj_.original_tagname_ = 'EvaporativelyCooledCondenserMinimumTemperature'
# end class TrueType148


class EvaporativelyCooledCondenserMaximumTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EvaporativelyCooledCondenserMaximumTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EvaporativelyCooledCondenserMaximumTemperatureType.subclass:
            return EvaporativelyCooledCondenserMaximumTemperatureType.subclass(*args_, **kwargs_)
        else:
            return EvaporativelyCooledCondenserMaximumTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserMaximumTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EvaporativelyCooledCondenserMaximumTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EvaporativelyCooledCondenserMaximumTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EvaporativelyCooledCondenserMaximumTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserMaximumTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EvaporativelyCooledCondenserMaximumTemperatureType


class EvaporativelyCooledCondenserMinimumTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EvaporativelyCooledCondenserMinimumTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EvaporativelyCooledCondenserMinimumTemperatureType.subclass:
            return EvaporativelyCooledCondenserMinimumTemperatureType.subclass(*args_, **kwargs_)
        else:
            return EvaporativelyCooledCondenserMinimumTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserMinimumTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EvaporativelyCooledCondenserMinimumTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EvaporativelyCooledCondenserMinimumTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EvaporativelyCooledCondenserMinimumTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EvaporativelyCooledCondenserMinimumTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EvaporativelyCooledCondenserMinimumTemperatureType


class CondensingTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondensingTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondensingTemperatureType.subclass:
            return CondensingTemperatureType.subclass(*args_, **kwargs_)
        else:
            return CondensingTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondensingTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondensingTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondensingTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondensingTemperatureType


class DesignAmbientTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DesignAmbientTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DesignAmbientTemperatureType.subclass:
            return DesignAmbientTemperatureType.subclass(*args_, **kwargs_)
        else:
            return DesignAmbientTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DesignAmbientTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DesignAmbientTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DesignAmbientTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DesignAmbientTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DesignAmbientTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DesignAmbientTemperatureType


class DesignTemperatureDifferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DesignTemperatureDifferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DesignTemperatureDifferenceType.subclass:
            return DesignTemperatureDifferenceType.subclass(*args_, **kwargs_)
        else:
            return DesignTemperatureDifferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DesignTemperatureDifferenceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DesignTemperatureDifferenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DesignTemperatureDifferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DesignTemperatureDifferenceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DesignTemperatureDifferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DesignTemperatureDifferenceType


class WaterCooledType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WaterCooledCondenserType=None, CondenserWaterTemperature=None, CondensingTemperature=None, WaterCooledCondenserFlowControl=None, WaterSideEconomizer=None, CoolingTowerControlType=None, CellCount=None):
        self.original_tagname_ = None
        self.WaterCooledCondenserType = WaterCooledCondenserType
        self.validate_WaterCooledCondenserTypeType(self.WaterCooledCondenserType)
        self.CondenserWaterTemperature = CondenserWaterTemperature
        self.CondensingTemperature = CondensingTemperature
        self.WaterCooledCondenserFlowControl = WaterCooledCondenserFlowControl
        self.validate_WaterCooledCondenserFlowControl(self.WaterCooledCondenserFlowControl)
        self.WaterSideEconomizer = WaterSideEconomizer
        self.CoolingTowerControlType = CoolingTowerControlType
        self.validate_CoolingTowerControlTypeType(self.CoolingTowerControlType)
        self.CellCount = CellCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterCooledType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterCooledType.subclass:
            return WaterCooledType.subclass(*args_, **kwargs_)
        else:
            return WaterCooledType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WaterCooledCondenserTypeType(self, value):
        # Validate type WaterCooledCondenserTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cooling tower', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WaterCooledCondenserTypeType' % {"value" : value.encode("utf-8")} )
    def validate_WaterCooledCondenserFlowControl(self, value):
        # Validate type WaterCooledCondenserFlowControl, a restriction on xs:string.
        pass
    def validate_CoolingTowerControlTypeType(self, value):
        # Validate type CoolingTowerControlTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Wet Bulb Reset', 'Max Cells', 'Min Cells', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CoolingTowerControlTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.WaterCooledCondenserType is not None or
            self.CondenserWaterTemperature is not None or
            self.CondensingTemperature is not None or
            self.WaterCooledCondenserFlowControl is not None or
            self.WaterSideEconomizer is not None or
            self.CoolingTowerControlType is not None or
            self.CellCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterCooledType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterCooledType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterCooledType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterCooledType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterCooledType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WaterCooledCondenserType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterCooledCondenserType>%s</%sWaterCooledCondenserType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterCooledCondenserType), input_name='WaterCooledCondenserType')), namespace_, eol_))
        if self.CondenserWaterTemperature is not None:
            self.CondenserWaterTemperature.export(outfile, level, namespace_, name_='CondenserWaterTemperature', pretty_print=pretty_print)
        if self.CondensingTemperature is not None:
            self.CondensingTemperature.export(outfile, level, namespace_, name_='CondensingTemperature', pretty_print=pretty_print)
        if self.WaterCooledCondenserFlowControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterCooledCondenserFlowControl>%s</%sWaterCooledCondenserFlowControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterCooledCondenserFlowControl), input_name='WaterCooledCondenserFlowControl')), namespace_, eol_))
        if self.WaterSideEconomizer is not None:
            self.WaterSideEconomizer.export(outfile, level, namespace_, name_='WaterSideEconomizer', pretty_print=pretty_print)
        if self.CoolingTowerControlType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoolingTowerControlType>%s</%sCoolingTowerControlType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CoolingTowerControlType), input_name='CoolingTowerControlType')), namespace_, eol_))
        if self.CellCount is not None:
            self.CellCount.export(outfile, level, namespace_, name_='CellCount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterCooledCondenserType':
            WaterCooledCondenserType_ = child_.text
            WaterCooledCondenserType_ = self.gds_validate_string(WaterCooledCondenserType_, node, 'WaterCooledCondenserType')
            self.WaterCooledCondenserType = WaterCooledCondenserType_
            # validate type WaterCooledCondenserTypeType
            self.validate_WaterCooledCondenserTypeType(self.WaterCooledCondenserType)
        elif nodeName_ == 'CondenserWaterTemperature':
            obj_ = CondenserWaterTemperatureType.factory()
            obj_.build(child_)
            self.CondenserWaterTemperature = obj_
            obj_.original_tagname_ = 'CondenserWaterTemperature'
        elif nodeName_ == 'CondensingTemperature':
            obj_ = CondensingTemperatureType149.factory()
            obj_.build(child_)
            self.CondensingTemperature = obj_
            obj_.original_tagname_ = 'CondensingTemperature'
        elif nodeName_ == 'WaterCooledCondenserFlowControl':
            WaterCooledCondenserFlowControl_ = child_.text
            WaterCooledCondenserFlowControl_ = self.gds_validate_string(WaterCooledCondenserFlowControl_, node, 'WaterCooledCondenserFlowControl')
            self.WaterCooledCondenserFlowControl = WaterCooledCondenserFlowControl_
            # validate type WaterCooledCondenserFlowControl
            self.validate_WaterCooledCondenserFlowControl(self.WaterCooledCondenserFlowControl)
        elif nodeName_ == 'WaterSideEconomizer':
            obj_ = WaterSideEconomizerType150.factory()
            obj_.build(child_)
            self.WaterSideEconomizer = obj_
            obj_.original_tagname_ = 'WaterSideEconomizer'
        elif nodeName_ == 'CoolingTowerControlType':
            CoolingTowerControlType_ = child_.text
            CoolingTowerControlType_ = self.gds_validate_string(CoolingTowerControlType_, node, 'CoolingTowerControlType')
            self.CoolingTowerControlType = CoolingTowerControlType_
            # validate type CoolingTowerControlTypeType
            self.validate_CoolingTowerControlTypeType(self.CoolingTowerControlType)
        elif nodeName_ == 'CellCount':
            obj_ = CellCountType.factory()
            obj_.build(child_)
            self.CellCount = obj_
            obj_.original_tagname_ = 'CellCount'
# end class WaterCooledType


class CondenserWaterTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserWaterTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserWaterTemperatureType.subclass:
            return CondenserWaterTemperatureType.subclass(*args_, **kwargs_)
        else:
            return CondenserWaterTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserWaterTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserWaterTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserWaterTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserWaterTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserWaterTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondenserWaterTemperatureType


class CondensingTemperatureType149(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondensingTemperatureType149)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondensingTemperatureType149.subclass:
            return CondensingTemperatureType149.subclass(*args_, **kwargs_)
        else:
            return CondensingTemperatureType149(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType149', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondensingTemperatureType149')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondensingTemperatureType149', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondensingTemperatureType149'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType149', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondensingTemperatureType149


class WaterSideEconomizerType150(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerType150)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerType150.subclass:
            return WaterSideEconomizerType150.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerType150(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType150', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerType150')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerType150', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerType150'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType150', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType151.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class WaterSideEconomizerType150


class TrueType151(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, WaterSideEconomizerType=None, WaterSideEconomizerTemperatureMaximum=None, WaterSideEconomizerDBTemperatureMaximum=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.WaterSideEconomizerType = WaterSideEconomizerType
        self.validate_WaterSideEconomizerType(self.WaterSideEconomizerType)
        self.WaterSideEconomizerTemperatureMaximum = WaterSideEconomizerTemperatureMaximum
        self.WaterSideEconomizerDBTemperatureMaximum = WaterSideEconomizerDBTemperatureMaximum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType151)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType151.subclass:
            return TrueType151.subclass(*args_, **kwargs_)
        else:
            return TrueType151(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WaterSideEconomizerType(self, value):
        # Validate type WaterSideEconomizerType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.WaterSideEconomizerType is not None or
            self.WaterSideEconomizerTemperatureMaximum is not None or
            self.WaterSideEconomizerDBTemperatureMaximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType151', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType151')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType151', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType151'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType151', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WaterSideEconomizerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterSideEconomizerType>%s</%sWaterSideEconomizerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterSideEconomizerType), input_name='WaterSideEconomizerType')), namespace_, eol_))
        if self.WaterSideEconomizerTemperatureMaximum is not None:
            self.WaterSideEconomizerTemperatureMaximum.export(outfile, level, namespace_, name_='WaterSideEconomizerTemperatureMaximum', pretty_print=pretty_print)
        if self.WaterSideEconomizerDBTemperatureMaximum is not None:
            self.WaterSideEconomizerDBTemperatureMaximum.export(outfile, level, namespace_, name_='WaterSideEconomizerDBTemperatureMaximum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterSideEconomizerType':
            WaterSideEconomizerType_ = child_.text
            WaterSideEconomizerType_ = self.gds_validate_string(WaterSideEconomizerType_, node, 'WaterSideEconomizerType')
            self.WaterSideEconomizerType = WaterSideEconomizerType_
            # validate type WaterSideEconomizerType
            self.validate_WaterSideEconomizerType(self.WaterSideEconomizerType)
        elif nodeName_ == 'WaterSideEconomizerTemperatureMaximum':
            obj_ = WaterSideEconomizerTemperatureMaximumType.factory()
            obj_.build(child_)
            self.WaterSideEconomizerTemperatureMaximum = obj_
            obj_.original_tagname_ = 'WaterSideEconomizerTemperatureMaximum'
        elif nodeName_ == 'WaterSideEconomizerDBTemperatureMaximum':
            obj_ = WaterSideEconomizerDBTemperatureMaximumType.factory()
            obj_.build(child_)
            self.WaterSideEconomizerDBTemperatureMaximum = obj_
            obj_.original_tagname_ = 'WaterSideEconomizerDBTemperatureMaximum'
# end class TrueType151


class WaterSideEconomizerTemperatureMaximumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerTemperatureMaximumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerTemperatureMaximumType.subclass:
            return WaterSideEconomizerTemperatureMaximumType.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerTemperatureMaximumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerTemperatureMaximumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerTemperatureMaximumType


class WaterSideEconomizerDBTemperatureMaximumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerDBTemperatureMaximumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerDBTemperatureMaximumType.subclass:
            return WaterSideEconomizerDBTemperatureMaximumType.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerDBTemperatureMaximumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerDBTemperatureMaximumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerDBTemperatureMaximumType


class CellCountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CellCountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CellCountType.subclass:
            return CellCountType.subclass(*args_, **kwargs_)
        else:
            return CellCountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CellCountType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellCountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CellCountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CellCountType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CellCountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CellCountType


class GroundSourceType152(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GroundSourceType=None, CondenserWaterTemperature=None, CondensingTemperature=None, WaterCooledCondenserFlowControl=None, WaterSideEconomizer=None, WellCount=None):
        self.original_tagname_ = None
        self.GroundSourceType = GroundSourceType
        self.validate_GroundSourceTypeType(self.GroundSourceType)
        self.CondenserWaterTemperature = CondenserWaterTemperature
        self.CondensingTemperature = CondensingTemperature
        self.WaterCooledCondenserFlowControl = WaterCooledCondenserFlowControl
        self.validate_WaterCooledCondenserFlowControl(self.WaterCooledCondenserFlowControl)
        self.WaterSideEconomizer = WaterSideEconomizer
        self.WellCount = WellCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroundSourceType152)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroundSourceType152.subclass:
            return GroundSourceType152.subclass(*args_, **kwargs_)
        else:
            return GroundSourceType152(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_GroundSourceTypeType(self, value):
        # Validate type GroundSourceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Open loop ground water', 'Closed loop ground source', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GroundSourceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_WaterCooledCondenserFlowControl(self, value):
        # Validate type WaterCooledCondenserFlowControl, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.GroundSourceType is not None or
            self.CondenserWaterTemperature is not None or
            self.CondensingTemperature is not None or
            self.WaterCooledCondenserFlowControl is not None or
            self.WaterSideEconomizer is not None or
            self.WellCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GroundSourceType152', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroundSourceType152')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GroundSourceType152', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GroundSourceType152'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GroundSourceType152', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GroundSourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroundSourceType>%s</%sGroundSourceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.GroundSourceType), input_name='GroundSourceType')), namespace_, eol_))
        if self.CondenserWaterTemperature is not None:
            self.CondenserWaterTemperature.export(outfile, level, namespace_, name_='CondenserWaterTemperature', pretty_print=pretty_print)
        if self.CondensingTemperature is not None:
            self.CondensingTemperature.export(outfile, level, namespace_, name_='CondensingTemperature', pretty_print=pretty_print)
        if self.WaterCooledCondenserFlowControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterCooledCondenserFlowControl>%s</%sWaterCooledCondenserFlowControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterCooledCondenserFlowControl), input_name='WaterCooledCondenserFlowControl')), namespace_, eol_))
        if self.WaterSideEconomizer is not None:
            self.WaterSideEconomizer.export(outfile, level, namespace_, name_='WaterSideEconomizer', pretty_print=pretty_print)
        if self.WellCount is not None:
            self.WellCount.export(outfile, level, namespace_, name_='WellCount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GroundSourceType':
            GroundSourceType_ = child_.text
            GroundSourceType_ = self.gds_validate_string(GroundSourceType_, node, 'GroundSourceType')
            self.GroundSourceType = GroundSourceType_
            # validate type GroundSourceTypeType
            self.validate_GroundSourceTypeType(self.GroundSourceType)
        elif nodeName_ == 'CondenserWaterTemperature':
            obj_ = CondenserWaterTemperatureType153.factory()
            obj_.build(child_)
            self.CondenserWaterTemperature = obj_
            obj_.original_tagname_ = 'CondenserWaterTemperature'
        elif nodeName_ == 'CondensingTemperature':
            obj_ = CondensingTemperatureType154.factory()
            obj_.build(child_)
            self.CondensingTemperature = obj_
            obj_.original_tagname_ = 'CondensingTemperature'
        elif nodeName_ == 'WaterCooledCondenserFlowControl':
            WaterCooledCondenserFlowControl_ = child_.text
            WaterCooledCondenserFlowControl_ = self.gds_validate_string(WaterCooledCondenserFlowControl_, node, 'WaterCooledCondenserFlowControl')
            self.WaterCooledCondenserFlowControl = WaterCooledCondenserFlowControl_
            # validate type WaterCooledCondenserFlowControl
            self.validate_WaterCooledCondenserFlowControl(self.WaterCooledCondenserFlowControl)
        elif nodeName_ == 'WaterSideEconomizer':
            obj_ = WaterSideEconomizerType155.factory()
            obj_.build(child_)
            self.WaterSideEconomizer = obj_
            obj_.original_tagname_ = 'WaterSideEconomizer'
        elif nodeName_ == 'WellCount':
            obj_ = WellCountType.factory()
            obj_.build(child_)
            self.WellCount = obj_
            obj_.original_tagname_ = 'WellCount'
# end class GroundSourceType152


class CondenserWaterTemperatureType153(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserWaterTemperatureType153)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserWaterTemperatureType153.subclass:
            return CondenserWaterTemperatureType153.subclass(*args_, **kwargs_)
        else:
            return CondenserWaterTemperatureType153(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserWaterTemperatureType153', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserWaterTemperatureType153')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserWaterTemperatureType153', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserWaterTemperatureType153'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserWaterTemperatureType153', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondenserWaterTemperatureType153


class CondensingTemperatureType154(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondensingTemperatureType154)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondensingTemperatureType154.subclass:
            return CondensingTemperatureType154.subclass(*args_, **kwargs_)
        else:
            return CondensingTemperatureType154(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType154', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondensingTemperatureType154')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondensingTemperatureType154', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondensingTemperatureType154'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType154', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondensingTemperatureType154


class WaterSideEconomizerType155(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerType155)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerType155.subclass:
            return WaterSideEconomizerType155.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerType155(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType155', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerType155')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerType155', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerType155'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerType155', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType156.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class WaterSideEconomizerType155


class TrueType156(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, WaterSideEconomizerType=None, WaterSideEconomizerTemperatureSetpoint=None, WaterSideEconomizerTemperatureMaximum=None, WaterSideEconomizerDBTemperatureMaximum=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.WaterSideEconomizerType = WaterSideEconomizerType
        self.validate_WaterSideEconomizerType(self.WaterSideEconomizerType)
        self.WaterSideEconomizerTemperatureSetpoint = WaterSideEconomizerTemperatureSetpoint
        self.WaterSideEconomizerTemperatureMaximum = WaterSideEconomizerTemperatureMaximum
        self.WaterSideEconomizerDBTemperatureMaximum = WaterSideEconomizerDBTemperatureMaximum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType156)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType156.subclass:
            return TrueType156.subclass(*args_, **kwargs_)
        else:
            return TrueType156(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WaterSideEconomizerType(self, value):
        # Validate type WaterSideEconomizerType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.WaterSideEconomizerType is not None or
            self.WaterSideEconomizerTemperatureSetpoint is not None or
            self.WaterSideEconomizerTemperatureMaximum is not None or
            self.WaterSideEconomizerDBTemperatureMaximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType156', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType156')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType156', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType156'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType156', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WaterSideEconomizerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWaterSideEconomizerType>%s</%sWaterSideEconomizerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WaterSideEconomizerType), input_name='WaterSideEconomizerType')), namespace_, eol_))
        if self.WaterSideEconomizerTemperatureSetpoint is not None:
            self.WaterSideEconomizerTemperatureSetpoint.export(outfile, level, namespace_, name_='WaterSideEconomizerTemperatureSetpoint', pretty_print=pretty_print)
        if self.WaterSideEconomizerTemperatureMaximum is not None:
            self.WaterSideEconomizerTemperatureMaximum.export(outfile, level, namespace_, name_='WaterSideEconomizerTemperatureMaximum', pretty_print=pretty_print)
        if self.WaterSideEconomizerDBTemperatureMaximum is not None:
            self.WaterSideEconomizerDBTemperatureMaximum.export(outfile, level, namespace_, name_='WaterSideEconomizerDBTemperatureMaximum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WaterSideEconomizerType':
            WaterSideEconomizerType_ = child_.text
            WaterSideEconomizerType_ = self.gds_validate_string(WaterSideEconomizerType_, node, 'WaterSideEconomizerType')
            self.WaterSideEconomizerType = WaterSideEconomizerType_
            # validate type WaterSideEconomizerType
            self.validate_WaterSideEconomizerType(self.WaterSideEconomizerType)
        elif nodeName_ == 'WaterSideEconomizerTemperatureSetpoint':
            obj_ = WaterSideEconomizerTemperatureSetpointType.factory()
            obj_.build(child_)
            self.WaterSideEconomizerTemperatureSetpoint = obj_
            obj_.original_tagname_ = 'WaterSideEconomizerTemperatureSetpoint'
        elif nodeName_ == 'WaterSideEconomizerTemperatureMaximum':
            obj_ = WaterSideEconomizerTemperatureMaximumType157.factory()
            obj_.build(child_)
            self.WaterSideEconomizerTemperatureMaximum = obj_
            obj_.original_tagname_ = 'WaterSideEconomizerTemperatureMaximum'
        elif nodeName_ == 'WaterSideEconomizerDBTemperatureMaximum':
            obj_ = WaterSideEconomizerDBTemperatureMaximumType158.factory()
            obj_.build(child_)
            self.WaterSideEconomizerDBTemperatureMaximum = obj_
            obj_.original_tagname_ = 'WaterSideEconomizerDBTemperatureMaximum'
# end class TrueType156


class WaterSideEconomizerTemperatureSetpointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerTemperatureSetpointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerTemperatureSetpointType.subclass:
            return WaterSideEconomizerTemperatureSetpointType.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerTemperatureSetpointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureSetpointType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerTemperatureSetpointType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerTemperatureSetpointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerTemperatureSetpointType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureSetpointType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerTemperatureSetpointType


class WaterSideEconomizerTemperatureMaximumType157(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerTemperatureMaximumType157)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerTemperatureMaximumType157.subclass:
            return WaterSideEconomizerTemperatureMaximumType157.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerTemperatureMaximumType157(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType157', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerTemperatureMaximumType157')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType157', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType157'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerTemperatureMaximumType157', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerTemperatureMaximumType157


class WaterSideEconomizerDBTemperatureMaximumType158(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterSideEconomizerDBTemperatureMaximumType158)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterSideEconomizerDBTemperatureMaximumType158.subclass:
            return WaterSideEconomizerDBTemperatureMaximumType158.subclass(*args_, **kwargs_)
        else:
            return WaterSideEconomizerDBTemperatureMaximumType158(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType158', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterSideEconomizerDBTemperatureMaximumType158')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType158', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType158'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterSideEconomizerDBTemperatureMaximumType158', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterSideEconomizerDBTemperatureMaximumType158


class WellCountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WellCountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WellCountType.subclass:
            return WellCountType.subclass(*args_, **kwargs_)
        else:
            return WellCountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WellCountType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WellCountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WellCountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WellCountType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WellCountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WellCountType


class GlycolCooledDryCoolerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CondensingTemperature=None):
        self.original_tagname_ = None
        self.CondensingTemperature = CondensingTemperature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlycolCooledDryCoolerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlycolCooledDryCoolerType.subclass:
            return GlycolCooledDryCoolerType.subclass(*args_, **kwargs_)
        else:
            return GlycolCooledDryCoolerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CondensingTemperature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GlycolCooledDryCoolerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GlycolCooledDryCoolerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GlycolCooledDryCoolerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GlycolCooledDryCoolerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GlycolCooledDryCoolerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CondensingTemperature is not None:
            self.CondensingTemperature.export(outfile, level, namespace_, name_='CondensingTemperature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CondensingTemperature':
            obj_ = CondensingTemperatureType159.factory()
            obj_.build(child_)
            self.CondensingTemperature = obj_
            obj_.original_tagname_ = 'CondensingTemperature'
# end class GlycolCooledDryCoolerType


class CondensingTemperatureType159(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondensingTemperatureType159)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondensingTemperatureType159.subclass:
            return CondensingTemperatureType159.subclass(*args_, **kwargs_)
        else:
            return CondensingTemperatureType159(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType159', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondensingTemperatureType159')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondensingTemperatureType159', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondensingTemperatureType159'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondensingTemperatureType159', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondensingTemperatureType159


class OtherHVACTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Humidifier=None, Dehumidifier=None, AirCleaner=None, MechanicalVentilation=None, SpotExhaust=None, NaturalVentilation=None, OtherCombination=None, Unknown=None):
        self.original_tagname_ = None
        self.Humidifier = Humidifier
        self.Dehumidifier = Dehumidifier
        self.AirCleaner = AirCleaner
        self.MechanicalVentilation = MechanicalVentilation
        self.SpotExhaust = SpotExhaust
        self.NaturalVentilation = NaturalVentilation
        self.OtherCombination = OtherCombination
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherHVACTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherHVACTypeType.subclass:
            return OtherHVACTypeType.subclass(*args_, **kwargs_)
        else:
            return OtherHVACTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Humidifier is not None or
            self.Dehumidifier is not None or
            self.AirCleaner is not None or
            self.MechanicalVentilation is not None or
            self.SpotExhaust is not None or
            self.NaturalVentilation is not None or
            self.OtherCombination is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherHVACTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherHVACTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherHVACTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherHVACTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherHVACTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Humidifier is not None:
            self.Humidifier.export(outfile, level, namespace_, name_='Humidifier', pretty_print=pretty_print)
        if self.Dehumidifier is not None:
            self.Dehumidifier.export(outfile, level, namespace_, name_='Dehumidifier', pretty_print=pretty_print)
        if self.AirCleaner is not None:
            self.AirCleaner.export(outfile, level, namespace_, name_='AirCleaner', pretty_print=pretty_print)
        if self.MechanicalVentilation is not None:
            self.MechanicalVentilation.export(outfile, level, namespace_, name_='MechanicalVentilation', pretty_print=pretty_print)
        if self.SpotExhaust is not None:
            self.SpotExhaust.export(outfile, level, namespace_, name_='SpotExhaust', pretty_print=pretty_print)
        if self.NaturalVentilation is not None:
            self.NaturalVentilation.export(outfile, level, namespace_, name_='NaturalVentilation', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Humidifier':
            obj_ = HumidifierType.factory()
            obj_.build(child_)
            self.Humidifier = obj_
            obj_.original_tagname_ = 'Humidifier'
        elif nodeName_ == 'Dehumidifier':
            obj_ = DehumidifierType.factory()
            obj_.build(child_)
            self.Dehumidifier = obj_
            obj_.original_tagname_ = 'Dehumidifier'
        elif nodeName_ == 'AirCleaner':
            obj_ = AirCleanerType.factory()
            obj_.build(child_)
            self.AirCleaner = obj_
            obj_.original_tagname_ = 'AirCleaner'
        elif nodeName_ == 'MechanicalVentilation':
            obj_ = MechanicalVentilationType.factory()
            obj_.build(child_)
            self.MechanicalVentilation = obj_
            obj_.original_tagname_ = 'MechanicalVentilation'
        elif nodeName_ == 'SpotExhaust':
            obj_ = SpotExhaustType.factory()
            obj_.build(child_)
            self.SpotExhaust = obj_
            obj_.original_tagname_ = 'SpotExhaust'
        elif nodeName_ == 'NaturalVentilation':
            obj_ = NaturalVentilationType.factory()
            obj_.build(child_)
            self.NaturalVentilation = obj_
            obj_.original_tagname_ = 'NaturalVentilation'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class OtherHVACTypeType


class HumidifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HumidificationType=None, HumidityControlMinimum=None, Capacity=None, CapacityUnits=None, DutyCycle=None, SystemPerformanceRatio=None):
        self.original_tagname_ = None
        self.HumidificationType = HumidificationType
        self.validate_HumidificationTypeType(self.HumidificationType)
        self.HumidityControlMinimum = HumidityControlMinimum
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
        self.SystemPerformanceRatio = SystemPerformanceRatio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HumidifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HumidifierType.subclass:
            return HumidifierType.subclass(*args_, **kwargs_)
        else:
            return HumidifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_HumidificationTypeType(self, value):
        # Validate type HumidificationTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Steam', 'Water Spray', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HumidificationTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.HumidificationType is not None or
            self.HumidityControlMinimum is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None or
            self.SystemPerformanceRatio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HumidifierType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HumidifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HumidifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HumidifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HumidifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HumidificationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHumidificationType>%s</%sHumidificationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HumidificationType), input_name='HumidificationType')), namespace_, eol_))
        if self.HumidityControlMinimum is not None:
            self.HumidityControlMinimum.export(outfile, level, namespace_, name_='HumidityControlMinimum', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
        if self.SystemPerformanceRatio is not None:
            self.SystemPerformanceRatio.export(outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HumidificationType':
            HumidificationType_ = child_.text
            HumidificationType_ = self.gds_validate_string(HumidificationType_, node, 'HumidificationType')
            self.HumidificationType = HumidificationType_
            # validate type HumidificationTypeType
            self.validate_HumidificationTypeType(self.HumidificationType)
        elif nodeName_ == 'HumidityControlMinimum':
            obj_ = HumidityControlMinimumType.factory()
            obj_.build(child_)
            self.HumidityControlMinimum = obj_
            obj_.original_tagname_ = 'HumidityControlMinimum'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'SystemPerformanceRatio':
            obj_ = SystemPerformanceRatio.factory()
            obj_.build(child_)
            self.SystemPerformanceRatio = obj_
            obj_.original_tagname_ = 'SystemPerformanceRatio'
# end class HumidifierType


class HumidityControlMinimumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HumidityControlMinimumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HumidityControlMinimumType.subclass:
            return HumidityControlMinimumType.subclass(*args_, **kwargs_)
        else:
            return HumidityControlMinimumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HumidityControlMinimumType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HumidityControlMinimumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HumidityControlMinimumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HumidityControlMinimumType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HumidityControlMinimumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HumidityControlMinimumType


class DehumidifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DehumidificationType=None, HumidityControlMaximum=None, Capacity=None, CapacityUnits=None, DutyCycle=None, SystemPerformanceRatio=None, ThirdPartyCertification=None):
        self.original_tagname_ = None
        self.DehumidificationType = DehumidificationType
        self.validate_DehumidificationTypeType(self.DehumidificationType)
        self.HumidityControlMaximum = HumidityControlMaximum
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
        self.SystemPerformanceRatio = SystemPerformanceRatio
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DehumidifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DehumidifierType.subclass:
            return DehumidifierType.subclass(*args_, **kwargs_)
        else:
            return DehumidifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DehumidificationTypeType(self, value):
        # Validate type DehumidificationTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Desiccant wheel', 'Liquid desiccant', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DehumidificationTypeType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DehumidificationType is not None or
            self.HumidityControlMaximum is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None or
            self.SystemPerformanceRatio is not None or
            self.ThirdPartyCertification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DehumidifierType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DehumidifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DehumidifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DehumidifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DehumidifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DehumidificationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDehumidificationType>%s</%sDehumidificationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DehumidificationType), input_name='DehumidificationType')), namespace_, eol_))
        if self.HumidityControlMaximum is not None:
            self.HumidityControlMaximum.export(outfile, level, namespace_, name_='HumidityControlMaximum', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
        if self.SystemPerformanceRatio is not None:
            self.SystemPerformanceRatio.export(outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DehumidificationType':
            DehumidificationType_ = child_.text
            DehumidificationType_ = self.gds_validate_string(DehumidificationType_, node, 'DehumidificationType')
            self.DehumidificationType = DehumidificationType_
            # validate type DehumidificationTypeType
            self.validate_DehumidificationTypeType(self.DehumidificationType)
        elif nodeName_ == 'HumidityControlMaximum':
            obj_ = HumidityControlMaximumType.factory()
            obj_.build(child_)
            self.HumidityControlMaximum = obj_
            obj_.original_tagname_ = 'HumidityControlMaximum'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'SystemPerformanceRatio':
            obj_ = SystemPerformanceRatio.factory()
            obj_.build(child_)
            self.SystemPerformanceRatio = obj_
            obj_.original_tagname_ = 'SystemPerformanceRatio'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
# end class DehumidifierType


class HumidityControlMaximumType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HumidityControlMaximumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HumidityControlMaximumType.subclass:
            return HumidityControlMaximumType.subclass(*args_, **kwargs_)
        else:
            return HumidityControlMaximumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HumidityControlMaximumType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HumidityControlMaximumType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HumidityControlMaximumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HumidityControlMaximumType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HumidityControlMaximumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HumidityControlMaximumType


class AirCleanerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Capacity=None, CapacityUnits=None, DutyCycle=None, SystemPerformanceRatio=None):
        self.original_tagname_ = None
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
        self.SystemPerformanceRatio = SystemPerformanceRatio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AirCleanerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AirCleanerType.subclass:
            return AirCleanerType.subclass(*args_, **kwargs_)
        else:
            return AirCleanerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None or
            self.SystemPerformanceRatio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AirCleanerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AirCleanerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AirCleanerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AirCleanerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AirCleanerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
        if self.SystemPerformanceRatio is not None:
            self.SystemPerformanceRatio.export(outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'SystemPerformanceRatio':
            obj_ = SystemPerformanceRatio.factory()
            obj_.build(child_)
            self.SystemPerformanceRatio = obj_
            obj_.original_tagname_ = 'SystemPerformanceRatio'
# end class AirCleanerType


class MechanicalVentilationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VentilationRate=None, RequiredVentilationRate=None, VentilationType=None, DemandControlVentilation=None, VentilationControlMethod=None, VentilationZoneControl=None, MakeupAirSourceID=None, Capacity=None, CapacityUnits=None, DutyCycle=None, SystemPerformanceRatio=None, ThirdPartyCertification=None):
        self.original_tagname_ = None
        self.VentilationRate = VentilationRate
        self.RequiredVentilationRate = RequiredVentilationRate
        self.VentilationType = VentilationType
        self.validate_VentilationTypeType(self.VentilationType)
        self.DemandControlVentilation = DemandControlVentilation
        self.VentilationControlMethod = VentilationControlMethod
        self.validate_VentilationControlMethod(self.VentilationControlMethod)
        self.VentilationZoneControl = VentilationZoneControl
        self.validate_VentilationZoneControlType(self.VentilationZoneControl)
        self.MakeupAirSourceID = MakeupAirSourceID
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
        self.SystemPerformanceRatio = SystemPerformanceRatio
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MechanicalVentilationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MechanicalVentilationType.subclass:
            return MechanicalVentilationType.subclass(*args_, **kwargs_)
        else:
            return MechanicalVentilationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_VentilationTypeType(self, value):
        # Validate type VentilationTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Exhaust only', 'Supply only', 'Dedicated outdoor air system', 'Heat recovery ventilator', 'Energy recovery ventilator', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VentilationTypeType' % {"value" : value.encode("utf-8")} )
    def validate_VentilationControlMethod(self, value):
        # Validate type VentilationControlMethod, a restriction on xs:string.
        pass
    def validate_VentilationZoneControlType(self, value):
        # Validate type VentilationZoneControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Average Flow', 'Critical Zone', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VentilationZoneControlType' % {"value" : value.encode("utf-8")} )
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.VentilationRate is not None or
            self.RequiredVentilationRate is not None or
            self.VentilationType is not None or
            self.DemandControlVentilation is not None or
            self.VentilationControlMethod is not None or
            self.VentilationZoneControl is not None or
            self.MakeupAirSourceID is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None or
            self.SystemPerformanceRatio is not None or
            self.ThirdPartyCertification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MechanicalVentilationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MechanicalVentilationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MechanicalVentilationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MechanicalVentilationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MechanicalVentilationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VentilationRate is not None:
            self.VentilationRate.export(outfile, level, namespace_, name_='VentilationRate', pretty_print=pretty_print)
        if self.RequiredVentilationRate is not None:
            self.RequiredVentilationRate.export(outfile, level, namespace_, name_='RequiredVentilationRate', pretty_print=pretty_print)
        if self.VentilationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVentilationType>%s</%sVentilationType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VentilationType), input_name='VentilationType')), namespace_, eol_))
        if self.DemandControlVentilation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDemandControlVentilation>%s</%sDemandControlVentilation>%s' % (namespace_, self.gds_format_boolean(self.DemandControlVentilation, input_name='DemandControlVentilation'), namespace_, eol_))
        if self.VentilationControlMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVentilationControlMethod>%s</%sVentilationControlMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VentilationControlMethod), input_name='VentilationControlMethod')), namespace_, eol_))
        if self.VentilationZoneControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVentilationZoneControl>%s</%sVentilationZoneControl>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VentilationZoneControl), input_name='VentilationZoneControl')), namespace_, eol_))
        if self.MakeupAirSourceID is not None:
            self.MakeupAirSourceID.export(outfile, level, namespace_, name_='MakeupAirSourceID', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
        if self.SystemPerformanceRatio is not None:
            self.SystemPerformanceRatio.export(outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VentilationRate':
            obj_ = VentilationRateType.factory()
            obj_.build(child_)
            self.VentilationRate = obj_
            obj_.original_tagname_ = 'VentilationRate'
        elif nodeName_ == 'RequiredVentilationRate':
            obj_ = RequiredVentilationRateType.factory()
            obj_.build(child_)
            self.RequiredVentilationRate = obj_
            obj_.original_tagname_ = 'RequiredVentilationRate'
        elif nodeName_ == 'VentilationType':
            VentilationType_ = child_.text
            VentilationType_ = self.gds_validate_string(VentilationType_, node, 'VentilationType')
            self.VentilationType = VentilationType_
            # validate type VentilationTypeType
            self.validate_VentilationTypeType(self.VentilationType)
        elif nodeName_ == 'DemandControlVentilation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DemandControlVentilation')
            self.DemandControlVentilation = ival_
        elif nodeName_ == 'VentilationControlMethod':
            VentilationControlMethod_ = child_.text
            VentilationControlMethod_ = self.gds_validate_string(VentilationControlMethod_, node, 'VentilationControlMethod')
            self.VentilationControlMethod = VentilationControlMethod_
            # validate type VentilationControlMethod
            self.validate_VentilationControlMethod(self.VentilationControlMethod)
        elif nodeName_ == 'VentilationZoneControl':
            VentilationZoneControl_ = child_.text
            VentilationZoneControl_ = self.gds_validate_string(VentilationZoneControl_, node, 'VentilationZoneControl')
            self.VentilationZoneControl = VentilationZoneControl_
            # validate type VentilationZoneControlType
            self.validate_VentilationZoneControlType(self.VentilationZoneControl)
        elif nodeName_ == 'MakeupAirSourceID':
            obj_ = MakeupAirSourceIDType.factory()
            obj_.build(child_)
            self.MakeupAirSourceID = obj_
            obj_.original_tagname_ = 'MakeupAirSourceID'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'SystemPerformanceRatio':
            obj_ = SystemPerformanceRatio.factory()
            obj_.build(child_)
            self.SystemPerformanceRatio = obj_
            obj_.original_tagname_ = 'SystemPerformanceRatio'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
# end class MechanicalVentilationType


class VentilationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VentilationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VentilationRateType.subclass:
            return VentilationRateType.subclass(*args_, **kwargs_)
        else:
            return VentilationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VentilationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VentilationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VentilationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VentilationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VentilationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VentilationRateType


class RequiredVentilationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequiredVentilationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequiredVentilationRateType.subclass:
            return RequiredVentilationRateType.subclass(*args_, **kwargs_)
        else:
            return RequiredVentilationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RequiredVentilationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequiredVentilationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RequiredVentilationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RequiredVentilationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RequiredVentilationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequiredVentilationRateType


class MakeupAirSourceIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, valueOf_=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MakeupAirSourceIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MakeupAirSourceIDType.subclass:
            return MakeupAirSourceIDType.subclass(*args_, **kwargs_)
        else:
            return MakeupAirSourceIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MakeupAirSourceIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MakeupAirSourceIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MakeupAirSourceIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MakeupAirSourceIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MakeupAirSourceIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MakeupAirSourceIDType


class SpotExhaustType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExhaustLocation=None, VentilationRate=None, RequiredVentilationRate=None, VentilationControlMethod=None, MakeupAirSourceID=None, Capacity=None, CapacityUnits=None, DutyCycle=None, SystemPerformanceRatio=None, ThirdPartyCertification=None):
        self.original_tagname_ = None
        self.ExhaustLocation = ExhaustLocation
        self.validate_ExhaustLocationType(self.ExhaustLocation)
        self.VentilationRate = VentilationRate
        self.RequiredVentilationRate = RequiredVentilationRate
        self.VentilationControlMethod = VentilationControlMethod
        self.validate_VentilationControlMethod(self.VentilationControlMethod)
        self.MakeupAirSourceID = MakeupAirSourceID
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
        self.SystemPerformanceRatio = SystemPerformanceRatio
        self.ThirdPartyCertification = ThirdPartyCertification
        self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpotExhaustType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpotExhaustType.subclass:
            return SpotExhaustType.subclass(*args_, **kwargs_)
        else:
            return SpotExhaustType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ExhaustLocationType(self, value):
        # Validate type ExhaustLocationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Bathroom', 'Kitchen hood', 'Laboratory hood', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExhaustLocationType' % {"value" : value.encode("utf-8")} )
    def validate_VentilationControlMethod(self, value):
        # Validate type VentilationControlMethod, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def validate_ThirdPartyCertification(self, value):
        # Validate type ThirdPartyCertification, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ExhaustLocation is not None or
            self.VentilationRate is not None or
            self.RequiredVentilationRate is not None or
            self.VentilationControlMethod is not None or
            self.MakeupAirSourceID is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None or
            self.SystemPerformanceRatio is not None or
            self.ThirdPartyCertification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpotExhaustType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpotExhaustType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpotExhaustType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpotExhaustType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpotExhaustType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExhaustLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExhaustLocation>%s</%sExhaustLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExhaustLocation), input_name='ExhaustLocation')), namespace_, eol_))
        if self.VentilationRate is not None:
            self.VentilationRate.export(outfile, level, namespace_, name_='VentilationRate', pretty_print=pretty_print)
        if self.RequiredVentilationRate is not None:
            self.RequiredVentilationRate.export(outfile, level, namespace_, name_='RequiredVentilationRate', pretty_print=pretty_print)
        if self.VentilationControlMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVentilationControlMethod>%s</%sVentilationControlMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VentilationControlMethod), input_name='VentilationControlMethod')), namespace_, eol_))
        if self.MakeupAirSourceID is not None:
            self.MakeupAirSourceID.export(outfile, level, namespace_, name_='MakeupAirSourceID', pretty_print=pretty_print)
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
        if self.SystemPerformanceRatio is not None:
            self.SystemPerformanceRatio.export(outfile, level, namespace_='auc:', name_='SystemPerformanceRatio', pretty_print=pretty_print)
        if self.ThirdPartyCertification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThirdPartyCertification>%s</%sThirdPartyCertification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyCertification), input_name='ThirdPartyCertification')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExhaustLocation':
            ExhaustLocation_ = child_.text
            ExhaustLocation_ = self.gds_validate_string(ExhaustLocation_, node, 'ExhaustLocation')
            self.ExhaustLocation = ExhaustLocation_
            # validate type ExhaustLocationType
            self.validate_ExhaustLocationType(self.ExhaustLocation)
        elif nodeName_ == 'VentilationRate':
            obj_ = VentilationRateType160.factory()
            obj_.build(child_)
            self.VentilationRate = obj_
            obj_.original_tagname_ = 'VentilationRate'
        elif nodeName_ == 'RequiredVentilationRate':
            obj_ = RequiredVentilationRateType161.factory()
            obj_.build(child_)
            self.RequiredVentilationRate = obj_
            obj_.original_tagname_ = 'RequiredVentilationRate'
        elif nodeName_ == 'VentilationControlMethod':
            VentilationControlMethod_ = child_.text
            VentilationControlMethod_ = self.gds_validate_string(VentilationControlMethod_, node, 'VentilationControlMethod')
            self.VentilationControlMethod = VentilationControlMethod_
            # validate type VentilationControlMethod
            self.validate_VentilationControlMethod(self.VentilationControlMethod)
        elif nodeName_ == 'MakeupAirSourceID':
            obj_ = MakeupAirSourceIDType162.factory()
            obj_.build(child_)
            self.MakeupAirSourceID = obj_
            obj_.original_tagname_ = 'MakeupAirSourceID'
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'SystemPerformanceRatio':
            obj_ = SystemPerformanceRatio.factory()
            obj_.build(child_)
            self.SystemPerformanceRatio = obj_
            obj_.original_tagname_ = 'SystemPerformanceRatio'
        elif nodeName_ == 'ThirdPartyCertification':
            ThirdPartyCertification_ = child_.text
            ThirdPartyCertification_ = self.gds_validate_string(ThirdPartyCertification_, node, 'ThirdPartyCertification')
            self.ThirdPartyCertification = ThirdPartyCertification_
            # validate type ThirdPartyCertification
            self.validate_ThirdPartyCertification(self.ThirdPartyCertification)
# end class SpotExhaustType


class VentilationRateType160(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VentilationRateType160)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VentilationRateType160.subclass:
            return VentilationRateType160.subclass(*args_, **kwargs_)
        else:
            return VentilationRateType160(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VentilationRateType160', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VentilationRateType160')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VentilationRateType160', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VentilationRateType160'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VentilationRateType160', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VentilationRateType160


class RequiredVentilationRateType161(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequiredVentilationRateType161)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequiredVentilationRateType161.subclass:
            return RequiredVentilationRateType161.subclass(*args_, **kwargs_)
        else:
            return RequiredVentilationRateType161(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RequiredVentilationRateType161', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequiredVentilationRateType161')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RequiredVentilationRateType161', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RequiredVentilationRateType161'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RequiredVentilationRateType161', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RequiredVentilationRateType161


class MakeupAirSourceIDType162(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, valueOf_=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MakeupAirSourceIDType162)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MakeupAirSourceIDType162.subclass:
            return MakeupAirSourceIDType162.subclass(*args_, **kwargs_)
        else:
            return MakeupAirSourceIDType162(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MakeupAirSourceIDType162', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MakeupAirSourceIDType162')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MakeupAirSourceIDType162', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MakeupAirSourceIDType162'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MakeupAirSourceIDType162', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MakeupAirSourceIDType162


class NaturalVentilationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NaturalVentilationRate=None, NaturalVentilationMethod=None, VentilationControlMethod=None, Capacity=None, CapacityUnits=None, DutyCycle=None):
        self.original_tagname_ = None
        self.NaturalVentilationRate = NaturalVentilationRate
        self.NaturalVentilationMethod = NaturalVentilationMethod
        self.validate_NaturalVentilationMethodType(self.NaturalVentilationMethod)
        self.VentilationControlMethod = VentilationControlMethod
        self.validate_VentilationControlMethod(self.VentilationControlMethod)
        self.Capacity = Capacity
        self.CapacityUnits = CapacityUnits
        self.validate_CapacityUnits(self.CapacityUnits)
        self.DutyCycle = DutyCycle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaturalVentilationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaturalVentilationType.subclass:
            return NaturalVentilationType.subclass(*args_, **kwargs_)
        else:
            return NaturalVentilationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_NaturalVentilationMethodType(self, value):
        # Validate type NaturalVentilationMethodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Air changes per hour', 'Flow per area', 'Flow per person', 'Flow per zone', 'Wind and stack open area', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaturalVentilationMethodType' % {"value" : value.encode("utf-8")} )
    def validate_VentilationControlMethod(self, value):
        # Validate type VentilationControlMethod, a restriction on xs:string.
        pass
    def validate_CapacityUnits(self, value):
        # Validate type CapacityUnits, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NaturalVentilationRate is not None or
            self.NaturalVentilationMethod is not None or
            self.VentilationControlMethod is not None or
            self.Capacity is not None or
            self.CapacityUnits is not None or
            self.DutyCycle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NaturalVentilationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaturalVentilationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NaturalVentilationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NaturalVentilationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NaturalVentilationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NaturalVentilationRate is not None:
            self.NaturalVentilationRate.export(outfile, level, namespace_, name_='NaturalVentilationRate', pretty_print=pretty_print)
        if self.NaturalVentilationMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNaturalVentilationMethod>%s</%sNaturalVentilationMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.NaturalVentilationMethod), input_name='NaturalVentilationMethod')), namespace_, eol_))
        if self.VentilationControlMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVentilationControlMethod>%s</%sVentilationControlMethod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.VentilationControlMethod), input_name='VentilationControlMethod')), namespace_, eol_))
        if self.Capacity is not None:
            self.Capacity.export(outfile, level, namespace_='auc:', name_='Capacity', pretty_print=pretty_print)
        if self.CapacityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapacityUnits>%s</%sCapacityUnits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CapacityUnits), input_name='CapacityUnits')), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_='auc:', name_='DutyCycle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NaturalVentilationRate':
            obj_ = NaturalVentilationRateType.factory()
            obj_.build(child_)
            self.NaturalVentilationRate = obj_
            obj_.original_tagname_ = 'NaturalVentilationRate'
        elif nodeName_ == 'NaturalVentilationMethod':
            NaturalVentilationMethod_ = child_.text
            NaturalVentilationMethod_ = self.gds_validate_string(NaturalVentilationMethod_, node, 'NaturalVentilationMethod')
            self.NaturalVentilationMethod = NaturalVentilationMethod_
            # validate type NaturalVentilationMethodType
            self.validate_NaturalVentilationMethodType(self.NaturalVentilationMethod)
        elif nodeName_ == 'VentilationControlMethod':
            VentilationControlMethod_ = child_.text
            VentilationControlMethod_ = self.gds_validate_string(VentilationControlMethod_, node, 'VentilationControlMethod')
            self.VentilationControlMethod = VentilationControlMethod_
            # validate type VentilationControlMethod
            self.validate_VentilationControlMethod(self.VentilationControlMethod)
        elif nodeName_ == 'Capacity':
            obj_ = Capacity.factory()
            obj_.build(child_)
            self.Capacity = obj_
            obj_.original_tagname_ = 'Capacity'
        elif nodeName_ == 'CapacityUnits':
            CapacityUnits_ = child_.text
            CapacityUnits_ = self.gds_validate_string(CapacityUnits_, node, 'CapacityUnits')
            self.CapacityUnits = CapacityUnits_
            # validate type CapacityUnits
            self.validate_CapacityUnits(self.CapacityUnits)
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
# end class NaturalVentilationType


class NaturalVentilationRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaturalVentilationRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaturalVentilationRateType.subclass:
            return NaturalVentilationRateType.subclass(*args_, **kwargs_)
        else:
            return NaturalVentilationRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NaturalVentilationRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaturalVentilationRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NaturalVentilationRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NaturalVentilationRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NaturalVentilationRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NaturalVentilationRateType


class LampTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Incandescent=None, LinearFluorescent=None, CompactFluorescent=None, Halogen=None, HighIntensityDischarge=None, SolidStateLighting=None, Induction=None, Neon=None, Plasma=None, Photoluminescent=None, SelfLuminous=None, OtherCombination=None, Unknown=None):
        self.original_tagname_ = None
        self.Incandescent = Incandescent
        self.LinearFluorescent = LinearFluorescent
        self.CompactFluorescent = CompactFluorescent
        self.Halogen = Halogen
        self.HighIntensityDischarge = HighIntensityDischarge
        self.SolidStateLighting = SolidStateLighting
        self.Induction = Induction
        self.Neon = Neon
        self.Plasma = Plasma
        self.Photoluminescent = Photoluminescent
        self.SelfLuminous = SelfLuminous
        self.OtherCombination = OtherCombination
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LampTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LampTypeType.subclass:
            return LampTypeType.subclass(*args_, **kwargs_)
        else:
            return LampTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Incandescent is not None or
            self.LinearFluorescent is not None or
            self.CompactFluorescent is not None or
            self.Halogen is not None or
            self.HighIntensityDischarge is not None or
            self.SolidStateLighting is not None or
            self.Induction is not None or
            self.Neon is not None or
            self.Plasma is not None or
            self.Photoluminescent is not None or
            self.SelfLuminous is not None or
            self.OtherCombination is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LampTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LampTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LampTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LampTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LampTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Incandescent is not None:
            self.Incandescent.export(outfile, level, namespace_, name_='Incandescent', pretty_print=pretty_print)
        if self.LinearFluorescent is not None:
            self.LinearFluorescent.export(outfile, level, namespace_, name_='LinearFluorescent', pretty_print=pretty_print)
        if self.CompactFluorescent is not None:
            self.CompactFluorescent.export(outfile, level, namespace_, name_='CompactFluorescent', pretty_print=pretty_print)
        if self.Halogen is not None:
            self.Halogen.export(outfile, level, namespace_, name_='Halogen', pretty_print=pretty_print)
        if self.HighIntensityDischarge is not None:
            self.HighIntensityDischarge.export(outfile, level, namespace_, name_='HighIntensityDischarge', pretty_print=pretty_print)
        if self.SolidStateLighting is not None:
            self.SolidStateLighting.export(outfile, level, namespace_, name_='SolidStateLighting', pretty_print=pretty_print)
        if self.Induction is not None:
            self.Induction.export(outfile, level, namespace_, name_='Induction', pretty_print=pretty_print)
        if self.Neon is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNeon>%s</%sNeon>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Neon), input_name='Neon')), namespace_, eol_))
        if self.Plasma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlasma>%s</%sPlasma>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Plasma), input_name='Plasma')), namespace_, eol_))
        if self.Photoluminescent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhotoluminescent>%s</%sPhotoluminescent>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Photoluminescent), input_name='Photoluminescent')), namespace_, eol_))
        if self.SelfLuminous is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSelfLuminous>%s</%sSelfLuminous>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SelfLuminous), input_name='SelfLuminous')), namespace_, eol_))
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Incandescent':
            obj_ = IncandescentType.factory()
            obj_.build(child_)
            self.Incandescent = obj_
            obj_.original_tagname_ = 'Incandescent'
        elif nodeName_ == 'LinearFluorescent':
            obj_ = LinearFluorescentType.factory()
            obj_.build(child_)
            self.LinearFluorescent = obj_
            obj_.original_tagname_ = 'LinearFluorescent'
        elif nodeName_ == 'CompactFluorescent':
            obj_ = CompactFluorescentType.factory()
            obj_.build(child_)
            self.CompactFluorescent = obj_
            obj_.original_tagname_ = 'CompactFluorescent'
        elif nodeName_ == 'Halogen':
            obj_ = HalogenType.factory()
            obj_.build(child_)
            self.Halogen = obj_
            obj_.original_tagname_ = 'Halogen'
        elif nodeName_ == 'HighIntensityDischarge':
            obj_ = HighIntensityDischargeType.factory()
            obj_.build(child_)
            self.HighIntensityDischarge = obj_
            obj_.original_tagname_ = 'HighIntensityDischarge'
        elif nodeName_ == 'SolidStateLighting':
            obj_ = SolidStateLightingType.factory()
            obj_.build(child_)
            self.SolidStateLighting = obj_
            obj_.original_tagname_ = 'SolidStateLighting'
        elif nodeName_ == 'Induction':
            obj_ = InductionType.factory()
            obj_.build(child_)
            self.Induction = obj_
            obj_.original_tagname_ = 'Induction'
        elif nodeName_ == 'Neon':
            Neon_ = child_.text
            Neon_ = self.gds_validate_string(Neon_, node, 'Neon')
            self.Neon = Neon_
        elif nodeName_ == 'Plasma':
            Plasma_ = child_.text
            Plasma_ = self.gds_validate_string(Plasma_, node, 'Plasma')
            self.Plasma = Plasma_
        elif nodeName_ == 'Photoluminescent':
            Photoluminescent_ = child_.text
            Photoluminescent_ = self.gds_validate_string(Photoluminescent_, node, 'Photoluminescent')
            self.Photoluminescent = Photoluminescent_
        elif nodeName_ == 'SelfLuminous':
            SelfLuminous_ = child_.text
            SelfLuminous_ = self.gds_validate_string(SelfLuminous_, node, 'SelfLuminous')
            self.SelfLuminous = SelfLuminous_
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class LampTypeType


class Neon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Neon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Neon.subclass:
            return Neon.subclass(*args_, **kwargs_)
        else:
            return Neon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Neon', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Neon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Neon', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Neon'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Neon', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Neon


class Plasma(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Plasma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Plasma.subclass:
            return Plasma.subclass(*args_, **kwargs_)
        else:
            return Plasma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Plasma', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Plasma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Plasma', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Plasma'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Plasma', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Plasma


class Photoluminescent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Photoluminescent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Photoluminescent.subclass:
            return Photoluminescent.subclass(*args_, **kwargs_)
        else:
            return Photoluminescent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='Photoluminescent', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Photoluminescent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='Photoluminescent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='Photoluminescent'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='Photoluminescent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Photoluminescent


class SelfLuminous(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelfLuminous)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelfLuminous.subclass:
            return SelfLuminous.subclass(*args_, **kwargs_)
        else:
            return SelfLuminous(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SelfLuminous', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelfLuminous')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SelfLuminous', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SelfLuminous'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SelfLuminous', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SelfLuminous


class IncandescentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType(self.LampLabel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IncandescentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IncandescentType.subclass:
            return IncandescentType.subclass(*args_, **kwargs_)
        else:
            return IncandescentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType(self, value):
        # Validate type LampLabelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A19', 'A21', 'G16C', 'G25M', 'G40M', 'MR16', 'PAR16', 'PAR20', 'PAR30', 'PAR38', 'PS-Series', 'R20', 'R30', 'R40', 'TC', 'TM', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LampLabel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IncandescentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncandescentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IncandescentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IncandescentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IncandescentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType
            self.validate_LampLabelType(self.LampLabel)
# end class IncandescentType


class LinearFluorescentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None, LampLength=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType163(self.LampLabel)
        self.LampLength = LampLength
        self.validate_LampLengthType(self.LampLength)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearFluorescentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearFluorescentType.subclass:
            return LinearFluorescentType.subclass(*args_, **kwargs_)
        else:
            return LinearFluorescentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType163(self, value):
        # Validate type LampLabelType163, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Super T8', 'T12', 'T5', 'T5HO', 'T8', 'T12U', 'T8U', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType163' % {"value" : value.encode("utf-8")} )
    def validate_LampLengthType(self, value):
        # Validate type LampLengthType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2 ft', '4 ft', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLengthType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LampLabel is not None or
            self.LampLength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinearFluorescentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearFluorescentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinearFluorescentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinearFluorescentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinearFluorescentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
        if self.LampLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLength>%s</%sLampLength>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLength), input_name='LampLength')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType163
            self.validate_LampLabelType163(self.LampLabel)
        elif nodeName_ == 'LampLength':
            LampLength_ = child_.text
            LampLength_ = self.gds_validate_string(LampLength_, node, 'LampLength')
            self.LampLength = LampLength_
            # validate type LampLengthType
            self.validate_LampLengthType(self.LampLength)
# end class LinearFluorescentType


class CompactFluorescentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None, FluorescentStartType=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType164(self.LampLabel)
        self.FluorescentStartType = FluorescentStartType
        self.validate_FluorescentStartType(self.FluorescentStartType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompactFluorescentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompactFluorescentType.subclass:
            return CompactFluorescentType.subclass(*args_, **kwargs_)
        else:
            return CompactFluorescentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType164(self, value):
        # Validate type LampLabelType164, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2D', 'A-series', 'Circline', 'Spiral', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType164' % {"value" : value.encode("utf-8")} )
    def validate_FluorescentStartType(self, value):
        # Validate type FluorescentStartType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.LampLabel is not None or
            self.FluorescentStartType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CompactFluorescentType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompactFluorescentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CompactFluorescentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CompactFluorescentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CompactFluorescentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
        if self.FluorescentStartType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFluorescentStartType>%s</%sFluorescentStartType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FluorescentStartType), input_name='FluorescentStartType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType164
            self.validate_LampLabelType164(self.LampLabel)
        elif nodeName_ == 'FluorescentStartType':
            FluorescentStartType_ = child_.text
            FluorescentStartType_ = self.gds_validate_string(FluorescentStartType_, node, 'FluorescentStartType')
            self.FluorescentStartType = FluorescentStartType_
            # validate type FluorescentStartType
            self.validate_FluorescentStartType(self.FluorescentStartType)
# end class CompactFluorescentType


class HalogenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None, TransformerNeeded=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType165(self.LampLabel)
        self.TransformerNeeded = TransformerNeeded
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HalogenType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HalogenType.subclass:
            return HalogenType.subclass(*args_, **kwargs_)
        else:
            return HalogenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType165(self, value):
        # Validate type LampLabelType165, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A-shape', 'BR30', 'BR40', 'MR11', 'MR16', 'MR8', 'PAR20', 'PAR30', 'PAR38', 'Pin Base', 'R20', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType165' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LampLabel is not None or
            self.TransformerNeeded is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HalogenType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HalogenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HalogenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HalogenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HalogenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
        if self.TransformerNeeded is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformerNeeded>%s</%sTransformerNeeded>%s' % (namespace_, self.gds_format_boolean(self.TransformerNeeded, input_name='TransformerNeeded'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType165
            self.validate_LampLabelType165(self.LampLabel)
        elif nodeName_ == 'TransformerNeeded':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TransformerNeeded')
            self.TransformerNeeded = ival_
# end class HalogenType


class HighIntensityDischargeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None, MetalHalideStartType=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType166(self.LampLabel)
        self.MetalHalideStartType = MetalHalideStartType
        self.validate_MetalHalideStartTypeType(self.MetalHalideStartType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HighIntensityDischargeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HighIntensityDischargeType.subclass:
            return HighIntensityDischargeType.subclass(*args_, **kwargs_)
        else:
            return HighIntensityDischargeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType166(self, value):
        # Validate type LampLabelType166, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Sodium Vapor High Pressure', 'Sodium Vapor Low Pressure', 'Metal Halide', 'Mercury Vapor', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType166' % {"value" : value.encode("utf-8")} )
    def validate_MetalHalideStartTypeType(self, value):
        # Validate type MetalHalideStartTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Probe start', 'Pulse start', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MetalHalideStartTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LampLabel is not None or
            self.MetalHalideStartType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HighIntensityDischargeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HighIntensityDischargeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HighIntensityDischargeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HighIntensityDischargeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HighIntensityDischargeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
        if self.MetalHalideStartType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetalHalideStartType>%s</%sMetalHalideStartType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.MetalHalideStartType), input_name='MetalHalideStartType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType166
            self.validate_LampLabelType166(self.LampLabel)
        elif nodeName_ == 'MetalHalideStartType':
            MetalHalideStartType_ = child_.text
            MetalHalideStartType_ = self.gds_validate_string(MetalHalideStartType_, node, 'MetalHalideStartType')
            self.MetalHalideStartType = MetalHalideStartType_
            # validate type MetalHalideStartTypeType
            self.validate_MetalHalideStartTypeType(self.MetalHalideStartType)
# end class HighIntensityDischargeType


class SolidStateLightingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LampLabel=None, TransformerNeeded=None):
        self.original_tagname_ = None
        self.LampLabel = LampLabel
        self.validate_LampLabelType167(self.LampLabel)
        self.TransformerNeeded = TransformerNeeded
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolidStateLightingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolidStateLightingType.subclass:
            return SolidStateLightingType.subclass(*args_, **kwargs_)
        else:
            return SolidStateLightingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_LampLabelType167(self, value):
        # Validate type LampLabelType167, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LED', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LampLabelType167' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LampLabel is not None or
            self.TransformerNeeded is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolidStateLightingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolidStateLightingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolidStateLightingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolidStateLightingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolidStateLightingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LampLabel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLampLabel>%s</%sLampLabel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LampLabel), input_name='LampLabel')), namespace_, eol_))
        if self.TransformerNeeded is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransformerNeeded>%s</%sTransformerNeeded>%s' % (namespace_, self.gds_format_boolean(self.TransformerNeeded, input_name='TransformerNeeded'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LampLabel':
            LampLabel_ = child_.text
            LampLabel_ = self.gds_validate_string(LampLabel_, node, 'LampLabel')
            self.LampLabel = LampLabel_
            # validate type LampLabelType167
            self.validate_LampLabelType167(self.LampLabel)
        elif nodeName_ == 'TransformerNeeded':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TransformerNeeded')
            self.TransformerNeeded = ival_
# end class SolidStateLightingType


class InductionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FluorescentStartType=None):
        self.original_tagname_ = None
        self.FluorescentStartType = FluorescentStartType
        self.validate_FluorescentStartType(self.FluorescentStartType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InductionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InductionType.subclass:
            return InductionType.subclass(*args_, **kwargs_)
        else:
            return InductionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FluorescentStartType(self, value):
        # Validate type FluorescentStartType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FluorescentStartType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InductionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InductionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InductionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InductionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InductionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FluorescentStartType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFluorescentStartType>%s</%sFluorescentStartType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FluorescentStartType), input_name='FluorescentStartType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FluorescentStartType':
            FluorescentStartType_ = child_.text
            FluorescentStartType_ = self.gds_validate_string(FluorescentStartType_, node, 'FluorescentStartType')
            self.FluorescentStartType = FluorescentStartType_
            # validate type FluorescentStartType
            self.validate_FluorescentStartType(self.FluorescentStartType)
# end class InductionType


class DimmingCapabilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimmingCapabilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimmingCapabilityType.subclass:
            return DimmingCapabilityType.subclass(*args_, **kwargs_)
        else:
            return DimmingCapabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DimmingCapabilityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimmingCapabilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DimmingCapabilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DimmingCapabilityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DimmingCapabilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType168.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class DimmingCapabilityType


class TrueType168(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MinimumDimmingLightFraction=None, MinimumDimmingPowerFraction=None):
        self.original_tagname_ = None
        self.MinimumDimmingLightFraction = MinimumDimmingLightFraction
        self.MinimumDimmingPowerFraction = MinimumDimmingPowerFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType168)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType168.subclass:
            return TrueType168.subclass(*args_, **kwargs_)
        else:
            return TrueType168(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MinimumDimmingLightFraction is not None or
            self.MinimumDimmingPowerFraction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType168', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType168')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType168', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType168'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType168', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MinimumDimmingLightFraction is not None:
            self.MinimumDimmingLightFraction.export(outfile, level, namespace_, name_='MinimumDimmingLightFraction', pretty_print=pretty_print)
        if self.MinimumDimmingPowerFraction is not None:
            self.MinimumDimmingPowerFraction.export(outfile, level, namespace_, name_='MinimumDimmingPowerFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinimumDimmingLightFraction':
            obj_ = MinimumDimmingLightFractionType.factory()
            obj_.build(child_)
            self.MinimumDimmingLightFraction = obj_
            obj_.original_tagname_ = 'MinimumDimmingLightFraction'
        elif nodeName_ == 'MinimumDimmingPowerFraction':
            obj_ = MinimumDimmingPowerFractionType.factory()
            obj_.build(child_)
            self.MinimumDimmingPowerFraction = obj_
            obj_.original_tagname_ = 'MinimumDimmingPowerFraction'
# end class TrueType168


class MinimumDimmingLightFractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumDimmingLightFractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumDimmingLightFractionType.subclass:
            return MinimumDimmingLightFractionType.subclass(*args_, **kwargs_)
        else:
            return MinimumDimmingLightFractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumDimmingLightFractionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumDimmingLightFractionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumDimmingLightFractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumDimmingLightFractionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumDimmingLightFractionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumDimmingLightFractionType


class MinimumDimmingPowerFractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumDimmingPowerFractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumDimmingPowerFractionType.subclass:
            return MinimumDimmingPowerFractionType.subclass(*args_, **kwargs_)
        else:
            return MinimumDimmingPowerFractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumDimmingPowerFractionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumDimmingPowerFractionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumDimmingPowerFractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumDimmingPowerFractionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumDimmingPowerFractionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumDimmingPowerFractionType


class DaylightingControlStepsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DaylightingControlStepsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DaylightingControlStepsType.subclass:
            return DaylightingControlStepsType.subclass(*args_, **kwargs_)
        else:
            return DaylightingControlStepsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DaylightingControlStepsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DaylightingControlStepsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DaylightingControlStepsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DaylightingControlStepsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DaylightingControlStepsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DaylightingControlStepsType


class PercentPremisesServedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentPremisesServedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentPremisesServedType.subclass:
            return PercentPremisesServedType.subclass(*args_, **kwargs_)
        else:
            return PercentPremisesServedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PercentPremisesServedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercentPremisesServedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PercentPremisesServedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PercentPremisesServedType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PercentPremisesServedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PercentPremisesServedType


class InstalledPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstalledPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstalledPowerType.subclass:
            return InstalledPowerType.subclass(*args_, **kwargs_)
        else:
            return InstalledPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InstalledPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstalledPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InstalledPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InstalledPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InstalledPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InstalledPowerType


class LampPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LampPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LampPowerType.subclass:
            return LampPowerType.subclass(*args_, **kwargs_)
        else:
            return LampPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LampPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LampPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LampPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LampPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LampPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LampPowerType


class NumberOfLampsPerLuminaireType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfLampsPerLuminaireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfLampsPerLuminaireType.subclass:
            return NumberOfLampsPerLuminaireType.subclass(*args_, **kwargs_)
        else:
            return NumberOfLampsPerLuminaireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfLampsPerLuminaireType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfLampsPerLuminaireType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfLampsPerLuminaireType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfLampsPerLuminaireType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfLampsPerLuminaireType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfLampsPerLuminaireType


class NumberOfLampsPerBallastType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfLampsPerBallastType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfLampsPerBallastType.subclass:
            return NumberOfLampsPerBallastType.subclass(*args_, **kwargs_)
        else:
            return NumberOfLampsPerBallastType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfLampsPerBallastType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfLampsPerBallastType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfLampsPerBallastType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfLampsPerBallastType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfLampsPerBallastType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfLampsPerBallastType


class NumberOfBallastsPerLuminaireType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfBallastsPerLuminaireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfBallastsPerLuminaireType.subclass:
            return NumberOfBallastsPerLuminaireType.subclass(*args_, **kwargs_)
        else:
            return NumberOfBallastsPerLuminaireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfBallastsPerLuminaireType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfBallastsPerLuminaireType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfBallastsPerLuminaireType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfBallastsPerLuminaireType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfBallastsPerLuminaireType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfBallastsPerLuminaireType


class NumberOfLuminairesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfLuminairesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfLuminairesType.subclass:
            return NumberOfLuminairesType.subclass(*args_, **kwargs_)
        else:
            return NumberOfLuminairesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfLuminairesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfLuminairesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfLuminairesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfLuminairesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfLuminairesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfLuminairesType


class LightingEfficacyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightingEfficacyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightingEfficacyType.subclass:
            return LightingEfficacyType.subclass(*args_, **kwargs_)
        else:
            return LightingEfficacyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightingEfficacyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightingEfficacyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightingEfficacyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightingEfficacyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightingEfficacyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightingEfficacyType


class WorkPlaneHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WorkPlaneHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WorkPlaneHeightType.subclass:
            return WorkPlaneHeightType.subclass(*args_, **kwargs_)
        else:
            return WorkPlaneHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WorkPlaneHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WorkPlaneHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WorkPlaneHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WorkPlaneHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WorkPlaneHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WorkPlaneHeightType


class LuminaireHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LuminaireHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LuminaireHeightType.subclass:
            return LuminaireHeightType.subclass(*args_, **kwargs_)
        else:
            return LuminaireHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LuminaireHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LuminaireHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LuminaireHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LuminaireHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LuminaireHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LuminaireHeightType


class FixtureSpacingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixtureSpacingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixtureSpacingType.subclass:
            return FixtureSpacingType.subclass(*args_, **kwargs_)
        else:
            return FixtureSpacingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FixtureSpacingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixtureSpacingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FixtureSpacingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FixtureSpacingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FixtureSpacingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FixtureSpacingType


class RatedLampLifeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatedLampLifeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatedLampLifeType.subclass:
            return RatedLampLifeType.subclass(*args_, **kwargs_)
        else:
            return RatedLampLifeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatedLampLifeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatedLampLifeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatedLampLifeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatedLampLifeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatedLampLifeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RatedLampLifeType


class DomesticHotWaterTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StorageTank=None, Instantaneous=None, HeatExchanger=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.StorageTank = StorageTank
        self.Instantaneous = Instantaneous
        self.HeatExchanger = HeatExchanger
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomesticHotWaterTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomesticHotWaterTypeType.subclass:
            return DomesticHotWaterTypeType.subclass(*args_, **kwargs_)
        else:
            return DomesticHotWaterTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.StorageTank is not None or
            self.Instantaneous is not None or
            self.HeatExchanger is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomesticHotWaterTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DomesticHotWaterTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DomesticHotWaterTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DomesticHotWaterTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageTank is not None:
            self.StorageTank.export(outfile, level, namespace_, name_='StorageTank', pretty_print=pretty_print)
        if self.Instantaneous is not None:
            self.Instantaneous.export(outfile, level, namespace_, name_='Instantaneous', pretty_print=pretty_print)
        if self.HeatExchanger is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeatExchanger>%s</%sHeatExchanger>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.HeatExchanger), input_name='HeatExchanger')), namespace_, eol_))
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageTank':
            obj_ = StorageTankType.factory()
            obj_.build(child_)
            self.StorageTank = obj_
            obj_.original_tagname_ = 'StorageTank'
        elif nodeName_ == 'Instantaneous':
            obj_ = InstantaneousType.factory()
            obj_.build(child_)
            self.Instantaneous = obj_
            obj_.original_tagname_ = 'Instantaneous'
        elif nodeName_ == 'HeatExchanger':
            HeatExchanger_ = child_.text
            HeatExchanger_ = self.gds_validate_string(HeatExchanger_, node, 'HeatExchanger')
            self.HeatExchanger = HeatExchanger_
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class DomesticHotWaterTypeType


class HeatExchanger(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatExchanger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatExchanger.subclass:
            return HeatExchanger.subclass(*args_, **kwargs_)
        else:
            return HeatExchanger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatExchanger', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatExchanger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatExchanger', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatExchanger'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatExchanger', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatExchanger


class StorageTankType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TankHeatingType=None, TankVolume=None, TankHeight=None, TankPerimeter=None, RecoveryEfficiency=None, StorageTankInsulationRValue=None, StorageTankInsulationThickness=None, OffCycleHeatLossCoefficient=None):
        self.original_tagname_ = None
        self.TankHeatingType = TankHeatingType
        self.TankVolume = TankVolume
        self.TankHeight = TankHeight
        self.TankPerimeter = TankPerimeter
        self.RecoveryEfficiency = RecoveryEfficiency
        self.StorageTankInsulationRValue = StorageTankInsulationRValue
        self.StorageTankInsulationThickness = StorageTankInsulationThickness
        self.OffCycleHeatLossCoefficient = OffCycleHeatLossCoefficient
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageTankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageTankType.subclass:
            return StorageTankType.subclass(*args_, **kwargs_)
        else:
            return StorageTankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.TankHeatingType is not None or
            self.TankVolume is not None or
            self.TankHeight is not None or
            self.TankPerimeter is not None or
            self.RecoveryEfficiency is not None or
            self.StorageTankInsulationRValue is not None or
            self.StorageTankInsulationThickness is not None or
            self.OffCycleHeatLossCoefficient is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StorageTankType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageTankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StorageTankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StorageTankType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StorageTankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TankHeatingType is not None:
            self.TankHeatingType.export(outfile, level, namespace_, name_='TankHeatingType', pretty_print=pretty_print)
        if self.TankVolume is not None:
            self.TankVolume.export(outfile, level, namespace_, name_='TankVolume', pretty_print=pretty_print)
        if self.TankHeight is not None:
            self.TankHeight.export(outfile, level, namespace_, name_='TankHeight', pretty_print=pretty_print)
        if self.TankPerimeter is not None:
            self.TankPerimeter.export(outfile, level, namespace_, name_='TankPerimeter', pretty_print=pretty_print)
        if self.RecoveryEfficiency is not None:
            self.RecoveryEfficiency.export(outfile, level, namespace_, name_='RecoveryEfficiency', pretty_print=pretty_print)
        if self.StorageTankInsulationRValue is not None:
            self.StorageTankInsulationRValue.export(outfile, level, namespace_, name_='StorageTankInsulationRValue', pretty_print=pretty_print)
        if self.StorageTankInsulationThickness is not None:
            self.StorageTankInsulationThickness.export(outfile, level, namespace_, name_='StorageTankInsulationThickness', pretty_print=pretty_print)
        if self.OffCycleHeatLossCoefficient is not None:
            self.OffCycleHeatLossCoefficient.export(outfile, level, namespace_, name_='OffCycleHeatLossCoefficient', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TankHeatingType':
            obj_ = TankHeatingTypeType.factory()
            obj_.build(child_)
            self.TankHeatingType = obj_
            obj_.original_tagname_ = 'TankHeatingType'
        elif nodeName_ == 'TankVolume':
            obj_ = TankVolumeType.factory()
            obj_.build(child_)
            self.TankVolume = obj_
            obj_.original_tagname_ = 'TankVolume'
        elif nodeName_ == 'TankHeight':
            obj_ = TankHeightType.factory()
            obj_.build(child_)
            self.TankHeight = obj_
            obj_.original_tagname_ = 'TankHeight'
        elif nodeName_ == 'TankPerimeter':
            obj_ = TankPerimeterType.factory()
            obj_.build(child_)
            self.TankPerimeter = obj_
            obj_.original_tagname_ = 'TankPerimeter'
        elif nodeName_ == 'RecoveryEfficiency':
            obj_ = RecoveryEfficiencyType.factory()
            obj_.build(child_)
            self.RecoveryEfficiency = obj_
            obj_.original_tagname_ = 'RecoveryEfficiency'
        elif nodeName_ == 'StorageTankInsulationRValue':
            obj_ = StorageTankInsulationRValueType.factory()
            obj_.build(child_)
            self.StorageTankInsulationRValue = obj_
            obj_.original_tagname_ = 'StorageTankInsulationRValue'
        elif nodeName_ == 'StorageTankInsulationThickness':
            obj_ = StorageTankInsulationThicknessType.factory()
            obj_.build(child_)
            self.StorageTankInsulationThickness = obj_
            obj_.original_tagname_ = 'StorageTankInsulationThickness'
        elif nodeName_ == 'OffCycleHeatLossCoefficient':
            obj_ = OffCycleHeatLossCoefficientType.factory()
            obj_.build(child_)
            self.OffCycleHeatLossCoefficient = obj_
            obj_.original_tagname_ = 'OffCycleHeatLossCoefficient'
# end class StorageTankType


class TankHeatingTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Direct=None, Indirect=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.Direct = Direct
        self.Indirect = Indirect
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TankHeatingTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TankHeatingTypeType.subclass:
            return TankHeatingTypeType.subclass(*args_, **kwargs_)
        else:
            return TankHeatingTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Direct is not None or
            self.Indirect is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TankHeatingTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankHeatingTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TankHeatingTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TankHeatingTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TankHeatingTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Direct is not None:
            self.Direct.export(outfile, level, namespace_, name_='Direct', pretty_print=pretty_print)
        if self.Indirect is not None:
            self.Indirect.export(outfile, level, namespace_, name_='Indirect', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Direct':
            obj_ = DirectType.factory()
            obj_.build(child_)
            self.Direct = obj_
            obj_.original_tagname_ = 'Direct'
        elif nodeName_ == 'Indirect':
            obj_ = IndirectType.factory()
            obj_.build(child_)
            self.Indirect = obj_
            obj_.original_tagname_ = 'Indirect'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class TankHeatingTypeType


class DirectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DirectTankHeatingSource=None):
        self.original_tagname_ = None
        self.DirectTankHeatingSource = DirectTankHeatingSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectType.subclass:
            return DirectType.subclass(*args_, **kwargs_)
        else:
            return DirectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.DirectTankHeatingSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DirectType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DirectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DirectType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DirectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DirectTankHeatingSource is not None:
            self.DirectTankHeatingSource.export(outfile, level, namespace_, name_='DirectTankHeatingSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DirectTankHeatingSource':
            obj_ = DirectTankHeatingSourceType.factory()
            obj_.build(child_)
            self.DirectTankHeatingSource = obj_
            obj_.original_tagname_ = 'DirectTankHeatingSource'
# end class DirectType


class DirectTankHeatingSourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ElectricResistance=None, Combustion=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.ElectricResistance = ElectricResistance
        self.Combustion = Combustion
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectTankHeatingSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectTankHeatingSourceType.subclass:
            return DirectTankHeatingSourceType.subclass(*args_, **kwargs_)
        else:
            return DirectTankHeatingSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ElectricResistance is not None or
            self.Combustion is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DirectTankHeatingSourceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectTankHeatingSourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DirectTankHeatingSourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DirectTankHeatingSourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DirectTankHeatingSourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ElectricResistance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sElectricResistance>%s</%sElectricResistance>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ElectricResistance), input_name='ElectricResistance')), namespace_, eol_))
        if self.Combustion is not None:
            self.Combustion.export(outfile, level, namespace_, name_='Combustion', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ElectricResistance':
            ElectricResistance_ = child_.text
            ElectricResistance_ = self.gds_validate_string(ElectricResistance_, node, 'ElectricResistance')
            self.ElectricResistance = ElectricResistance_
        elif nodeName_ == 'Combustion':
            obj_ = CombustionType.factory()
            obj_.build(child_)
            self.Combustion = obj_
            obj_.original_tagname_ = 'Combustion'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class DirectTankHeatingSourceType


class ElectricResistance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricResistance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricResistance.subclass:
            return ElectricResistance.subclass(*args_, **kwargs_)
        else:
            return ElectricResistance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ElectricResistance', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectricResistance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ElectricResistance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ElectricResistance'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ElectricResistance', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectricResistance


class CombustionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DraftType=None):
        self.original_tagname_ = None
        self.DraftType = DraftType
        self.validate_DraftType(self.DraftType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombustionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombustionType.subclass:
            return CombustionType.subclass(*args_, **kwargs_)
        else:
            return CombustionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DraftType(self, value):
        # Validate type DraftType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DraftType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CombustionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombustionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CombustionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CombustionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CombustionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DraftType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDraftType>%s</%sDraftType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DraftType), input_name='DraftType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DraftType':
            DraftType_ = child_.text
            DraftType_ = self.gds_validate_string(DraftType_, node, 'DraftType')
            self.DraftType = DraftType_
            # validate type DraftType
            self.validate_DraftType(self.DraftType)
# end class CombustionType


class IndirectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IndirectTankHeatingSource=None):
        self.original_tagname_ = None
        self.IndirectTankHeatingSource = IndirectTankHeatingSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndirectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndirectType.subclass:
            return IndirectType.subclass(*args_, **kwargs_)
        else:
            return IndirectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.IndirectTankHeatingSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IndirectType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndirectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IndirectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IndirectType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IndirectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IndirectTankHeatingSource is not None:
            self.IndirectTankHeatingSource.export(outfile, level, namespace_, name_='IndirectTankHeatingSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndirectTankHeatingSource':
            obj_ = IndirectTankHeatingSourceType.factory()
            obj_.build(child_)
            self.IndirectTankHeatingSource = obj_
            obj_.original_tagname_ = 'IndirectTankHeatingSource'
# end class IndirectType


class IndirectTankHeatingSourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HeatPump=None, Solar=None, SpaceHeatingSystem=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.HeatPump = HeatPump
        self.Solar = Solar
        self.SpaceHeatingSystem = SpaceHeatingSystem
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndirectTankHeatingSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndirectTankHeatingSourceType.subclass:
            return IndirectTankHeatingSourceType.subclass(*args_, **kwargs_)
        else:
            return IndirectTankHeatingSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HeatPump is not None or
            self.Solar is not None or
            self.SpaceHeatingSystem is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='IndirectTankHeatingSourceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndirectTankHeatingSourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='IndirectTankHeatingSourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='IndirectTankHeatingSourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='IndirectTankHeatingSourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeatPump is not None:
            self.HeatPump.export(outfile, level, namespace_, name_='HeatPump', pretty_print=pretty_print)
        if self.Solar is not None:
            self.Solar.export(outfile, level, namespace_, name_='Solar', pretty_print=pretty_print)
        if self.SpaceHeatingSystem is not None:
            self.SpaceHeatingSystem.export(outfile, level, namespace_, name_='SpaceHeatingSystem', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatPump':
            obj_ = HeatPumpType169.factory()
            obj_.build(child_)
            self.HeatPump = obj_
            obj_.original_tagname_ = 'HeatPump'
        elif nodeName_ == 'Solar':
            obj_ = SolarType.factory()
            obj_.build(child_)
            self.Solar = obj_
            obj_.original_tagname_ = 'Solar'
        elif nodeName_ == 'SpaceHeatingSystem':
            obj_ = SpaceHeatingSystemType.factory()
            obj_.build(child_)
            self.SpaceHeatingSystem = obj_
            obj_.original_tagname_ = 'SpaceHeatingSystem'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class IndirectTankHeatingSourceType


class HeatPumpType169(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RatedHeatPumpSensibleHeatRatio=None, HPWHMinimumAirTemperature=None, Refrigerant=None):
        self.original_tagname_ = None
        self.RatedHeatPumpSensibleHeatRatio = RatedHeatPumpSensibleHeatRatio
        self.HPWHMinimumAirTemperature = HPWHMinimumAirTemperature
        self.Refrigerant = Refrigerant
        self.validate_Refrigerant(self.Refrigerant)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatPumpType169)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatPumpType169.subclass:
            return HeatPumpType169.subclass(*args_, **kwargs_)
        else:
            return HeatPumpType169(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Refrigerant(self, value):
        # Validate type Refrigerant, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.RatedHeatPumpSensibleHeatRatio is not None or
            self.HPWHMinimumAirTemperature is not None or
            self.Refrigerant is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatPumpType169', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatPumpType169')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatPumpType169', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatPumpType169'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatPumpType169', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RatedHeatPumpSensibleHeatRatio is not None:
            self.RatedHeatPumpSensibleHeatRatio.export(outfile, level, namespace_, name_='RatedHeatPumpSensibleHeatRatio', pretty_print=pretty_print)
        if self.HPWHMinimumAirTemperature is not None:
            self.HPWHMinimumAirTemperature.export(outfile, level, namespace_, name_='HPWHMinimumAirTemperature', pretty_print=pretty_print)
        if self.Refrigerant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerant>%s</%sRefrigerant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Refrigerant), input_name='Refrigerant')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RatedHeatPumpSensibleHeatRatio':
            obj_ = RatedHeatPumpSensibleHeatRatioType.factory()
            obj_.build(child_)
            self.RatedHeatPumpSensibleHeatRatio = obj_
            obj_.original_tagname_ = 'RatedHeatPumpSensibleHeatRatio'
        elif nodeName_ == 'HPWHMinimumAirTemperature':
            obj_ = HPWHMinimumAirTemperatureType.factory()
            obj_.build(child_)
            self.HPWHMinimumAirTemperature = obj_
            obj_.original_tagname_ = 'HPWHMinimumAirTemperature'
        elif nodeName_ == 'Refrigerant':
            Refrigerant_ = child_.text
            Refrigerant_ = self.gds_validate_string(Refrigerant_, node, 'Refrigerant')
            self.Refrigerant = Refrigerant_
            # validate type Refrigerant
            self.validate_Refrigerant(self.Refrigerant)
# end class HeatPumpType169


class RatedHeatPumpSensibleHeatRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatedHeatPumpSensibleHeatRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatedHeatPumpSensibleHeatRatioType.subclass:
            return RatedHeatPumpSensibleHeatRatioType.subclass(*args_, **kwargs_)
        else:
            return RatedHeatPumpSensibleHeatRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RatedHeatPumpSensibleHeatRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RatedHeatPumpSensibleHeatRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RatedHeatPumpSensibleHeatRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RatedHeatPumpSensibleHeatRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RatedHeatPumpSensibleHeatRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RatedHeatPumpSensibleHeatRatioType


class HPWHMinimumAirTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HPWHMinimumAirTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HPWHMinimumAirTemperatureType.subclass:
            return HPWHMinimumAirTemperatureType.subclass(*args_, **kwargs_)
        else:
            return HPWHMinimumAirTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HPWHMinimumAirTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HPWHMinimumAirTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HPWHMinimumAirTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HPWHMinimumAirTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HPWHMinimumAirTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HPWHMinimumAirTemperatureType


class SolarType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SolarThermalSystemType=None, SolarThermalSystemCollectorArea=None, SolarThermalSystemCollectorLoopType=None, SolarThermalSystemCollectorType=None, SolarThermalSystemCollectorAzimuth=None, SolarThermalSystemCollectorTilt=None, SolarThermalSystemStorageVolume=None, ControlTechnology=None, Quantity=None, YearInstalled=None, YearofManufacture=None, Manufacturer=None, ModelNumber=None, Location=None):
        self.original_tagname_ = None
        self.SolarThermalSystemType = SolarThermalSystemType
        self.validate_SolarThermalSystemTypeType(self.SolarThermalSystemType)
        self.SolarThermalSystemCollectorArea = SolarThermalSystemCollectorArea
        self.SolarThermalSystemCollectorLoopType = SolarThermalSystemCollectorLoopType
        self.validate_SolarThermalSystemCollectorLoopTypeType(self.SolarThermalSystemCollectorLoopType)
        self.SolarThermalSystemCollectorType = SolarThermalSystemCollectorType
        self.validate_SolarThermalSystemCollectorTypeType(self.SolarThermalSystemCollectorType)
        self.SolarThermalSystemCollectorAzimuth = SolarThermalSystemCollectorAzimuth
        self.SolarThermalSystemCollectorTilt = SolarThermalSystemCollectorTilt
        self.SolarThermalSystemStorageVolume = SolarThermalSystemStorageVolume
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
        self.Quantity = Quantity
        self.YearInstalled = YearInstalled
        self.YearofManufacture = YearofManufacture
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
        self.Location = Location
        self.validate_Location(self.Location)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarType.subclass:
            return SolarType.subclass(*args_, **kwargs_)
        else:
            return SolarType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SolarThermalSystemTypeType(self, value):
        # Validate type SolarThermalSystemTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hot water', 'Hot water and space heating', 'Space heating', 'Hybrid system', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SolarThermalSystemTypeType' % {"value" : value.encode("utf-8")} )
    def validate_SolarThermalSystemCollectorLoopTypeType(self, value):
        # Validate type SolarThermalSystemCollectorLoopTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Air direct', 'Air indirect', 'Liquid direct', 'Liquid indirect', 'Passive thermosyphon', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SolarThermalSystemCollectorLoopTypeType' % {"value" : value.encode("utf-8")} )
    def validate_SolarThermalSystemCollectorTypeType(self, value):
        # Validate type SolarThermalSystemCollectorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Single glazing black', 'Single glazing selective', 'Double glazing black', 'Double glazing selective', 'Evacuated tube', 'Integrated collector storage', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SolarThermalSystemCollectorTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def validate_Location(self, value):
        # Validate type Location, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SolarThermalSystemType is not None or
            self.SolarThermalSystemCollectorArea is not None or
            self.SolarThermalSystemCollectorLoopType is not None or
            self.SolarThermalSystemCollectorType is not None or
            self.SolarThermalSystemCollectorAzimuth is not None or
            self.SolarThermalSystemCollectorTilt is not None or
            self.SolarThermalSystemStorageVolume is not None or
            self.ControlTechnology is not None or
            self.Quantity is not None or
            self.YearInstalled is not None or
            self.YearofManufacture is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None or
            self.Location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SolarThermalSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSolarThermalSystemType>%s</%sSolarThermalSystemType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SolarThermalSystemType), input_name='SolarThermalSystemType')), namespace_, eol_))
        if self.SolarThermalSystemCollectorArea is not None:
            self.SolarThermalSystemCollectorArea.export(outfile, level, namespace_, name_='SolarThermalSystemCollectorArea', pretty_print=pretty_print)
        if self.SolarThermalSystemCollectorLoopType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSolarThermalSystemCollectorLoopType>%s</%sSolarThermalSystemCollectorLoopType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SolarThermalSystemCollectorLoopType), input_name='SolarThermalSystemCollectorLoopType')), namespace_, eol_))
        if self.SolarThermalSystemCollectorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSolarThermalSystemCollectorType>%s</%sSolarThermalSystemCollectorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SolarThermalSystemCollectorType), input_name='SolarThermalSystemCollectorType')), namespace_, eol_))
        if self.SolarThermalSystemCollectorAzimuth is not None:
            self.SolarThermalSystemCollectorAzimuth.export(outfile, level, namespace_, name_='SolarThermalSystemCollectorAzimuth', pretty_print=pretty_print)
        if self.SolarThermalSystemCollectorTilt is not None:
            self.SolarThermalSystemCollectorTilt.export(outfile, level, namespace_, name_='SolarThermalSystemCollectorTilt', pretty_print=pretty_print)
        if self.SolarThermalSystemStorageVolume is not None:
            self.SolarThermalSystemStorageVolume.export(outfile, level, namespace_, name_='SolarThermalSystemStorageVolume', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_='auc:', name_='Quantity', pretty_print=pretty_print)
        if self.YearInstalled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearInstalled>%s</%sYearInstalled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearInstalled), input_name='YearInstalled')), namespace_, eol_))
        if self.YearofManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYearofManufacture>%s</%sYearofManufacture>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.YearofManufacture), input_name='YearofManufacture')), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SolarThermalSystemType':
            SolarThermalSystemType_ = child_.text
            SolarThermalSystemType_ = self.gds_validate_string(SolarThermalSystemType_, node, 'SolarThermalSystemType')
            self.SolarThermalSystemType = SolarThermalSystemType_
            # validate type SolarThermalSystemTypeType
            self.validate_SolarThermalSystemTypeType(self.SolarThermalSystemType)
        elif nodeName_ == 'SolarThermalSystemCollectorArea':
            obj_ = SolarThermalSystemCollectorAreaType.factory()
            obj_.build(child_)
            self.SolarThermalSystemCollectorArea = obj_
            obj_.original_tagname_ = 'SolarThermalSystemCollectorArea'
        elif nodeName_ == 'SolarThermalSystemCollectorLoopType':
            SolarThermalSystemCollectorLoopType_ = child_.text
            SolarThermalSystemCollectorLoopType_ = self.gds_validate_string(SolarThermalSystemCollectorLoopType_, node, 'SolarThermalSystemCollectorLoopType')
            self.SolarThermalSystemCollectorLoopType = SolarThermalSystemCollectorLoopType_
            # validate type SolarThermalSystemCollectorLoopTypeType
            self.validate_SolarThermalSystemCollectorLoopTypeType(self.SolarThermalSystemCollectorLoopType)
        elif nodeName_ == 'SolarThermalSystemCollectorType':
            SolarThermalSystemCollectorType_ = child_.text
            SolarThermalSystemCollectorType_ = self.gds_validate_string(SolarThermalSystemCollectorType_, node, 'SolarThermalSystemCollectorType')
            self.SolarThermalSystemCollectorType = SolarThermalSystemCollectorType_
            # validate type SolarThermalSystemCollectorTypeType
            self.validate_SolarThermalSystemCollectorTypeType(self.SolarThermalSystemCollectorType)
        elif nodeName_ == 'SolarThermalSystemCollectorAzimuth':
            obj_ = SolarThermalSystemCollectorAzimuthType.factory()
            obj_.build(child_)
            self.SolarThermalSystemCollectorAzimuth = obj_
            obj_.original_tagname_ = 'SolarThermalSystemCollectorAzimuth'
        elif nodeName_ == 'SolarThermalSystemCollectorTilt':
            obj_ = SolarThermalSystemCollectorTiltType.factory()
            obj_.build(child_)
            self.SolarThermalSystemCollectorTilt = obj_
            obj_.original_tagname_ = 'SolarThermalSystemCollectorTilt'
        elif nodeName_ == 'SolarThermalSystemStorageVolume':
            obj_ = SolarThermalSystemStorageVolumeType.factory()
            obj_.build(child_)
            self.SolarThermalSystemStorageVolume = obj_
            obj_.original_tagname_ = 'SolarThermalSystemStorageVolume'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
        elif nodeName_ == 'Quantity':
            obj_ = Quantity.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'YearInstalled':
            YearInstalled_ = child_.text
            YearInstalled_ = self.gds_validate_string(YearInstalled_, node, 'YearInstalled')
            self.YearInstalled = YearInstalled_
        elif nodeName_ == 'YearofManufacture':
            YearofManufacture_ = child_.text
            YearofManufacture_ = self.gds_validate_string(YearofManufacture_, node, 'YearofManufacture')
            self.YearofManufacture = YearofManufacture_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            # validate type Location
            self.validate_Location(self.Location)
# end class SolarType


class SolarThermalSystemCollectorAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarThermalSystemCollectorAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarThermalSystemCollectorAreaType.subclass:
            return SolarThermalSystemCollectorAreaType.subclass(*args_, **kwargs_)
        else:
            return SolarThermalSystemCollectorAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarThermalSystemCollectorAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarThermalSystemCollectorAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarThermalSystemCollectorAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolarThermalSystemCollectorAreaType


class SolarThermalSystemCollectorAzimuthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarThermalSystemCollectorAzimuthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarThermalSystemCollectorAzimuthType.subclass:
            return SolarThermalSystemCollectorAzimuthType.subclass(*args_, **kwargs_)
        else:
            return SolarThermalSystemCollectorAzimuthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorAzimuthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarThermalSystemCollectorAzimuthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarThermalSystemCollectorAzimuthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarThermalSystemCollectorAzimuthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorAzimuthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolarThermalSystemCollectorAzimuthType


class SolarThermalSystemCollectorTiltType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarThermalSystemCollectorTiltType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarThermalSystemCollectorTiltType.subclass:
            return SolarThermalSystemCollectorTiltType.subclass(*args_, **kwargs_)
        else:
            return SolarThermalSystemCollectorTiltType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorTiltType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarThermalSystemCollectorTiltType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarThermalSystemCollectorTiltType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarThermalSystemCollectorTiltType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemCollectorTiltType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolarThermalSystemCollectorTiltType


class SolarThermalSystemStorageVolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarThermalSystemStorageVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarThermalSystemStorageVolumeType.subclass:
            return SolarThermalSystemStorageVolumeType.subclass(*args_, **kwargs_)
        else:
            return SolarThermalSystemStorageVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemStorageVolumeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarThermalSystemStorageVolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarThermalSystemStorageVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarThermalSystemStorageVolumeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarThermalSystemStorageVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolarThermalSystemStorageVolumeType


class SpaceHeatingSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HeatingPlantID=None):
        self.original_tagname_ = None
        self.HeatingPlantID = HeatingPlantID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceHeatingSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceHeatingSystemType.subclass:
            return SpaceHeatingSystemType.subclass(*args_, **kwargs_)
        else:
            return SpaceHeatingSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.HeatingPlantID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceHeatingSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceHeatingSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceHeatingSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceHeatingSystemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceHeatingSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HeatingPlantID is not None:
            self.HeatingPlantID.export(outfile, level, namespace_, name_='HeatingPlantID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HeatingPlantID':
            obj_ = HeatingPlantIDType.factory()
            obj_.build(child_)
            self.HeatingPlantID = obj_
            obj_.original_tagname_ = 'HeatingPlantID'
# end class SpaceHeatingSystemType


class HeatingPlantIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingPlantIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingPlantIDType.subclass:
            return HeatingPlantIDType.subclass(*args_, **kwargs_)
        else:
            return HeatingPlantIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatingPlantIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatingPlantIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatingPlantIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatingPlantIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatingPlantIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatingPlantIDType


class TankVolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TankVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TankVolumeType.subclass:
            return TankVolumeType.subclass(*args_, **kwargs_)
        else:
            return TankVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TankVolumeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankVolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TankVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TankVolumeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TankVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TankVolumeType


class TankHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TankHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TankHeightType.subclass:
            return TankHeightType.subclass(*args_, **kwargs_)
        else:
            return TankHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TankHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TankHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TankHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TankHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TankHeightType


class TankPerimeterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TankPerimeterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TankPerimeterType.subclass:
            return TankPerimeterType.subclass(*args_, **kwargs_)
        else:
            return TankPerimeterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TankPerimeterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TankPerimeterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TankPerimeterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TankPerimeterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TankPerimeterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TankPerimeterType


class RecoveryEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecoveryEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecoveryEfficiencyType.subclass:
            return RecoveryEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return RecoveryEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecoveryEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecoveryEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecoveryEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecoveryEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecoveryEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecoveryEfficiencyType


class StorageTankInsulationRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageTankInsulationRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageTankInsulationRValueType.subclass:
            return StorageTankInsulationRValueType.subclass(*args_, **kwargs_)
        else:
            return StorageTankInsulationRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StorageTankInsulationRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageTankInsulationRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StorageTankInsulationRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StorageTankInsulationRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StorageTankInsulationRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StorageTankInsulationRValueType


class StorageTankInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageTankInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageTankInsulationThicknessType.subclass:
            return StorageTankInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return StorageTankInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StorageTankInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageTankInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StorageTankInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StorageTankInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StorageTankInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StorageTankInsulationThicknessType


class OffCycleHeatLossCoefficientType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OffCycleHeatLossCoefficientType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OffCycleHeatLossCoefficientType.subclass:
            return OffCycleHeatLossCoefficientType.subclass(*args_, **kwargs_)
        else:
            return OffCycleHeatLossCoefficientType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OffCycleHeatLossCoefficientType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OffCycleHeatLossCoefficientType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OffCycleHeatLossCoefficientType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OffCycleHeatLossCoefficientType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OffCycleHeatLossCoefficientType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OffCycleHeatLossCoefficientType


class InstantaneousType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InstantaneousWaterHeatingSource=None):
        self.original_tagname_ = None
        self.InstantaneousWaterHeatingSource = InstantaneousWaterHeatingSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstantaneousType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstantaneousType.subclass:
            return InstantaneousType.subclass(*args_, **kwargs_)
        else:
            return InstantaneousType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.InstantaneousWaterHeatingSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InstantaneousType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantaneousType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InstantaneousType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InstantaneousType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InstantaneousType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InstantaneousWaterHeatingSource is not None:
            self.InstantaneousWaterHeatingSource.export(outfile, level, namespace_, name_='InstantaneousWaterHeatingSource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InstantaneousWaterHeatingSource':
            obj_ = InstantaneousWaterHeatingSourceType.factory()
            obj_.build(child_)
            self.InstantaneousWaterHeatingSource = obj_
            obj_.original_tagname_ = 'InstantaneousWaterHeatingSource'
# end class InstantaneousType


class InstantaneousWaterHeatingSourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ElectricResistance=None, Combustion=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.ElectricResistance = ElectricResistance
        self.Combustion = Combustion
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstantaneousWaterHeatingSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstantaneousWaterHeatingSourceType.subclass:
            return InstantaneousWaterHeatingSourceType.subclass(*args_, **kwargs_)
        else:
            return InstantaneousWaterHeatingSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ElectricResistance is not None or
            self.Combustion is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InstantaneousWaterHeatingSourceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantaneousWaterHeatingSourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InstantaneousWaterHeatingSourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InstantaneousWaterHeatingSourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InstantaneousWaterHeatingSourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ElectricResistance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sElectricResistance>%s</%sElectricResistance>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ElectricResistance), input_name='ElectricResistance')), namespace_, eol_))
        if self.Combustion is not None:
            self.Combustion.export(outfile, level, namespace_, name_='Combustion', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ElectricResistance':
            ElectricResistance_ = child_.text
            ElectricResistance_ = self.gds_validate_string(ElectricResistance_, node, 'ElectricResistance')
            self.ElectricResistance = ElectricResistance_
        elif nodeName_ == 'Combustion':
            obj_ = CombustionType170.factory()
            obj_.build(child_)
            self.Combustion = obj_
            obj_.original_tagname_ = 'Combustion'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class InstantaneousWaterHeatingSourceType


class CombustionType170(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DraftType=None):
        self.original_tagname_ = None
        self.DraftType = DraftType
        self.validate_DraftType(self.DraftType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombustionType170)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombustionType170.subclass:
            return CombustionType170.subclass(*args_, **kwargs_)
        else:
            return CombustionType170(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DraftType(self, value):
        # Validate type DraftType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DraftType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CombustionType170', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombustionType170')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CombustionType170', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CombustionType170'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CombustionType170', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DraftType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDraftType>%s</%sDraftType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DraftType), input_name='DraftType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DraftType':
            DraftType_ = child_.text
            DraftType_ = self.gds_validate_string(DraftType_, node, 'DraftType')
            self.DraftType = DraftType_
            # validate type DraftType
            self.validate_DraftType(self.DraftType)
# end class CombustionType170


class RecirculationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecirculationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecirculationType.subclass:
            return RecirculationType.subclass(*args_, **kwargs_)
        else:
            return RecirculationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecirculationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecirculationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecirculationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecirculationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecirculationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType171.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class RecirculationType


class TrueType171(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RecirculationLoopCount=None, RecirculationFlowRate=None, RecirculationControlType=None, PipeInsulationThickness=None, PipeLocation=None, RecirculationEnergyLossRate=None):
        self.original_tagname_ = None
        self.RecirculationLoopCount = RecirculationLoopCount
        self.RecirculationFlowRate = RecirculationFlowRate
        self.RecirculationControlType = RecirculationControlType
        self.validate_RecirculationControlTypeType(self.RecirculationControlType)
        self.PipeInsulationThickness = PipeInsulationThickness
        self.PipeLocation = PipeLocation
        self.RecirculationEnergyLossRate = RecirculationEnergyLossRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType171)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType171.subclass:
            return TrueType171.subclass(*args_, **kwargs_)
        else:
            return TrueType171(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RecirculationControlTypeType(self, value):
        # Validate type RecirculationControlTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Continuous', 'Temperature', 'Timer', 'Demand', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecirculationControlTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RecirculationLoopCount is not None or
            self.RecirculationFlowRate is not None or
            self.RecirculationControlType is not None or
            self.PipeInsulationThickness is not None or
            self.PipeLocation is not None or
            self.RecirculationEnergyLossRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType171', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType171')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType171', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType171'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType171', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RecirculationLoopCount is not None:
            self.RecirculationLoopCount.export(outfile, level, namespace_, name_='RecirculationLoopCount', pretty_print=pretty_print)
        if self.RecirculationFlowRate is not None:
            self.RecirculationFlowRate.export(outfile, level, namespace_, name_='RecirculationFlowRate', pretty_print=pretty_print)
        if self.RecirculationControlType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecirculationControlType>%s</%sRecirculationControlType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RecirculationControlType), input_name='RecirculationControlType')), namespace_, eol_))
        if self.PipeInsulationThickness is not None:
            self.PipeInsulationThickness.export(outfile, level, namespace_, name_='PipeInsulationThickness', pretty_print=pretty_print)
        if self.PipeLocation is not None:
            self.PipeLocation.export(outfile, level, namespace_, name_='PipeLocation', pretty_print=pretty_print)
        if self.RecirculationEnergyLossRate is not None:
            self.RecirculationEnergyLossRate.export(outfile, level, namespace_, name_='RecirculationEnergyLossRate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecirculationLoopCount':
            obj_ = RecirculationLoopCountType.factory()
            obj_.build(child_)
            self.RecirculationLoopCount = obj_
            obj_.original_tagname_ = 'RecirculationLoopCount'
        elif nodeName_ == 'RecirculationFlowRate':
            obj_ = RecirculationFlowRateType.factory()
            obj_.build(child_)
            self.RecirculationFlowRate = obj_
            obj_.original_tagname_ = 'RecirculationFlowRate'
        elif nodeName_ == 'RecirculationControlType':
            RecirculationControlType_ = child_.text
            RecirculationControlType_ = self.gds_validate_string(RecirculationControlType_, node, 'RecirculationControlType')
            self.RecirculationControlType = RecirculationControlType_
            # validate type RecirculationControlTypeType
            self.validate_RecirculationControlTypeType(self.RecirculationControlType)
        elif nodeName_ == 'PipeInsulationThickness':
            obj_ = PipeInsulationThicknessType172.factory()
            obj_.build(child_)
            self.PipeInsulationThickness = obj_
            obj_.original_tagname_ = 'PipeInsulationThickness'
        elif nodeName_ == 'PipeLocation':
            obj_ = PipeLocationType173.factory()
            obj_.build(child_)
            self.PipeLocation = obj_
            obj_.original_tagname_ = 'PipeLocation'
        elif nodeName_ == 'RecirculationEnergyLossRate':
            obj_ = RecirculationEnergyLossRateType.factory()
            obj_.build(child_)
            self.RecirculationEnergyLossRate = obj_
            obj_.original_tagname_ = 'RecirculationEnergyLossRate'
# end class TrueType171


class RecirculationLoopCountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecirculationLoopCountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecirculationLoopCountType.subclass:
            return RecirculationLoopCountType.subclass(*args_, **kwargs_)
        else:
            return RecirculationLoopCountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecirculationLoopCountType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecirculationLoopCountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecirculationLoopCountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecirculationLoopCountType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecirculationLoopCountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecirculationLoopCountType


class RecirculationFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecirculationFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecirculationFlowRateType.subclass:
            return RecirculationFlowRateType.subclass(*args_, **kwargs_)
        else:
            return RecirculationFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecirculationFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecirculationFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecirculationFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecirculationFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecirculationFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecirculationFlowRateType


class PipeInsulationThicknessType172(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeInsulationThicknessType172)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeInsulationThicknessType172.subclass:
            return PipeInsulationThicknessType172.subclass(*args_, **kwargs_)
        else:
            return PipeInsulationThicknessType172(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType172', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeInsulationThicknessType172')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeInsulationThicknessType172', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeInsulationThicknessType172'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeInsulationThicknessType172', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeInsulationThicknessType172


class PipeLocationType173(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipeLocationType173)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipeLocationType173.subclass:
            return PipeLocationType173.subclass(*args_, **kwargs_)
        else:
            return PipeLocationType173(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PipeLocationType173', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipeLocationType173')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PipeLocationType173', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PipeLocationType173'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PipeLocationType173', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PipeLocationType173


class RecirculationEnergyLossRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecirculationEnergyLossRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecirculationEnergyLossRateType.subclass:
            return RecirculationEnergyLossRateType.subclass(*args_, **kwargs_)
        else:
            return RecirculationEnergyLossRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RecirculationEnergyLossRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecirculationEnergyLossRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RecirculationEnergyLossRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RecirculationEnergyLossRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RecirculationEnergyLossRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecirculationEnergyLossRateType


class WaterHeaterEfficiencyType174(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterHeaterEfficiencyType174)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterHeaterEfficiencyType174.subclass:
            return WaterHeaterEfficiencyType174.subclass(*args_, **kwargs_)
        else:
            return WaterHeaterEfficiencyType174(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterHeaterEfficiencyType174', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterHeaterEfficiencyType174')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterHeaterEfficiencyType174', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterHeaterEfficiencyType174'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterHeaterEfficiencyType174', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterHeaterEfficiencyType174


class DailyHotWaterDrawType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DailyHotWaterDrawType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DailyHotWaterDrawType.subclass:
            return DailyHotWaterDrawType.subclass(*args_, **kwargs_)
        else:
            return DailyHotWaterDrawType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DailyHotWaterDrawType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DailyHotWaterDrawType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DailyHotWaterDrawType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DailyHotWaterDrawType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DailyHotWaterDrawType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DailyHotWaterDrawType


class HotWaterSetpointTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HotWaterSetpointTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HotWaterSetpointTemperatureType.subclass:
            return HotWaterSetpointTemperatureType.subclass(*args_, **kwargs_)
        else:
            return HotWaterSetpointTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HotWaterSetpointTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HotWaterSetpointTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HotWaterSetpointTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HotWaterSetpointTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HotWaterSetpointTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HotWaterSetpointTemperatureType


class ParasiticFuelConsumptionRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParasiticFuelConsumptionRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParasiticFuelConsumptionRateType.subclass:
            return ParasiticFuelConsumptionRateType.subclass(*args_, **kwargs_)
        else:
            return ParasiticFuelConsumptionRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ParasiticFuelConsumptionRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParasiticFuelConsumptionRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ParasiticFuelConsumptionRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ParasiticFuelConsumptionRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ParasiticFuelConsumptionRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParasiticFuelConsumptionRateType


class NumberOfMealsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfMealsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfMealsType.subclass:
            return NumberOfMealsType.subclass(*args_, **kwargs_)
        else:
            return NumberOfMealsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfMealsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfMealsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfMealsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfMealsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfMealsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfMealsType


class CookingEnergyPerMealType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CookingEnergyPerMealType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CookingEnergyPerMealType.subclass:
            return CookingEnergyPerMealType.subclass(*args_, **kwargs_)
        else:
            return CookingEnergyPerMealType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CookingEnergyPerMealType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CookingEnergyPerMealType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CookingEnergyPerMealType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CookingEnergyPerMealType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CookingEnergyPerMealType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CookingEnergyPerMealType


class DailyWaterUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DailyWaterUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DailyWaterUseType.subclass:
            return DailyWaterUseType.subclass(*args_, **kwargs_)
        else:
            return DailyWaterUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DailyWaterUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DailyWaterUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DailyWaterUseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DailyWaterUseType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DailyWaterUseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DailyWaterUseType


class RefrigerationSystemCategoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CentralRefrigerationSystem=None, RefrigerationUnit=None):
        self.original_tagname_ = None
        self.CentralRefrigerationSystem = CentralRefrigerationSystem
        self.RefrigerationUnit = RefrigerationUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationSystemCategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationSystemCategoryType.subclass:
            return RefrigerationSystemCategoryType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationSystemCategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CentralRefrigerationSystem is not None or
            self.RefrigerationUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemCategoryType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationSystemCategoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationSystemCategoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationSystemCategoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationSystemCategoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CentralRefrigerationSystem is not None:
            self.CentralRefrigerationSystem.export(outfile, level, namespace_, name_='CentralRefrigerationSystem', pretty_print=pretty_print)
        if self.RefrigerationUnit is not None:
            self.RefrigerationUnit.export(outfile, level, namespace_, name_='RefrigerationUnit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CentralRefrigerationSystem':
            obj_ = CentralRefrigerationSystemType.factory()
            obj_.build(child_)
            self.CentralRefrigerationSystem = obj_
            obj_.original_tagname_ = 'CentralRefrigerationSystem'
        elif nodeName_ == 'RefrigerationUnit':
            obj_ = RefrigerationUnitType178.factory()
            obj_.build(child_)
            self.RefrigerationUnit = obj_
            obj_.original_tagname_ = 'RefrigerationUnit'
# end class RefrigerationSystemCategoryType


class CentralRefrigerationSystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NetRefrigerationCapacity=None, TotalHeatRejection=None, Refrigerant=None, SuctionVaporTemperature=None, NumberOfRefrigerantReturnLines=None, EvaporatorPressureRegulators=None, RefrigerantSubcooler=None, CaseReturnLineDiameter=None, RefrigerationCompressor=None, CondenserPlantID=None):
        self.original_tagname_ = None
        self.NetRefrigerationCapacity = NetRefrigerationCapacity
        self.TotalHeatRejection = TotalHeatRejection
        self.Refrigerant = Refrigerant
        self.validate_Refrigerant(self.Refrigerant)
        self.SuctionVaporTemperature = SuctionVaporTemperature
        self.NumberOfRefrigerantReturnLines = NumberOfRefrigerantReturnLines
        self.EvaporatorPressureRegulators = EvaporatorPressureRegulators
        self.RefrigerantSubcooler = RefrigerantSubcooler
        self.CaseReturnLineDiameter = CaseReturnLineDiameter
        self.RefrigerationCompressor = RefrigerationCompressor
        if CondenserPlantID is None:
            self.CondenserPlantID = []
        else:
            self.CondenserPlantID = CondenserPlantID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CentralRefrigerationSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CentralRefrigerationSystemType.subclass:
            return CentralRefrigerationSystemType.subclass(*args_, **kwargs_)
        else:
            return CentralRefrigerationSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_Refrigerant(self, value):
        # Validate type Refrigerant, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NetRefrigerationCapacity is not None or
            self.TotalHeatRejection is not None or
            self.Refrigerant is not None or
            self.SuctionVaporTemperature is not None or
            self.NumberOfRefrigerantReturnLines is not None or
            self.EvaporatorPressureRegulators is not None or
            self.RefrigerantSubcooler is not None or
            self.CaseReturnLineDiameter is not None or
            self.RefrigerationCompressor is not None or
            self.CondenserPlantID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CentralRefrigerationSystemType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CentralRefrigerationSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CentralRefrigerationSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CentralRefrigerationSystemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CentralRefrigerationSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetRefrigerationCapacity is not None:
            self.NetRefrigerationCapacity.export(outfile, level, namespace_, name_='NetRefrigerationCapacity', pretty_print=pretty_print)
        if self.TotalHeatRejection is not None:
            self.TotalHeatRejection.export(outfile, level, namespace_, name_='TotalHeatRejection', pretty_print=pretty_print)
        if self.Refrigerant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerant>%s</%sRefrigerant>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Refrigerant), input_name='Refrigerant')), namespace_, eol_))
        if self.SuctionVaporTemperature is not None:
            self.SuctionVaporTemperature.export(outfile, level, namespace_, name_='SuctionVaporTemperature', pretty_print=pretty_print)
        if self.NumberOfRefrigerantReturnLines is not None:
            self.NumberOfRefrigerantReturnLines.export(outfile, level, namespace_, name_='NumberOfRefrigerantReturnLines', pretty_print=pretty_print)
        if self.EvaporatorPressureRegulators is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEvaporatorPressureRegulators>%s</%sEvaporatorPressureRegulators>%s' % (namespace_, self.gds_format_boolean(self.EvaporatorPressureRegulators, input_name='EvaporatorPressureRegulators'), namespace_, eol_))
        if self.RefrigerantSubcooler is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerantSubcooler>%s</%sRefrigerantSubcooler>%s' % (namespace_, self.gds_format_boolean(self.RefrigerantSubcooler, input_name='RefrigerantSubcooler'), namespace_, eol_))
        if self.CaseReturnLineDiameter is not None:
            self.CaseReturnLineDiameter.export(outfile, level, namespace_, name_='CaseReturnLineDiameter', pretty_print=pretty_print)
        if self.RefrigerationCompressor is not None:
            self.RefrigerationCompressor.export(outfile, level, namespace_, name_='RefrigerationCompressor', pretty_print=pretty_print)
        for CondenserPlantID_ in self.CondenserPlantID:
            CondenserPlantID_.export(outfile, level, namespace_, name_='CondenserPlantID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetRefrigerationCapacity':
            obj_ = NetRefrigerationCapacityType.factory()
            obj_.build(child_)
            self.NetRefrigerationCapacity = obj_
            obj_.original_tagname_ = 'NetRefrigerationCapacity'
        elif nodeName_ == 'TotalHeatRejection':
            obj_ = TotalHeatRejectionType.factory()
            obj_.build(child_)
            self.TotalHeatRejection = obj_
            obj_.original_tagname_ = 'TotalHeatRejection'
        elif nodeName_ == 'Refrigerant':
            Refrigerant_ = child_.text
            Refrigerant_ = self.gds_validate_string(Refrigerant_, node, 'Refrigerant')
            self.Refrigerant = Refrigerant_
            # validate type Refrigerant
            self.validate_Refrigerant(self.Refrigerant)
        elif nodeName_ == 'SuctionVaporTemperature':
            obj_ = SuctionVaporTemperatureType.factory()
            obj_.build(child_)
            self.SuctionVaporTemperature = obj_
            obj_.original_tagname_ = 'SuctionVaporTemperature'
        elif nodeName_ == 'NumberOfRefrigerantReturnLines':
            obj_ = NumberOfRefrigerantReturnLinesType.factory()
            obj_.build(child_)
            self.NumberOfRefrigerantReturnLines = obj_
            obj_.original_tagname_ = 'NumberOfRefrigerantReturnLines'
        elif nodeName_ == 'EvaporatorPressureRegulators':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EvaporatorPressureRegulators')
            self.EvaporatorPressureRegulators = ival_
        elif nodeName_ == 'RefrigerantSubcooler':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RefrigerantSubcooler')
            self.RefrigerantSubcooler = ival_
        elif nodeName_ == 'CaseReturnLineDiameter':
            obj_ = CaseReturnLineDiameterType.factory()
            obj_.build(child_)
            self.CaseReturnLineDiameter = obj_
            obj_.original_tagname_ = 'CaseReturnLineDiameter'
        elif nodeName_ == 'RefrigerationCompressor':
            obj_ = RefrigerationCompressorType175.factory()
            obj_.build(child_)
            self.RefrigerationCompressor = obj_
            obj_.original_tagname_ = 'RefrigerationCompressor'
        elif nodeName_ == 'CondenserPlantID':
            obj_ = CondenserPlantIDType177.factory()
            obj_.build(child_)
            self.CondenserPlantID.append(obj_)
            obj_.original_tagname_ = 'CondenserPlantID'
# end class CentralRefrigerationSystemType


class NetRefrigerationCapacityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetRefrigerationCapacityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetRefrigerationCapacityType.subclass:
            return NetRefrigerationCapacityType.subclass(*args_, **kwargs_)
        else:
            return NetRefrigerationCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NetRefrigerationCapacityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetRefrigerationCapacityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NetRefrigerationCapacityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NetRefrigerationCapacityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NetRefrigerationCapacityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NetRefrigerationCapacityType


class TotalHeatRejectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TotalHeatRejectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TotalHeatRejectionType.subclass:
            return TotalHeatRejectionType.subclass(*args_, **kwargs_)
        else:
            return TotalHeatRejectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TotalHeatRejectionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TotalHeatRejectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TotalHeatRejectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TotalHeatRejectionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TotalHeatRejectionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TotalHeatRejectionType


class SuctionVaporTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SuctionVaporTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SuctionVaporTemperatureType.subclass:
            return SuctionVaporTemperatureType.subclass(*args_, **kwargs_)
        else:
            return SuctionVaporTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SuctionVaporTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SuctionVaporTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SuctionVaporTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SuctionVaporTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SuctionVaporTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SuctionVaporTemperatureType


class NumberOfRefrigerantReturnLinesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfRefrigerantReturnLinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfRefrigerantReturnLinesType.subclass:
            return NumberOfRefrigerantReturnLinesType.subclass(*args_, **kwargs_)
        else:
            return NumberOfRefrigerantReturnLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfRefrigerantReturnLinesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfRefrigerantReturnLinesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfRefrigerantReturnLinesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfRefrigerantReturnLinesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfRefrigerantReturnLinesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfRefrigerantReturnLinesType


class CaseReturnLineDiameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CaseReturnLineDiameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CaseReturnLineDiameterType.subclass:
            return CaseReturnLineDiameterType.subclass(*args_, **kwargs_)
        else:
            return CaseReturnLineDiameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CaseReturnLineDiameterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CaseReturnLineDiameterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CaseReturnLineDiameterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CaseReturnLineDiameterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CaseReturnLineDiameterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CaseReturnLineDiameterType


class RefrigerationCompressorType175(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RefrigerationCompressorType=None, CompressorUnloader=None, DesuperheatValve=None, CrankcaseHeater=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.RefrigerationCompressorType = RefrigerationCompressorType
        self.validate_RefrigerationCompressorTypeType(self.RefrigerationCompressorType)
        self.CompressorUnloader = CompressorUnloader
        self.DesuperheatValve = DesuperheatValve
        self.CrankcaseHeater = CrankcaseHeater
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationCompressorType175)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationCompressorType175.subclass:
            return RefrigerationCompressorType175.subclass(*args_, **kwargs_)
        else:
            return RefrigerationCompressorType175(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RefrigerationCompressorTypeType(self, value):
        # Validate type RefrigerationCompressorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Reciprocating', 'Screw', 'Scroll', 'Centrifugal', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RefrigerationCompressorTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RefrigerationCompressorType is not None or
            self.CompressorUnloader is not None or
            self.DesuperheatValve is not None or
            self.CrankcaseHeater is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationCompressorType175', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationCompressorType175')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationCompressorType175', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationCompressorType175'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ID), input_name='ID')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationCompressorType175', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RefrigerationCompressorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerationCompressorType>%s</%sRefrigerationCompressorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RefrigerationCompressorType), input_name='RefrigerationCompressorType')), namespace_, eol_))
        if self.CompressorUnloader is not None:
            self.CompressorUnloader.export(outfile, level, namespace_, name_='CompressorUnloader', pretty_print=pretty_print)
        if self.DesuperheatValve is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDesuperheatValve>%s</%sDesuperheatValve>%s' % (namespace_, self.gds_format_boolean(self.DesuperheatValve, input_name='DesuperheatValve'), namespace_, eol_))
        if self.CrankcaseHeater is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCrankcaseHeater>%s</%sCrankcaseHeater>%s' % (namespace_, self.gds_format_boolean(self.CrankcaseHeater, input_name='CrankcaseHeater'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RefrigerationCompressorType':
            RefrigerationCompressorType_ = child_.text
            RefrigerationCompressorType_ = self.gds_validate_string(RefrigerationCompressorType_, node, 'RefrigerationCompressorType')
            self.RefrigerationCompressorType = RefrigerationCompressorType_
            # validate type RefrigerationCompressorTypeType
            self.validate_RefrigerationCompressorTypeType(self.RefrigerationCompressorType)
        elif nodeName_ == 'CompressorUnloader':
            obj_ = CompressorUnloaderType.factory()
            obj_.build(child_)
            self.CompressorUnloader = obj_
            obj_.original_tagname_ = 'CompressorUnloader'
        elif nodeName_ == 'DesuperheatValve':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DesuperheatValve')
            self.DesuperheatValve = ival_
        elif nodeName_ == 'CrankcaseHeater':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CrankcaseHeater')
            self.CrankcaseHeater = ival_
# end class RefrigerationCompressorType175


class CompressorUnloaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompressorUnloaderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompressorUnloaderType.subclass:
            return CompressorUnloaderType.subclass(*args_, **kwargs_)
        else:
            return CompressorUnloaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CompressorUnloaderType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompressorUnloaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CompressorUnloaderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CompressorUnloaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CompressorUnloaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType176.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class CompressorUnloaderType


class TrueType176(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompressorUnloaderStages=None):
        self.original_tagname_ = None
        self.CompressorUnloaderStages = CompressorUnloaderStages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType176)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType176.subclass:
            return TrueType176.subclass(*args_, **kwargs_)
        else:
            return TrueType176(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CompressorUnloaderStages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType176', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType176')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType176', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType176'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType176', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompressorUnloaderStages is not None:
            self.CompressorUnloaderStages.export(outfile, level, namespace_, name_='CompressorUnloaderStages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompressorUnloaderStages':
            obj_ = CompressorUnloaderStagesType.factory()
            obj_.build(child_)
            self.CompressorUnloaderStages = obj_
            obj_.original_tagname_ = 'CompressorUnloaderStages'
# end class TrueType176


class CompressorUnloaderStagesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompressorUnloaderStagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompressorUnloaderStagesType.subclass:
            return CompressorUnloaderStagesType.subclass(*args_, **kwargs_)
        else:
            return CompressorUnloaderStagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CompressorUnloaderStagesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompressorUnloaderStagesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CompressorUnloaderStagesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CompressorUnloaderStagesType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CompressorUnloaderStagesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompressorUnloaderStagesType


class CondenserPlantIDType177(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CondenserPlantIDType177)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CondenserPlantIDType177.subclass:
            return CondenserPlantIDType177.subclass(*args_, **kwargs_)
        else:
            return CondenserPlantIDType177(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType177', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CondenserPlantIDType177')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CondenserPlantIDType177', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CondenserPlantIDType177'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CondenserPlantIDType177', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CondenserPlantIDType177


class RefrigerationUnitType178(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RefrigerationUnitType=None, DoorConfiguration=None, RefrigeratedCaseDoors=None, CaseDoorOrientation=None, DefrostingType=None, LampPower=None, RefrigerationUnitSize=None, AntiSweatHeaters=None, RefrigerationEnergy=None):
        self.original_tagname_ = None
        self.RefrigerationUnitType = RefrigerationUnitType
        self.validate_RefrigerationUnitTypeType(self.RefrigerationUnitType)
        self.DoorConfiguration = DoorConfiguration
        self.validate_DoorConfigurationType(self.DoorConfiguration)
        self.RefrigeratedCaseDoors = RefrigeratedCaseDoors
        self.CaseDoorOrientation = CaseDoorOrientation
        self.validate_CaseDoorOrientationType(self.CaseDoorOrientation)
        self.DefrostingType = DefrostingType
        self.validate_DefrostingTypeType(self.DefrostingType)
        self.LampPower = LampPower
        self.RefrigerationUnitSize = RefrigerationUnitSize
        self.AntiSweatHeaters = AntiSweatHeaters
        self.RefrigerationEnergy = RefrigerationEnergy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationUnitType178)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationUnitType178.subclass:
            return RefrigerationUnitType178.subclass(*args_, **kwargs_)
        else:
            return RefrigerationUnitType178(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RefrigerationUnitTypeType(self, value):
        # Validate type RefrigerationUnitTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Refrigerator', 'Freezer', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RefrigerationUnitTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DoorConfigurationType(self, value):
        # Validate type DoorConfigurationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Side-by-side', 'Top and bottom', 'Walk-in', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DoorConfigurationType' % {"value" : value.encode("utf-8")} )
    def validate_CaseDoorOrientationType(self, value):
        # Validate type CaseDoorOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Horizontal', 'Vertical', 'Combination', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CaseDoorOrientationType' % {"value" : value.encode("utf-8")} )
    def validate_DefrostingTypeType(self, value):
        # Validate type DefrostingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electric', 'Off-cycle', 'Hot-gas', 'Reverse cycle', 'Water', 'Cool gas', 'None', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DefrostingTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RefrigerationUnitType is not None or
            self.DoorConfiguration is not None or
            self.RefrigeratedCaseDoors is not None or
            self.CaseDoorOrientation is not None or
            self.DefrostingType is not None or
            self.LampPower is not None or
            self.RefrigerationUnitSize is not None or
            self.AntiSweatHeaters is not None or
            self.RefrigerationEnergy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationUnitType178', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationUnitType178')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationUnitType178', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationUnitType178'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationUnitType178', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RefrigerationUnitType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigerationUnitType>%s</%sRefrigerationUnitType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RefrigerationUnitType), input_name='RefrigerationUnitType')), namespace_, eol_))
        if self.DoorConfiguration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDoorConfiguration>%s</%sDoorConfiguration>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DoorConfiguration), input_name='DoorConfiguration')), namespace_, eol_))
        if self.RefrigeratedCaseDoors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRefrigeratedCaseDoors>%s</%sRefrigeratedCaseDoors>%s' % (namespace_, self.gds_format_boolean(self.RefrigeratedCaseDoors, input_name='RefrigeratedCaseDoors'), namespace_, eol_))
        if self.CaseDoorOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCaseDoorOrientation>%s</%sCaseDoorOrientation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CaseDoorOrientation), input_name='CaseDoorOrientation')), namespace_, eol_))
        if self.DefrostingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefrostingType>%s</%sDefrostingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DefrostingType), input_name='DefrostingType')), namespace_, eol_))
        if self.LampPower is not None:
            self.LampPower.export(outfile, level, namespace_, name_='LampPower', pretty_print=pretty_print)
        if self.RefrigerationUnitSize is not None:
            self.RefrigerationUnitSize.export(outfile, level, namespace_, name_='RefrigerationUnitSize', pretty_print=pretty_print)
        if self.AntiSweatHeaters is not None:
            self.AntiSweatHeaters.export(outfile, level, namespace_, name_='AntiSweatHeaters', pretty_print=pretty_print)
        if self.RefrigerationEnergy is not None:
            self.RefrigerationEnergy.export(outfile, level, namespace_, name_='RefrigerationEnergy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RefrigerationUnitType':
            RefrigerationUnitType_ = child_.text
            RefrigerationUnitType_ = self.gds_validate_string(RefrigerationUnitType_, node, 'RefrigerationUnitType')
            self.RefrigerationUnitType = RefrigerationUnitType_
            # validate type RefrigerationUnitTypeType
            self.validate_RefrigerationUnitTypeType(self.RefrigerationUnitType)
        elif nodeName_ == 'DoorConfiguration':
            DoorConfiguration_ = child_.text
            DoorConfiguration_ = self.gds_validate_string(DoorConfiguration_, node, 'DoorConfiguration')
            self.DoorConfiguration = DoorConfiguration_
            # validate type DoorConfigurationType
            self.validate_DoorConfigurationType(self.DoorConfiguration)
        elif nodeName_ == 'RefrigeratedCaseDoors':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RefrigeratedCaseDoors')
            self.RefrigeratedCaseDoors = ival_
        elif nodeName_ == 'CaseDoorOrientation':
            CaseDoorOrientation_ = child_.text
            CaseDoorOrientation_ = self.gds_validate_string(CaseDoorOrientation_, node, 'CaseDoorOrientation')
            self.CaseDoorOrientation = CaseDoorOrientation_
            # validate type CaseDoorOrientationType
            self.validate_CaseDoorOrientationType(self.CaseDoorOrientation)
        elif nodeName_ == 'DefrostingType':
            DefrostingType_ = child_.text
            DefrostingType_ = self.gds_validate_string(DefrostingType_, node, 'DefrostingType')
            self.DefrostingType = DefrostingType_
            # validate type DefrostingTypeType
            self.validate_DefrostingTypeType(self.DefrostingType)
        elif nodeName_ == 'LampPower':
            obj_ = LampPowerType179.factory()
            obj_.build(child_)
            self.LampPower = obj_
            obj_.original_tagname_ = 'LampPower'
        elif nodeName_ == 'RefrigerationUnitSize':
            obj_ = RefrigerationUnitSizeType.factory()
            obj_.build(child_)
            self.RefrigerationUnitSize = obj_
            obj_.original_tagname_ = 'RefrigerationUnitSize'
        elif nodeName_ == 'AntiSweatHeaters':
            obj_ = AntiSweatHeatersType.factory()
            obj_.build(child_)
            self.AntiSweatHeaters = obj_
            obj_.original_tagname_ = 'AntiSweatHeaters'
        elif nodeName_ == 'RefrigerationEnergy':
            obj_ = RefrigerationEnergyType.factory()
            obj_.build(child_)
            self.RefrigerationEnergy = obj_
            obj_.original_tagname_ = 'RefrigerationEnergy'
# end class RefrigerationUnitType178


class LampPowerType179(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LampPowerType179)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LampPowerType179.subclass:
            return LampPowerType179.subclass(*args_, **kwargs_)
        else:
            return LampPowerType179(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LampPowerType179', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LampPowerType179')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LampPowerType179', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LampPowerType179'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LampPowerType179', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LampPowerType179


class RefrigerationUnitSizeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationUnitSizeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationUnitSizeType.subclass:
            return RefrigerationUnitSizeType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationUnitSizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationUnitSizeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationUnitSizeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationUnitSizeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationUnitSizeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationUnitSizeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RefrigerationUnitSizeType


class AntiSweatHeatersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AntiSweatHeatersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AntiSweatHeatersType.subclass:
            return AntiSweatHeatersType.subclass(*args_, **kwargs_)
        else:
            return AntiSweatHeatersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AntiSweatHeatersType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AntiSweatHeatersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AntiSweatHeatersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AntiSweatHeatersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AntiSweatHeatersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType180.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class AntiSweatHeatersType


class TrueType180(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AntiSweatHeaterPower=None, AntiSweatHeaterControls=None, Manufacturer=None, ModelNumber=None):
        self.original_tagname_ = None
        self.AntiSweatHeaterPower = AntiSweatHeaterPower
        self.AntiSweatHeaterControls = AntiSweatHeaterControls
        self.Manufacturer = Manufacturer
        self.ModelNumber = ModelNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType180)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType180.subclass:
            return TrueType180.subclass(*args_, **kwargs_)
        else:
            return TrueType180(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AntiSweatHeaterPower is not None or
            self.AntiSweatHeaterControls is not None or
            self.Manufacturer is not None or
            self.ModelNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType180', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType180')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType180', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType180'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType180', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AntiSweatHeaterPower is not None:
            self.AntiSweatHeaterPower.export(outfile, level, namespace_, name_='AntiSweatHeaterPower', pretty_print=pretty_print)
        if self.AntiSweatHeaterControls is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAntiSweatHeaterControls>%s</%sAntiSweatHeaterControls>%s' % (namespace_, self.gds_format_boolean(self.AntiSweatHeaterControls, input_name='AntiSweatHeaterControls'), namespace_, eol_))
        if self.Manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sManufacturer>%s</%sManufacturer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Manufacturer), input_name='Manufacturer')), namespace_, eol_))
        if self.ModelNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelNumber>%s</%sModelNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ModelNumber), input_name='ModelNumber')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AntiSweatHeaterPower':
            obj_ = AntiSweatHeaterPowerType.factory()
            obj_.build(child_)
            self.AntiSweatHeaterPower = obj_
            obj_.original_tagname_ = 'AntiSweatHeaterPower'
        elif nodeName_ == 'AntiSweatHeaterControls':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AntiSweatHeaterControls')
            self.AntiSweatHeaterControls = ival_
        elif nodeName_ == 'Manufacturer':
            Manufacturer_ = child_.text
            Manufacturer_ = self.gds_validate_string(Manufacturer_, node, 'Manufacturer')
            self.Manufacturer = Manufacturer_
        elif nodeName_ == 'ModelNumber':
            ModelNumber_ = child_.text
            ModelNumber_ = self.gds_validate_string(ModelNumber_, node, 'ModelNumber')
            self.ModelNumber = ModelNumber_
# end class TrueType180


class AntiSweatHeaterPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AntiSweatHeaterPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AntiSweatHeaterPowerType.subclass:
            return AntiSweatHeaterPowerType.subclass(*args_, **kwargs_)
        else:
            return AntiSweatHeaterPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='AntiSweatHeaterPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AntiSweatHeaterPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='AntiSweatHeaterPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='AntiSweatHeaterPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='AntiSweatHeaterPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AntiSweatHeaterPowerType


class RefrigerationEnergyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefrigerationEnergyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefrigerationEnergyType.subclass:
            return RefrigerationEnergyType.subclass(*args_, **kwargs_)
        else:
            return RefrigerationEnergyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RefrigerationEnergyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefrigerationEnergyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RefrigerationEnergyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RefrigerationEnergyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RefrigerationEnergyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RefrigerationEnergyType


class DishwasherLoadsPerWeekType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DishwasherLoadsPerWeekType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DishwasherLoadsPerWeekType.subclass:
            return DishwasherLoadsPerWeekType.subclass(*args_, **kwargs_)
        else:
            return DishwasherLoadsPerWeekType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DishwasherLoadsPerWeekType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DishwasherLoadsPerWeekType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DishwasherLoadsPerWeekType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DishwasherLoadsPerWeekType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DishwasherLoadsPerWeekType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DishwasherLoadsPerWeekType


class DishwasherEnergyFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DishwasherEnergyFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DishwasherEnergyFactorType.subclass:
            return DishwasherEnergyFactorType.subclass(*args_, **kwargs_)
        else:
            return DishwasherEnergyFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DishwasherEnergyFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DishwasherEnergyFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DishwasherEnergyFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DishwasherEnergyFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DishwasherEnergyFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DishwasherEnergyFactorType


class DishwasherHotWaterUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DishwasherHotWaterUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DishwasherHotWaterUseType.subclass:
            return DishwasherHotWaterUseType.subclass(*args_, **kwargs_)
        else:
            return DishwasherHotWaterUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DishwasherHotWaterUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DishwasherHotWaterUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DishwasherHotWaterUseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DishwasherHotWaterUseType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DishwasherHotWaterUseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DishwasherHotWaterUseType


class LaundryTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Washer=None, Dryer=None, Combination=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.Washer = Washer
        self.Dryer = Dryer
        self.Combination = Combination
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LaundryTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LaundryTypeType.subclass:
            return LaundryTypeType.subclass(*args_, **kwargs_)
        else:
            return LaundryTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Washer is not None or
            self.Dryer is not None or
            self.Combination is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LaundryTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LaundryTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LaundryTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LaundryTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LaundryTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Washer is not None:
            self.Washer.export(outfile, level, namespace_, name_='Washer', pretty_print=pretty_print)
        if self.Dryer is not None:
            self.Dryer.export(outfile, level, namespace_, name_='Dryer', pretty_print=pretty_print)
        if self.Combination is not None:
            self.Combination.export(outfile, level, namespace_, name_='Combination', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Washer':
            obj_ = WasherType.factory()
            obj_.build(child_)
            self.Washer = obj_
            obj_.original_tagname_ = 'Washer'
        elif nodeName_ == 'Dryer':
            obj_ = DryerType181.factory()
            obj_.build(child_)
            self.Dryer = obj_
            obj_.original_tagname_ = 'Dryer'
        elif nodeName_ == 'Combination':
            obj_ = CombinationType.factory()
            obj_.build(child_)
            self.Combination = obj_
            obj_.original_tagname_ = 'Combination'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class LaundryTypeType


class WasherType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClothesWasherClassification=None, ClothesWasherLoaderType=None, ClothesWasherModifiedEnergyFactor=None, ClothesWasherWaterFactor=None, ClothesWasherCapacity=None):
        self.original_tagname_ = None
        self.ClothesWasherClassification = ClothesWasherClassification
        self.validate_ClothesWasherClassification(self.ClothesWasherClassification)
        self.ClothesWasherLoaderType = ClothesWasherLoaderType
        self.validate_ClothesWasherLoaderType(self.ClothesWasherLoaderType)
        self.ClothesWasherModifiedEnergyFactor = ClothesWasherModifiedEnergyFactor
        self.ClothesWasherWaterFactor = ClothesWasherWaterFactor
        self.ClothesWasherCapacity = ClothesWasherCapacity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WasherType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WasherType.subclass:
            return WasherType.subclass(*args_, **kwargs_)
        else:
            return WasherType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ClothesWasherClassification(self, value):
        # Validate type ClothesWasherClassification, a restriction on xs:string.
        pass
    def validate_ClothesWasherLoaderType(self, value):
        # Validate type ClothesWasherLoaderType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ClothesWasherClassification is not None or
            self.ClothesWasherLoaderType is not None or
            self.ClothesWasherModifiedEnergyFactor is not None or
            self.ClothesWasherWaterFactor is not None or
            self.ClothesWasherCapacity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WasherType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasherType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WasherType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WasherType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WasherType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClothesWasherClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClothesWasherClassification>%s</%sClothesWasherClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClothesWasherClassification), input_name='ClothesWasherClassification')), namespace_, eol_))
        if self.ClothesWasherLoaderType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClothesWasherLoaderType>%s</%sClothesWasherLoaderType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClothesWasherLoaderType), input_name='ClothesWasherLoaderType')), namespace_, eol_))
        if self.ClothesWasherModifiedEnergyFactor is not None:
            self.ClothesWasherModifiedEnergyFactor.export(outfile, level, namespace_, name_='ClothesWasherModifiedEnergyFactor', pretty_print=pretty_print)
        if self.ClothesWasherWaterFactor is not None:
            self.ClothesWasherWaterFactor.export(outfile, level, namespace_, name_='ClothesWasherWaterFactor', pretty_print=pretty_print)
        if self.ClothesWasherCapacity is not None:
            self.ClothesWasherCapacity.export(outfile, level, namespace_, name_='ClothesWasherCapacity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClothesWasherClassification':
            ClothesWasherClassification_ = child_.text
            ClothesWasherClassification_ = self.gds_validate_string(ClothesWasherClassification_, node, 'ClothesWasherClassification')
            self.ClothesWasherClassification = ClothesWasherClassification_
            # validate type ClothesWasherClassification
            self.validate_ClothesWasherClassification(self.ClothesWasherClassification)
        elif nodeName_ == 'ClothesWasherLoaderType':
            ClothesWasherLoaderType_ = child_.text
            ClothesWasherLoaderType_ = self.gds_validate_string(ClothesWasherLoaderType_, node, 'ClothesWasherLoaderType')
            self.ClothesWasherLoaderType = ClothesWasherLoaderType_
            # validate type ClothesWasherLoaderType
            self.validate_ClothesWasherLoaderType(self.ClothesWasherLoaderType)
        elif nodeName_ == 'ClothesWasherModifiedEnergyFactor':
            obj_ = ClothesWasherModifiedEnergyFactorType.factory()
            obj_.build(child_)
            self.ClothesWasherModifiedEnergyFactor = obj_
            obj_.original_tagname_ = 'ClothesWasherModifiedEnergyFactor'
        elif nodeName_ == 'ClothesWasherWaterFactor':
            obj_ = ClothesWasherWaterFactorType.factory()
            obj_.build(child_)
            self.ClothesWasherWaterFactor = obj_
            obj_.original_tagname_ = 'ClothesWasherWaterFactor'
        elif nodeName_ == 'ClothesWasherCapacity':
            obj_ = ClothesWasherCapacityType.factory()
            obj_.build(child_)
            self.ClothesWasherCapacity = obj_
            obj_.original_tagname_ = 'ClothesWasherCapacity'
# end class WasherType


class ClothesWasherModifiedEnergyFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherModifiedEnergyFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherModifiedEnergyFactorType.subclass:
            return ClothesWasherModifiedEnergyFactorType.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherModifiedEnergyFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherModifiedEnergyFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherModifiedEnergyFactorType


class ClothesWasherWaterFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherWaterFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherWaterFactorType.subclass:
            return ClothesWasherWaterFactorType.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherWaterFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherWaterFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherWaterFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherWaterFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherWaterFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherWaterFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherWaterFactorType


class ClothesWasherCapacityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherCapacityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherCapacityType.subclass:
            return ClothesWasherCapacityType.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherCapacityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherCapacityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherCapacityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherCapacityType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherCapacityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherCapacityType


class DryerType181(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DryerType=None, DryerElectricEnergyUsePerLoad=None, DryerGasEnergyUsePerLoad=None):
        self.original_tagname_ = None
        self.DryerType = DryerType
        self.validate_DryerType(self.DryerType)
        self.DryerElectricEnergyUsePerLoad = DryerElectricEnergyUsePerLoad
        self.DryerGasEnergyUsePerLoad = DryerGasEnergyUsePerLoad
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerType181)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerType181.subclass:
            return DryerType181.subclass(*args_, **kwargs_)
        else:
            return DryerType181(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_DryerType(self, value):
        # Validate type DryerType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DryerType is not None or
            self.DryerElectricEnergyUsePerLoad is not None or
            self.DryerGasEnergyUsePerLoad is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerType181', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerType181')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerType181', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerType181'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerType181', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DryerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDryerType>%s</%sDryerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DryerType), input_name='DryerType')), namespace_, eol_))
        if self.DryerElectricEnergyUsePerLoad is not None:
            self.DryerElectricEnergyUsePerLoad.export(outfile, level, namespace_, name_='DryerElectricEnergyUsePerLoad', pretty_print=pretty_print)
        if self.DryerGasEnergyUsePerLoad is not None:
            self.DryerGasEnergyUsePerLoad.export(outfile, level, namespace_, name_='DryerGasEnergyUsePerLoad', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DryerType':
            DryerType_ = child_.text
            DryerType_ = self.gds_validate_string(DryerType_, node, 'DryerType')
            self.DryerType = DryerType_
            # validate type DryerType
            self.validate_DryerType(self.DryerType)
        elif nodeName_ == 'DryerElectricEnergyUsePerLoad':
            obj_ = DryerElectricEnergyUsePerLoadType.factory()
            obj_.build(child_)
            self.DryerElectricEnergyUsePerLoad = obj_
            obj_.original_tagname_ = 'DryerElectricEnergyUsePerLoad'
        elif nodeName_ == 'DryerGasEnergyUsePerLoad':
            obj_ = DryerGasEnergyUsePerLoadType.factory()
            obj_.build(child_)
            self.DryerGasEnergyUsePerLoad = obj_
            obj_.original_tagname_ = 'DryerGasEnergyUsePerLoad'
# end class DryerType181


class DryerElectricEnergyUsePerLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerElectricEnergyUsePerLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerElectricEnergyUsePerLoadType.subclass:
            return DryerElectricEnergyUsePerLoadType.subclass(*args_, **kwargs_)
        else:
            return DryerElectricEnergyUsePerLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerElectricEnergyUsePerLoadType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DryerElectricEnergyUsePerLoadType


class DryerGasEnergyUsePerLoadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerGasEnergyUsePerLoadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerGasEnergyUsePerLoadType.subclass:
            return DryerGasEnergyUsePerLoadType.subclass(*args_, **kwargs_)
        else:
            return DryerGasEnergyUsePerLoadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerGasEnergyUsePerLoadType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DryerGasEnergyUsePerLoadType


class CombinationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WasherDryerType=None, ClothesWasherClassification=None, ClothesWasherLoaderType=None, ClothesWasherModifiedEnergyFactor=None, ClothesWasherWaterFactor=None, ClothesWasherCapacity=None, DryerType=None, DryerElectricEnergyUsePerLoad=None, DryerGasEnergyUsePerLoad=None):
        self.original_tagname_ = None
        self.WasherDryerType = WasherDryerType
        self.validate_WasherDryerTypeType(self.WasherDryerType)
        self.ClothesWasherClassification = ClothesWasherClassification
        self.validate_ClothesWasherClassification(self.ClothesWasherClassification)
        self.ClothesWasherLoaderType = ClothesWasherLoaderType
        self.validate_ClothesWasherLoaderType(self.ClothesWasherLoaderType)
        self.ClothesWasherModifiedEnergyFactor = ClothesWasherModifiedEnergyFactor
        self.ClothesWasherWaterFactor = ClothesWasherWaterFactor
        self.ClothesWasherCapacity = ClothesWasherCapacity
        self.DryerType = DryerType
        self.validate_DryerType(self.DryerType)
        self.DryerElectricEnergyUsePerLoad = DryerElectricEnergyUsePerLoad
        self.DryerGasEnergyUsePerLoad = DryerGasEnergyUsePerLoad
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombinationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombinationType.subclass:
            return CombinationType.subclass(*args_, **kwargs_)
        else:
            return CombinationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WasherDryerTypeType(self, value):
        # Validate type WasherDryerTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Combination All-In One Clothes Washer-Dryer', 'Unitized/Stacked Washer Dryer Pair', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WasherDryerTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ClothesWasherClassification(self, value):
        # Validate type ClothesWasherClassification, a restriction on xs:string.
        pass
    def validate_ClothesWasherLoaderType(self, value):
        # Validate type ClothesWasherLoaderType, a restriction on xs:string.
        pass
    def validate_DryerType(self, value):
        # Validate type DryerType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.WasherDryerType is not None or
            self.ClothesWasherClassification is not None or
            self.ClothesWasherLoaderType is not None or
            self.ClothesWasherModifiedEnergyFactor is not None or
            self.ClothesWasherWaterFactor is not None or
            self.ClothesWasherCapacity is not None or
            self.DryerType is not None or
            self.DryerElectricEnergyUsePerLoad is not None or
            self.DryerGasEnergyUsePerLoad is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CombinationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombinationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CombinationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CombinationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CombinationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WasherDryerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWasherDryerType>%s</%sWasherDryerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WasherDryerType), input_name='WasherDryerType')), namespace_, eol_))
        if self.ClothesWasherClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClothesWasherClassification>%s</%sClothesWasherClassification>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClothesWasherClassification), input_name='ClothesWasherClassification')), namespace_, eol_))
        if self.ClothesWasherLoaderType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClothesWasherLoaderType>%s</%sClothesWasherLoaderType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ClothesWasherLoaderType), input_name='ClothesWasherLoaderType')), namespace_, eol_))
        if self.ClothesWasherModifiedEnergyFactor is not None:
            self.ClothesWasherModifiedEnergyFactor.export(outfile, level, namespace_, name_='ClothesWasherModifiedEnergyFactor', pretty_print=pretty_print)
        if self.ClothesWasherWaterFactor is not None:
            self.ClothesWasherWaterFactor.export(outfile, level, namespace_, name_='ClothesWasherWaterFactor', pretty_print=pretty_print)
        if self.ClothesWasherCapacity is not None:
            self.ClothesWasherCapacity.export(outfile, level, namespace_, name_='ClothesWasherCapacity', pretty_print=pretty_print)
        if self.DryerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDryerType>%s</%sDryerType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DryerType), input_name='DryerType')), namespace_, eol_))
        if self.DryerElectricEnergyUsePerLoad is not None:
            self.DryerElectricEnergyUsePerLoad.export(outfile, level, namespace_, name_='DryerElectricEnergyUsePerLoad', pretty_print=pretty_print)
        if self.DryerGasEnergyUsePerLoad is not None:
            self.DryerGasEnergyUsePerLoad.export(outfile, level, namespace_, name_='DryerGasEnergyUsePerLoad', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WasherDryerType':
            WasherDryerType_ = child_.text
            WasherDryerType_ = self.gds_validate_string(WasherDryerType_, node, 'WasherDryerType')
            self.WasherDryerType = WasherDryerType_
            # validate type WasherDryerTypeType
            self.validate_WasherDryerTypeType(self.WasherDryerType)
        elif nodeName_ == 'ClothesWasherClassification':
            ClothesWasherClassification_ = child_.text
            ClothesWasherClassification_ = self.gds_validate_string(ClothesWasherClassification_, node, 'ClothesWasherClassification')
            self.ClothesWasherClassification = ClothesWasherClassification_
            # validate type ClothesWasherClassification
            self.validate_ClothesWasherClassification(self.ClothesWasherClassification)
        elif nodeName_ == 'ClothesWasherLoaderType':
            ClothesWasherLoaderType_ = child_.text
            ClothesWasherLoaderType_ = self.gds_validate_string(ClothesWasherLoaderType_, node, 'ClothesWasherLoaderType')
            self.ClothesWasherLoaderType = ClothesWasherLoaderType_
            # validate type ClothesWasherLoaderType
            self.validate_ClothesWasherLoaderType(self.ClothesWasherLoaderType)
        elif nodeName_ == 'ClothesWasherModifiedEnergyFactor':
            obj_ = ClothesWasherModifiedEnergyFactorType182.factory()
            obj_.build(child_)
            self.ClothesWasherModifiedEnergyFactor = obj_
            obj_.original_tagname_ = 'ClothesWasherModifiedEnergyFactor'
        elif nodeName_ == 'ClothesWasherWaterFactor':
            obj_ = ClothesWasherWaterFactorType183.factory()
            obj_.build(child_)
            self.ClothesWasherWaterFactor = obj_
            obj_.original_tagname_ = 'ClothesWasherWaterFactor'
        elif nodeName_ == 'ClothesWasherCapacity':
            obj_ = ClothesWasherCapacityType184.factory()
            obj_.build(child_)
            self.ClothesWasherCapacity = obj_
            obj_.original_tagname_ = 'ClothesWasherCapacity'
        elif nodeName_ == 'DryerType':
            DryerType_ = child_.text
            DryerType_ = self.gds_validate_string(DryerType_, node, 'DryerType')
            self.DryerType = DryerType_
            # validate type DryerType
            self.validate_DryerType(self.DryerType)
        elif nodeName_ == 'DryerElectricEnergyUsePerLoad':
            obj_ = DryerElectricEnergyUsePerLoadType185.factory()
            obj_.build(child_)
            self.DryerElectricEnergyUsePerLoad = obj_
            obj_.original_tagname_ = 'DryerElectricEnergyUsePerLoad'
        elif nodeName_ == 'DryerGasEnergyUsePerLoad':
            obj_ = DryerGasEnergyUsePerLoadType186.factory()
            obj_.build(child_)
            self.DryerGasEnergyUsePerLoad = obj_
            obj_.original_tagname_ = 'DryerGasEnergyUsePerLoad'
# end class CombinationType


class ClothesWasherModifiedEnergyFactorType182(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherModifiedEnergyFactorType182)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherModifiedEnergyFactorType182.subclass:
            return ClothesWasherModifiedEnergyFactorType182.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherModifiedEnergyFactorType182(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType182', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherModifiedEnergyFactorType182')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType182', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType182'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherModifiedEnergyFactorType182', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherModifiedEnergyFactorType182


class ClothesWasherWaterFactorType183(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherWaterFactorType183)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherWaterFactorType183.subclass:
            return ClothesWasherWaterFactorType183.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherWaterFactorType183(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherWaterFactorType183', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherWaterFactorType183')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherWaterFactorType183', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherWaterFactorType183'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherWaterFactorType183', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherWaterFactorType183


class ClothesWasherCapacityType184(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClothesWasherCapacityType184)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClothesWasherCapacityType184.subclass:
            return ClothesWasherCapacityType184.subclass(*args_, **kwargs_)
        else:
            return ClothesWasherCapacityType184(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ClothesWasherCapacityType184', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClothesWasherCapacityType184')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ClothesWasherCapacityType184', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ClothesWasherCapacityType184'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ClothesWasherCapacityType184', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClothesWasherCapacityType184


class DryerElectricEnergyUsePerLoadType185(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerElectricEnergyUsePerLoadType185)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerElectricEnergyUsePerLoadType185.subclass:
            return DryerElectricEnergyUsePerLoadType185.subclass(*args_, **kwargs_)
        else:
            return DryerElectricEnergyUsePerLoadType185(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType185', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerElectricEnergyUsePerLoadType185')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType185', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType185'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerElectricEnergyUsePerLoadType185', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DryerElectricEnergyUsePerLoadType185


class DryerGasEnergyUsePerLoadType186(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DryerGasEnergyUsePerLoadType186)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DryerGasEnergyUsePerLoadType186.subclass:
            return DryerGasEnergyUsePerLoadType186.subclass(*args_, **kwargs_)
        else:
            return DryerGasEnergyUsePerLoadType186(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType186', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DryerGasEnergyUsePerLoadType186')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType186', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType186'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DryerGasEnergyUsePerLoadType186', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DryerGasEnergyUsePerLoadType186


class QuantityOfLaundryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityOfLaundryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityOfLaundryType.subclass:
            return QuantityOfLaundryType.subclass(*args_, **kwargs_)
        else:
            return QuantityOfLaundryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='QuantityOfLaundryType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuantityOfLaundryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='QuantityOfLaundryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='QuantityOfLaundryType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='QuantityOfLaundryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QuantityOfLaundryType


class LaundryEquipmentUsageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LaundryEquipmentUsageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LaundryEquipmentUsageType.subclass:
            return LaundryEquipmentUsageType.subclass(*args_, **kwargs_)
        else:
            return LaundryEquipmentUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LaundryEquipmentUsageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LaundryEquipmentUsageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LaundryEquipmentUsageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LaundryEquipmentUsageType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LaundryEquipmentUsageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LaundryEquipmentUsageType


class PumpEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpEfficiencyType.subclass:
            return PumpEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return PumpEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpEfficiencyType


class PumpMaximumFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpMaximumFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpMaximumFlowRateType.subclass:
            return PumpMaximumFlowRateType.subclass(*args_, **kwargs_)
        else:
            return PumpMaximumFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpMaximumFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpMaximumFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpMaximumFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpMaximumFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpMaximumFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpMaximumFlowRateType


class PumpMinimumFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpMinimumFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpMinimumFlowRateType.subclass:
            return PumpMinimumFlowRateType.subclass(*args_, **kwargs_)
        else:
            return PumpMinimumFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpMinimumFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpMinimumFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpMinimumFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpMinimumFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpMinimumFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpMinimumFlowRateType


class PumpInstalledFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpInstalledFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpInstalledFlowRateType.subclass:
            return PumpInstalledFlowRateType.subclass(*args_, **kwargs_)
        else:
            return PumpInstalledFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpInstalledFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpInstalledFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpInstalledFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpInstalledFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpInstalledFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpInstalledFlowRateType


class PumpPowerDemandType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpPowerDemandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpPowerDemandType.subclass:
            return PumpPowerDemandType.subclass(*args_, **kwargs_)
        else:
            return PumpPowerDemandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpPowerDemandType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpPowerDemandType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpPowerDemandType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpPowerDemandType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpPowerDemandType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpPowerDemandType


class LinkedSystemIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedSystemIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedSystemIDType.subclass:
            return LinkedSystemIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedSystemIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedSystemIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedSystemIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedSystemIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedSystemIDType


class FanEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanEfficiencyType.subclass:
            return FanEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return FanEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FanEfficiencyType


class FanSizeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanSizeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanSizeType.subclass:
            return FanSizeType.subclass(*args_, **kwargs_)
        else:
            return FanSizeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanSizeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanSizeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanSizeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanSizeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanSizeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FanSizeType


class InstalledFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstalledFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstalledFlowRateType.subclass:
            return InstalledFlowRateType.subclass(*args_, **kwargs_)
        else:
            return InstalledFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InstalledFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstalledFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InstalledFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InstalledFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InstalledFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InstalledFlowRateType


class MinimumFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MinimumFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MinimumFlowRateType.subclass:
            return MinimumFlowRateType.subclass(*args_, **kwargs_)
        else:
            return MinimumFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MinimumFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MinimumFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MinimumFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MinimumFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MinimumFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MinimumFlowRateType


class MaximumFanPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaximumFanPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaximumFanPowerType.subclass:
            return MaximumFanPowerType.subclass(*args_, **kwargs_)
        else:
            return MaximumFanPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MaximumFanPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaximumFanPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MaximumFanPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MaximumFanPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MaximumFanPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MaximumFanPowerType


class FanPowerMinimumRatioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FanPowerMinimumRatioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FanPowerMinimumRatioType.subclass:
            return FanPowerMinimumRatioType.subclass(*args_, **kwargs_)
        else:
            return FanPowerMinimumRatioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FanPowerMinimumRatioType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FanPowerMinimumRatioType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FanPowerMinimumRatioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FanPowerMinimumRatioType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FanPowerMinimumRatioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FanPowerMinimumRatioType


class DesignStaticPressureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DesignStaticPressureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DesignStaticPressureType.subclass:
            return DesignStaticPressureType.subclass(*args_, **kwargs_)
        else:
            return DesignStaticPressureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DesignStaticPressureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DesignStaticPressureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DesignStaticPressureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DesignStaticPressureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DesignStaticPressureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DesignStaticPressureType


class NumberOfDiscreteFanSpeedsCoolingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfDiscreteFanSpeedsCoolingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfDiscreteFanSpeedsCoolingType.subclass:
            return NumberOfDiscreteFanSpeedsCoolingType.subclass(*args_, **kwargs_)
        else:
            return NumberOfDiscreteFanSpeedsCoolingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsCoolingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDiscreteFanSpeedsCoolingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsCoolingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsCoolingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsCoolingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDiscreteFanSpeedsCoolingType


class NumberOfDiscreteFanSpeedsHeatingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfDiscreteFanSpeedsHeatingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfDiscreteFanSpeedsHeatingType.subclass:
            return NumberOfDiscreteFanSpeedsHeatingType.subclass(*args_, **kwargs_)
        else:
            return NumberOfDiscreteFanSpeedsHeatingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsHeatingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfDiscreteFanSpeedsHeatingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsHeatingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsHeatingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='NumberOfDiscreteFanSpeedsHeatingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NumberOfDiscreteFanSpeedsHeatingType


class LinkedSystemIDType187(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedSystemIDType187)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedSystemIDType187.subclass:
            return LinkedSystemIDType187.subclass(*args_, **kwargs_)
        else:
            return LinkedSystemIDType187(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType187', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedSystemIDType187')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedSystemIDType187', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedSystemIDType187'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType187', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedSystemIDType187


class MotorRPMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorRPMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorRPMType.subclass:
            return MotorRPMType.subclass(*args_, **kwargs_)
        else:
            return MotorRPMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorRPMType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorRPMType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorRPMType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorRPMType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorRPMType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MotorRPMType


class MotorBrakeHPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorBrakeHPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorBrakeHPType.subclass:
            return MotorBrakeHPType.subclass(*args_, **kwargs_)
        else:
            return MotorBrakeHPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorBrakeHPType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorBrakeHPType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorBrakeHPType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorBrakeHPType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorBrakeHPType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MotorBrakeHPType


class MotorHPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorHPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorHPType.subclass:
            return MotorHPType.subclass(*args_, **kwargs_)
        else:
            return MotorHPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorHPType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorHPType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorHPType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorHPType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorHPType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MotorHPType


class MotorEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorEfficiencyType.subclass:
            return MotorEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return MotorEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MotorEfficiencyType


class DriveEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DriveEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DriveEfficiencyType.subclass:
            return DriveEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return DriveEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DriveEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DriveEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DriveEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DriveEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DriveEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DriveEfficiencyType


class FullLoadAmpsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FullLoadAmpsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FullLoadAmpsType.subclass:
            return FullLoadAmpsType.subclass(*args_, **kwargs_)
        else:
            return FullLoadAmpsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FullLoadAmpsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FullLoadAmpsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FullLoadAmpsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FullLoadAmpsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FullLoadAmpsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FullLoadAmpsType


class MotorPoleCountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MotorPoleCountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MotorPoleCountType.subclass:
            return MotorPoleCountType.subclass(*args_, **kwargs_)
        else:
            return MotorPoleCountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MotorPoleCountType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MotorPoleCountType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MotorPoleCountType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MotorPoleCountType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MotorPoleCountType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MotorPoleCountType


class LinkedSystemIDType188(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedSystemIDType188)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedSystemIDType188.subclass:
            return LinkedSystemIDType188.subclass(*args_, **kwargs_)
        else:
            return LinkedSystemIDType188(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType188', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedSystemIDType188')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedSystemIDType188', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedSystemIDType188'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedSystemIDType188', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedSystemIDType188


class HeatRecoveryEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatRecoveryEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatRecoveryEfficiencyType.subclass:
            return HeatRecoveryEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return HeatRecoveryEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatRecoveryEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatRecoveryEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatRecoveryEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatRecoveryEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatRecoveryEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatRecoveryEfficiencyType


class EnergyRecoveryEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyRecoveryEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyRecoveryEfficiencyType.subclass:
            return EnergyRecoveryEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return EnergyRecoveryEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyRecoveryEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyRecoveryEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyRecoveryEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyRecoveryEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyRecoveryEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyRecoveryEfficiencyType


class SystemIDReceivingHeatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SystemIDReceivingHeatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SystemIDReceivingHeatType.subclass:
            return SystemIDReceivingHeatType.subclass(*args_, **kwargs_)
        else:
            return SystemIDReceivingHeatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SystemIDReceivingHeatType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SystemIDReceivingHeatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SystemIDReceivingHeatType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SystemIDReceivingHeatType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SystemIDReceivingHeatType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SystemIDReceivingHeatType


class SystemIDProvidingHeatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SystemIDProvidingHeatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SystemIDProvidingHeatType.subclass:
            return SystemIDProvidingHeatType.subclass(*args_, **kwargs_)
        else:
            return SystemIDProvidingHeatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SystemIDProvidingHeatType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SystemIDProvidingHeatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SystemIDProvidingHeatType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SystemIDProvidingHeatType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SystemIDProvidingHeatType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SystemIDProvidingHeatType


class WallInsulationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WallInsulationApplication=None, WallInsulationMaterial=None, WallInsulationThickness=None, WallInsulationContinuity=None, WallInsulationCondition=None, WallInsulationLocation=None):
        self.original_tagname_ = None
        self.WallInsulationApplication = WallInsulationApplication
        self.validate_WallInsulationApplicationType(self.WallInsulationApplication)
        self.WallInsulationMaterial = WallInsulationMaterial
        self.validate_InsulationMaterialType(self.WallInsulationMaterial)
        self.WallInsulationThickness = WallInsulationThickness
        self.WallInsulationContinuity = WallInsulationContinuity
        self.validate_WallInsulationContinuityType(self.WallInsulationContinuity)
        self.WallInsulationCondition = WallInsulationCondition
        self.validate_WallInsulationConditionType(self.WallInsulationCondition)
        self.WallInsulationLocation = WallInsulationLocation
        self.validate_WallInsulationLocationType(self.WallInsulationLocation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallInsulationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallInsulationType.subclass:
            return WallInsulationType.subclass(*args_, **kwargs_)
        else:
            return WallInsulationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WallInsulationApplicationType(self, value):
        # Validate type WallInsulationApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Loose-fill', 'Batt', 'Spray-on', 'Rigid', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WallInsulationApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_InsulationMaterialType(self, value):
        # Validate type InsulationMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fiberglass', 'Cellulose', 'EPS', 'XPS', 'Rock wool', 'Insulsafe', 'Recycled cotton', 'ISOCY', 'Icynene', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InsulationMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_WallInsulationContinuityType(self, value):
        # Validate type WallInsulationContinuityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cavity', 'Continuous', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WallInsulationContinuityType' % {"value" : value.encode("utf-8")} )
    def validate_WallInsulationConditionType(self, value):
        # Validate type WallInsulationConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Excellent', 'Good', 'Average', 'Poor', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WallInsulationConditionType' % {"value" : value.encode("utf-8")} )
    def validate_WallInsulationLocationType(self, value):
        # Validate type WallInsulationLocationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Interior', 'Exterior', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WallInsulationLocationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.WallInsulationApplication is not None or
            self.WallInsulationMaterial is not None or
            self.WallInsulationThickness is not None or
            self.WallInsulationContinuity is not None or
            self.WallInsulationCondition is not None or
            self.WallInsulationLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallInsulationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallInsulationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallInsulationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallInsulationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallInsulationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WallInsulationApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallInsulationApplication>%s</%sWallInsulationApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallInsulationApplication), input_name='WallInsulationApplication')), namespace_, eol_))
        if self.WallInsulationMaterial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallInsulationMaterial>%s</%sWallInsulationMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallInsulationMaterial), input_name='WallInsulationMaterial')), namespace_, eol_))
        if self.WallInsulationThickness is not None:
            self.WallInsulationThickness.export(outfile, level, namespace_, name_='WallInsulationThickness', pretty_print=pretty_print)
        if self.WallInsulationContinuity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallInsulationContinuity>%s</%sWallInsulationContinuity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallInsulationContinuity), input_name='WallInsulationContinuity')), namespace_, eol_))
        if self.WallInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallInsulationCondition>%s</%sWallInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallInsulationCondition), input_name='WallInsulationCondition')), namespace_, eol_))
        if self.WallInsulationLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWallInsulationLocation>%s</%sWallInsulationLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WallInsulationLocation), input_name='WallInsulationLocation')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WallInsulationApplication':
            WallInsulationApplication_ = child_.text
            WallInsulationApplication_ = self.gds_validate_string(WallInsulationApplication_, node, 'WallInsulationApplication')
            self.WallInsulationApplication = WallInsulationApplication_
            # validate type WallInsulationApplicationType
            self.validate_WallInsulationApplicationType(self.WallInsulationApplication)
        elif nodeName_ == 'WallInsulationMaterial':
            WallInsulationMaterial_ = child_.text
            WallInsulationMaterial_ = self.gds_validate_string(WallInsulationMaterial_, node, 'WallInsulationMaterial')
            self.WallInsulationMaterial = WallInsulationMaterial_
            # validate type InsulationMaterialType
            self.validate_InsulationMaterialType(self.WallInsulationMaterial)
        elif nodeName_ == 'WallInsulationThickness':
            obj_ = WallInsulationThicknessType.factory()
            obj_.build(child_)
            self.WallInsulationThickness = obj_
            obj_.original_tagname_ = 'WallInsulationThickness'
        elif nodeName_ == 'WallInsulationContinuity':
            WallInsulationContinuity_ = child_.text
            WallInsulationContinuity_ = self.gds_validate_string(WallInsulationContinuity_, node, 'WallInsulationContinuity')
            self.WallInsulationContinuity = WallInsulationContinuity_
            # validate type WallInsulationContinuityType
            self.validate_WallInsulationContinuityType(self.WallInsulationContinuity)
        elif nodeName_ == 'WallInsulationCondition':
            WallInsulationCondition_ = child_.text
            WallInsulationCondition_ = self.gds_validate_string(WallInsulationCondition_, node, 'WallInsulationCondition')
            self.WallInsulationCondition = WallInsulationCondition_
            # validate type WallInsulationConditionType
            self.validate_WallInsulationConditionType(self.WallInsulationCondition)
        elif nodeName_ == 'WallInsulationLocation':
            WallInsulationLocation_ = child_.text
            WallInsulationLocation_ = self.gds_validate_string(WallInsulationLocation_, node, 'WallInsulationLocation')
            self.WallInsulationLocation = WallInsulationLocation_
            # validate type WallInsulationLocationType
            self.validate_WallInsulationLocationType(self.WallInsulationLocation)
# end class WallInsulationType


class WallInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallInsulationThicknessType.subclass:
            return WallInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return WallInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallInsulationThicknessType


class WallRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallRValueType.subclass:
            return WallRValueType.subclass(*args_, **kwargs_)
        else:
            return WallRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallRValueType


class WallUFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallUFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallUFactorType.subclass:
            return WallUFactorType.subclass(*args_, **kwargs_)
        else:
            return WallUFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallUFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallUFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallUFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallUFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallUFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallUFactorType


class WallFramingSpacingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallFramingSpacingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallFramingSpacingType.subclass:
            return WallFramingSpacingType.subclass(*args_, **kwargs_)
        else:
            return WallFramingSpacingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallFramingSpacingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallFramingSpacingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallFramingSpacingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallFramingSpacingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallFramingSpacingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallFramingSpacingType


class WallFramingDepthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallFramingDepthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallFramingDepthType.subclass:
            return WallFramingDepthType.subclass(*args_, **kwargs_)
        else:
            return WallFramingDepthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallFramingDepthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallFramingDepthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallFramingDepthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallFramingDepthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallFramingDepthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallFramingDepthType


class WallFramingFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallFramingFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallFramingFactorType.subclass:
            return WallFramingFactorType.subclass(*args_, **kwargs_)
        else:
            return WallFramingFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallFramingFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallFramingFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallFramingFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallFramingFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallFramingFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallFramingFactorType


class WallExteriorSolarAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallExteriorSolarAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallExteriorSolarAbsorptanceType.subclass:
            return WallExteriorSolarAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return WallExteriorSolarAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallExteriorSolarAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallExteriorSolarAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallExteriorSolarAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallExteriorSolarAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallExteriorSolarAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallExteriorSolarAbsorptanceType


class WallExteriorThermalAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WallExteriorThermalAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WallExteriorThermalAbsorptanceType.subclass:
            return WallExteriorThermalAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return WallExteriorThermalAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WallExteriorThermalAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WallExteriorThermalAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WallExteriorThermalAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WallExteriorThermalAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WallExteriorThermalAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WallExteriorThermalAbsorptanceType


class InteriorVisibleAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InteriorVisibleAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InteriorVisibleAbsorptanceType.subclass:
            return InteriorVisibleAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return InteriorVisibleAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='InteriorVisibleAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InteriorVisibleAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='InteriorVisibleAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='InteriorVisibleAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='InteriorVisibleAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InteriorVisibleAbsorptanceType


class RoofInsulationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RoofInsulationApplication=None, RoofInsulationMaterial=None, RoofInsulationThickness=None, RoofInsulationContinuity=None, RoofInsulationCondition=None):
        self.original_tagname_ = None
        self.RoofInsulationApplication = RoofInsulationApplication
        self.validate_RoofInsulationApplicationType(self.RoofInsulationApplication)
        self.RoofInsulationMaterial = RoofInsulationMaterial
        self.validate_InsulationMaterialType(self.RoofInsulationMaterial)
        self.RoofInsulationThickness = RoofInsulationThickness
        self.RoofInsulationContinuity = RoofInsulationContinuity
        self.validate_RoofInsulationContinuityType(self.RoofInsulationContinuity)
        self.RoofInsulationCondition = RoofInsulationCondition
        self.validate_RoofInsulationConditionType(self.RoofInsulationCondition)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofInsulationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofInsulationType.subclass:
            return RoofInsulationType.subclass(*args_, **kwargs_)
        else:
            return RoofInsulationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RoofInsulationApplicationType(self, value):
        # Validate type RoofInsulationApplicationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Loose-fill', 'Batt', 'Spray-on', 'Rigid', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofInsulationApplicationType' % {"value" : value.encode("utf-8")} )
    def validate_InsulationMaterialType(self, value):
        # Validate type InsulationMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fiberglass', 'Cellulose', 'EPS', 'XPS', 'Rock wool', 'Insulsafe', 'Recycled cotton', 'ISOCY', 'Icynene', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InsulationMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_RoofInsulationContinuityType(self, value):
        # Validate type RoofInsulationContinuityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cavity', 'Continuous', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofInsulationContinuityType' % {"value" : value.encode("utf-8")} )
    def validate_RoofInsulationConditionType(self, value):
        # Validate type RoofInsulationConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Excellent', 'Good', 'Average', 'Poor', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RoofInsulationConditionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RoofInsulationApplication is not None or
            self.RoofInsulationMaterial is not None or
            self.RoofInsulationThickness is not None or
            self.RoofInsulationContinuity is not None or
            self.RoofInsulationCondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofInsulationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofInsulationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofInsulationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofInsulationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofInsulationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RoofInsulationApplication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofInsulationApplication>%s</%sRoofInsulationApplication>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofInsulationApplication), input_name='RoofInsulationApplication')), namespace_, eol_))
        if self.RoofInsulationMaterial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofInsulationMaterial>%s</%sRoofInsulationMaterial>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofInsulationMaterial), input_name='RoofInsulationMaterial')), namespace_, eol_))
        if self.RoofInsulationThickness is not None:
            self.RoofInsulationThickness.export(outfile, level, namespace_, name_='RoofInsulationThickness', pretty_print=pretty_print)
        if self.RoofInsulationContinuity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofInsulationContinuity>%s</%sRoofInsulationContinuity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofInsulationContinuity), input_name='RoofInsulationContinuity')), namespace_, eol_))
        if self.RoofInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoofInsulationCondition>%s</%sRoofInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.RoofInsulationCondition), input_name='RoofInsulationCondition')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RoofInsulationApplication':
            RoofInsulationApplication_ = child_.text
            RoofInsulationApplication_ = self.gds_validate_string(RoofInsulationApplication_, node, 'RoofInsulationApplication')
            self.RoofInsulationApplication = RoofInsulationApplication_
            # validate type RoofInsulationApplicationType
            self.validate_RoofInsulationApplicationType(self.RoofInsulationApplication)
        elif nodeName_ == 'RoofInsulationMaterial':
            RoofInsulationMaterial_ = child_.text
            RoofInsulationMaterial_ = self.gds_validate_string(RoofInsulationMaterial_, node, 'RoofInsulationMaterial')
            self.RoofInsulationMaterial = RoofInsulationMaterial_
            # validate type InsulationMaterialType
            self.validate_InsulationMaterialType(self.RoofInsulationMaterial)
        elif nodeName_ == 'RoofInsulationThickness':
            obj_ = RoofInsulationThicknessType.factory()
            obj_.build(child_)
            self.RoofInsulationThickness = obj_
            obj_.original_tagname_ = 'RoofInsulationThickness'
        elif nodeName_ == 'RoofInsulationContinuity':
            RoofInsulationContinuity_ = child_.text
            RoofInsulationContinuity_ = self.gds_validate_string(RoofInsulationContinuity_, node, 'RoofInsulationContinuity')
            self.RoofInsulationContinuity = RoofInsulationContinuity_
            # validate type RoofInsulationContinuityType
            self.validate_RoofInsulationContinuityType(self.RoofInsulationContinuity)
        elif nodeName_ == 'RoofInsulationCondition':
            RoofInsulationCondition_ = child_.text
            RoofInsulationCondition_ = self.gds_validate_string(RoofInsulationCondition_, node, 'RoofInsulationCondition')
            self.RoofInsulationCondition = RoofInsulationCondition_
            # validate type RoofInsulationConditionType
            self.validate_RoofInsulationConditionType(self.RoofInsulationCondition)
# end class RoofInsulationType


class RoofInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofInsulationThicknessType.subclass:
            return RoofInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return RoofInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofInsulationThicknessType


class RoofRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofRValueType.subclass:
            return RoofRValueType.subclass(*args_, **kwargs_)
        else:
            return RoofRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofRValueType


class RoofUFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofUFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofUFactorType.subclass:
            return RoofUFactorType.subclass(*args_, **kwargs_)
        else:
            return RoofUFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofUFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofUFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofUFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofUFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofUFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofUFactorType


class RoofFramingSpacingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofFramingSpacingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofFramingSpacingType.subclass:
            return RoofFramingSpacingType.subclass(*args_, **kwargs_)
        else:
            return RoofFramingSpacingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofFramingSpacingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofFramingSpacingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofFramingSpacingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofFramingSpacingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofFramingSpacingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofFramingSpacingType


class RoofFramingDepthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofFramingDepthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofFramingDepthType.subclass:
            return RoofFramingDepthType.subclass(*args_, **kwargs_)
        else:
            return RoofFramingDepthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofFramingDepthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofFramingDepthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofFramingDepthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofFramingDepthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofFramingDepthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofFramingDepthType


class RoofFramingFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofFramingFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofFramingFactorType.subclass:
            return RoofFramingFactorType.subclass(*args_, **kwargs_)
        else:
            return RoofFramingFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofFramingFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofFramingFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofFramingFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofFramingFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofFramingFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofFramingFactorType


class RoofExteriorSolarAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofExteriorSolarAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofExteriorSolarAbsorptanceType.subclass:
            return RoofExteriorSolarAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return RoofExteriorSolarAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofExteriorSolarAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofExteriorSolarAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofExteriorSolarAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofExteriorSolarAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofExteriorSolarAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofExteriorSolarAbsorptanceType


class RoofExteriorThermalAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoofExteriorThermalAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoofExteriorThermalAbsorptanceType.subclass:
            return RoofExteriorThermalAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return RoofExteriorThermalAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RoofExteriorThermalAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoofExteriorThermalAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RoofExteriorThermalAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RoofExteriorThermalAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RoofExteriorThermalAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoofExteriorThermalAbsorptanceType


class CeilingVisibleAbsorptanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CeilingVisibleAbsorptanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CeilingVisibleAbsorptanceType.subclass:
            return CeilingVisibleAbsorptanceType.subclass(*args_, **kwargs_)
        else:
            return CeilingVisibleAbsorptanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CeilingVisibleAbsorptanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CeilingVisibleAbsorptanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CeilingVisibleAbsorptanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CeilingVisibleAbsorptanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CeilingVisibleAbsorptanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CeilingVisibleAbsorptanceType


class FenestrationTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Window=None, Skylight=None, Door=None, Other=None):
        self.original_tagname_ = None
        self.Window = Window
        self.Skylight = Skylight
        self.Door = Door
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationTypeType.subclass:
            return FenestrationTypeType.subclass(*args_, **kwargs_)
        else:
            return FenestrationTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Window is not None or
            self.Skylight is not None or
            self.Door is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Window is not None:
            self.Window.export(outfile, level, namespace_, name_='Window', pretty_print=pretty_print)
        if self.Skylight is not None:
            self.Skylight.export(outfile, level, namespace_, name_='Skylight', pretty_print=pretty_print)
        if self.Door is not None:
            self.Door.export(outfile, level, namespace_, name_='Door', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Window':
            obj_ = WindowType.factory()
            obj_.build(child_)
            self.Window = obj_
            obj_.original_tagname_ = 'Window'
        elif nodeName_ == 'Skylight':
            obj_ = SkylightType.factory()
            obj_.build(child_)
            self.Skylight = obj_
            obj_.original_tagname_ = 'Skylight'
        elif nodeName_ == 'Door':
            obj_ = DoorType.factory()
            obj_.build(child_)
            self.Door = obj_
            obj_.original_tagname_ = 'Door'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class FenestrationTypeType


class WindowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WindowLayout=None, WindowOrientation=None, WindowSillHeight=None, WindowHeight=None, WindowWidth=None, WindowHorizontalSpacing=None, ExteriorShadingType=None, OverhangHeightAboveWindow=None, OverhangProjection=None, VerticalFinDepth=None, DistanceBetweenVerticalFins=None, VerticalEdgeFinOnly=None, LightShelves=None, InteriorShadingType=None):
        self.original_tagname_ = None
        self.WindowLayout = WindowLayout
        self.validate_WindowLayoutType(self.WindowLayout)
        self.WindowOrientation = WindowOrientation
        self.validate_WindowOrientationType(self.WindowOrientation)
        self.WindowSillHeight = WindowSillHeight
        self.WindowHeight = WindowHeight
        self.WindowWidth = WindowWidth
        self.WindowHorizontalSpacing = WindowHorizontalSpacing
        self.ExteriorShadingType = ExteriorShadingType
        self.validate_ExteriorShadingTypeType(self.ExteriorShadingType)
        self.OverhangHeightAboveWindow = OverhangHeightAboveWindow
        self.OverhangProjection = OverhangProjection
        self.VerticalFinDepth = VerticalFinDepth
        self.DistanceBetweenVerticalFins = DistanceBetweenVerticalFins
        self.VerticalEdgeFinOnly = VerticalEdgeFinOnly
        self.LightShelves = LightShelves
        self.InteriorShadingType = InteriorShadingType
        self.validate_InteriorShadingTypeType(self.InteriorShadingType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowType.subclass:
            return WindowType.subclass(*args_, **kwargs_)
        else:
            return WindowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_WindowLayoutType(self, value):
        # Validate type WindowLayoutType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Continuous', 'Discrete', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WindowLayoutType' % {"value" : value.encode("utf-8")} )
    def validate_WindowOrientationType(self, value):
        # Validate type WindowOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WindowOrientationType' % {"value" : value.encode("utf-8")} )
    def validate_ExteriorShadingTypeType(self, value):
        # Validate type ExteriorShadingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Overhang', 'Fin', 'Awning', 'Solar screen', 'Solar film', 'Louver', 'Screen', 'None', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExteriorShadingTypeType' % {"value" : value.encode("utf-8")} )
    def validate_InteriorShadingTypeType(self, value):
        # Validate type InteriorShadingTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Blind', 'Curtain', 'Shade', 'None', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InteriorShadingTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.WindowLayout is not None or
            self.WindowOrientation is not None or
            self.WindowSillHeight is not None or
            self.WindowHeight is not None or
            self.WindowWidth is not None or
            self.WindowHorizontalSpacing is not None or
            self.ExteriorShadingType is not None or
            self.OverhangHeightAboveWindow is not None or
            self.OverhangProjection is not None or
            self.VerticalFinDepth is not None or
            self.DistanceBetweenVerticalFins is not None or
            self.VerticalEdgeFinOnly is not None or
            self.LightShelves is not None or
            self.InteriorShadingType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WindowLayout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowLayout>%s</%sWindowLayout>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WindowLayout), input_name='WindowLayout')), namespace_, eol_))
        if self.WindowOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWindowOrientation>%s</%sWindowOrientation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.WindowOrientation), input_name='WindowOrientation')), namespace_, eol_))
        if self.WindowSillHeight is not None:
            self.WindowSillHeight.export(outfile, level, namespace_, name_='WindowSillHeight', pretty_print=pretty_print)
        if self.WindowHeight is not None:
            self.WindowHeight.export(outfile, level, namespace_, name_='WindowHeight', pretty_print=pretty_print)
        if self.WindowWidth is not None:
            self.WindowWidth.export(outfile, level, namespace_, name_='WindowWidth', pretty_print=pretty_print)
        if self.WindowHorizontalSpacing is not None:
            self.WindowHorizontalSpacing.export(outfile, level, namespace_, name_='WindowHorizontalSpacing', pretty_print=pretty_print)
        if self.ExteriorShadingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorShadingType>%s</%sExteriorShadingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorShadingType), input_name='ExteriorShadingType')), namespace_, eol_))
        if self.OverhangHeightAboveWindow is not None:
            self.OverhangHeightAboveWindow.export(outfile, level, namespace_, name_='OverhangHeightAboveWindow', pretty_print=pretty_print)
        if self.OverhangProjection is not None:
            self.OverhangProjection.export(outfile, level, namespace_, name_='OverhangProjection', pretty_print=pretty_print)
        if self.VerticalFinDepth is not None:
            self.VerticalFinDepth.export(outfile, level, namespace_, name_='VerticalFinDepth', pretty_print=pretty_print)
        if self.DistanceBetweenVerticalFins is not None:
            self.DistanceBetweenVerticalFins.export(outfile, level, namespace_, name_='DistanceBetweenVerticalFins', pretty_print=pretty_print)
        if self.VerticalEdgeFinOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerticalEdgeFinOnly>%s</%sVerticalEdgeFinOnly>%s' % (namespace_, self.gds_format_boolean(self.VerticalEdgeFinOnly, input_name='VerticalEdgeFinOnly'), namespace_, eol_))
        if self.LightShelves is not None:
            self.LightShelves.export(outfile, level, namespace_, name_='LightShelves', pretty_print=pretty_print)
        if self.InteriorShadingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInteriorShadingType>%s</%sInteriorShadingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.InteriorShadingType), input_name='InteriorShadingType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WindowLayout':
            WindowLayout_ = child_.text
            WindowLayout_ = self.gds_validate_string(WindowLayout_, node, 'WindowLayout')
            self.WindowLayout = WindowLayout_
            # validate type WindowLayoutType
            self.validate_WindowLayoutType(self.WindowLayout)
        elif nodeName_ == 'WindowOrientation':
            WindowOrientation_ = child_.text
            WindowOrientation_ = self.gds_validate_string(WindowOrientation_, node, 'WindowOrientation')
            self.WindowOrientation = WindowOrientation_
            # validate type WindowOrientationType
            self.validate_WindowOrientationType(self.WindowOrientation)
        elif nodeName_ == 'WindowSillHeight':
            obj_ = WindowSillHeightType.factory()
            obj_.build(child_)
            self.WindowSillHeight = obj_
            obj_.original_tagname_ = 'WindowSillHeight'
        elif nodeName_ == 'WindowHeight':
            obj_ = WindowHeightType.factory()
            obj_.build(child_)
            self.WindowHeight = obj_
            obj_.original_tagname_ = 'WindowHeight'
        elif nodeName_ == 'WindowWidth':
            obj_ = WindowWidthType.factory()
            obj_.build(child_)
            self.WindowWidth = obj_
            obj_.original_tagname_ = 'WindowWidth'
        elif nodeName_ == 'WindowHorizontalSpacing':
            obj_ = WindowHorizontalSpacingType.factory()
            obj_.build(child_)
            self.WindowHorizontalSpacing = obj_
            obj_.original_tagname_ = 'WindowHorizontalSpacing'
        elif nodeName_ == 'ExteriorShadingType':
            ExteriorShadingType_ = child_.text
            ExteriorShadingType_ = self.gds_validate_string(ExteriorShadingType_, node, 'ExteriorShadingType')
            self.ExteriorShadingType = ExteriorShadingType_
            # validate type ExteriorShadingTypeType
            self.validate_ExteriorShadingTypeType(self.ExteriorShadingType)
        elif nodeName_ == 'OverhangHeightAboveWindow':
            obj_ = OverhangHeightAboveWindowType.factory()
            obj_.build(child_)
            self.OverhangHeightAboveWindow = obj_
            obj_.original_tagname_ = 'OverhangHeightAboveWindow'
        elif nodeName_ == 'OverhangProjection':
            obj_ = OverhangProjectionType.factory()
            obj_.build(child_)
            self.OverhangProjection = obj_
            obj_.original_tagname_ = 'OverhangProjection'
        elif nodeName_ == 'VerticalFinDepth':
            obj_ = VerticalFinDepthType.factory()
            obj_.build(child_)
            self.VerticalFinDepth = obj_
            obj_.original_tagname_ = 'VerticalFinDepth'
        elif nodeName_ == 'DistanceBetweenVerticalFins':
            obj_ = DistanceBetweenVerticalFinsType.factory()
            obj_.build(child_)
            self.DistanceBetweenVerticalFins = obj_
            obj_.original_tagname_ = 'DistanceBetweenVerticalFins'
        elif nodeName_ == 'VerticalEdgeFinOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'VerticalEdgeFinOnly')
            self.VerticalEdgeFinOnly = ival_
        elif nodeName_ == 'LightShelves':
            obj_ = LightShelvesType.factory()
            obj_.build(child_)
            self.LightShelves = obj_
            obj_.original_tagname_ = 'LightShelves'
        elif nodeName_ == 'InteriorShadingType':
            InteriorShadingType_ = child_.text
            InteriorShadingType_ = self.gds_validate_string(InteriorShadingType_, node, 'InteriorShadingType')
            self.InteriorShadingType = InteriorShadingType_
            # validate type InteriorShadingTypeType
            self.validate_InteriorShadingTypeType(self.InteriorShadingType)
# end class WindowType


class WindowSillHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowSillHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowSillHeightType.subclass:
            return WindowSillHeightType.subclass(*args_, **kwargs_)
        else:
            return WindowSillHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowSillHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowSillHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowSillHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowSillHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowSillHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WindowSillHeightType


class WindowHeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowHeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowHeightType.subclass:
            return WindowHeightType.subclass(*args_, **kwargs_)
        else:
            return WindowHeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowHeightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowHeightType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowHeightType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowHeightType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowHeightType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WindowHeightType


class WindowWidthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowWidthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowWidthType.subclass:
            return WindowWidthType.subclass(*args_, **kwargs_)
        else:
            return WindowWidthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowWidthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowWidthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowWidthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowWidthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowWidthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WindowWidthType


class WindowHorizontalSpacingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindowHorizontalSpacingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindowHorizontalSpacingType.subclass:
            return WindowHorizontalSpacingType.subclass(*args_, **kwargs_)
        else:
            return WindowHorizontalSpacingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WindowHorizontalSpacingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WindowHorizontalSpacingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WindowHorizontalSpacingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WindowHorizontalSpacingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WindowHorizontalSpacingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WindowHorizontalSpacingType


class OverhangHeightAboveWindowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OverhangHeightAboveWindowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OverhangHeightAboveWindowType.subclass:
            return OverhangHeightAboveWindowType.subclass(*args_, **kwargs_)
        else:
            return OverhangHeightAboveWindowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OverhangHeightAboveWindowType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverhangHeightAboveWindowType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OverhangHeightAboveWindowType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OverhangHeightAboveWindowType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OverhangHeightAboveWindowType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OverhangHeightAboveWindowType


class OverhangProjectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OverhangProjectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OverhangProjectionType.subclass:
            return OverhangProjectionType.subclass(*args_, **kwargs_)
        else:
            return OverhangProjectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OverhangProjectionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverhangProjectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OverhangProjectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OverhangProjectionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OverhangProjectionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OverhangProjectionType


class VerticalFinDepthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalFinDepthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalFinDepthType.subclass:
            return VerticalFinDepthType.subclass(*args_, **kwargs_)
        else:
            return VerticalFinDepthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VerticalFinDepthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerticalFinDepthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VerticalFinDepthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VerticalFinDepthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VerticalFinDepthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerticalFinDepthType


class DistanceBetweenVerticalFinsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistanceBetweenVerticalFinsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistanceBetweenVerticalFinsType.subclass:
            return DistanceBetweenVerticalFinsType.subclass(*args_, **kwargs_)
        else:
            return DistanceBetweenVerticalFinsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DistanceBetweenVerticalFinsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistanceBetweenVerticalFinsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DistanceBetweenVerticalFinsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DistanceBetweenVerticalFinsType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DistanceBetweenVerticalFinsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DistanceBetweenVerticalFinsType


class LightShelvesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightShelvesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightShelvesType.subclass:
            return LightShelvesType.subclass(*args_, **kwargs_)
        else:
            return LightShelvesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightShelvesType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightShelvesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightShelvesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightShelvesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightShelvesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType189.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class LightShelvesType


class TrueType189(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LightShelfDistanceFromTop=None, LightShelfExteriorProtrusion=None, LightShelfInteriorProtrusion=None):
        self.original_tagname_ = None
        self.LightShelfDistanceFromTop = LightShelfDistanceFromTop
        self.LightShelfExteriorProtrusion = LightShelfExteriorProtrusion
        self.LightShelfInteriorProtrusion = LightShelfInteriorProtrusion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType189)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType189.subclass:
            return TrueType189.subclass(*args_, **kwargs_)
        else:
            return TrueType189(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LightShelfDistanceFromTop is not None or
            self.LightShelfExteriorProtrusion is not None or
            self.LightShelfInteriorProtrusion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType189', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType189')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType189', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType189'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType189', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LightShelfDistanceFromTop is not None:
            self.LightShelfDistanceFromTop.export(outfile, level, namespace_, name_='LightShelfDistanceFromTop', pretty_print=pretty_print)
        if self.LightShelfExteriorProtrusion is not None:
            self.LightShelfExteriorProtrusion.export(outfile, level, namespace_, name_='LightShelfExteriorProtrusion', pretty_print=pretty_print)
        if self.LightShelfInteriorProtrusion is not None:
            self.LightShelfInteriorProtrusion.export(outfile, level, namespace_, name_='LightShelfInteriorProtrusion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LightShelfDistanceFromTop':
            obj_ = LightShelfDistanceFromTopType.factory()
            obj_.build(child_)
            self.LightShelfDistanceFromTop = obj_
            obj_.original_tagname_ = 'LightShelfDistanceFromTop'
        elif nodeName_ == 'LightShelfExteriorProtrusion':
            obj_ = LightShelfExteriorProtrusionType.factory()
            obj_.build(child_)
            self.LightShelfExteriorProtrusion = obj_
            obj_.original_tagname_ = 'LightShelfExteriorProtrusion'
        elif nodeName_ == 'LightShelfInteriorProtrusion':
            obj_ = LightShelfInteriorProtrusionType.factory()
            obj_.build(child_)
            self.LightShelfInteriorProtrusion = obj_
            obj_.original_tagname_ = 'LightShelfInteriorProtrusion'
# end class TrueType189


class LightShelfDistanceFromTopType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightShelfDistanceFromTopType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightShelfDistanceFromTopType.subclass:
            return LightShelfDistanceFromTopType.subclass(*args_, **kwargs_)
        else:
            return LightShelfDistanceFromTopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightShelfDistanceFromTopType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightShelfDistanceFromTopType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightShelfDistanceFromTopType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightShelfDistanceFromTopType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightShelfDistanceFromTopType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightShelfDistanceFromTopType


class LightShelfExteriorProtrusionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightShelfExteriorProtrusionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightShelfExteriorProtrusionType.subclass:
            return LightShelfExteriorProtrusionType.subclass(*args_, **kwargs_)
        else:
            return LightShelfExteriorProtrusionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightShelfExteriorProtrusionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightShelfExteriorProtrusionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightShelfExteriorProtrusionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightShelfExteriorProtrusionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightShelfExteriorProtrusionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightShelfExteriorProtrusionType


class LightShelfInteriorProtrusionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LightShelfInteriorProtrusionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LightShelfInteriorProtrusionType.subclass:
            return LightShelfInteriorProtrusionType.subclass(*args_, **kwargs_)
        else:
            return LightShelfInteriorProtrusionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LightShelfInteriorProtrusionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LightShelfInteriorProtrusionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LightShelfInteriorProtrusionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LightShelfInteriorProtrusionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LightShelfInteriorProtrusionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightShelfInteriorProtrusionType


class SkylightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SkylightLayout=None, SkylightPitch=None, SkylightWindowTreatments=None, SkylightSolarTube=None):
        self.original_tagname_ = None
        self.SkylightLayout = SkylightLayout
        self.validate_SkylightLayoutType(self.SkylightLayout)
        self.SkylightPitch = SkylightPitch
        self.SkylightWindowTreatments = SkylightWindowTreatments
        self.validate_SkylightWindowTreatmentsType(self.SkylightWindowTreatments)
        self.SkylightSolarTube = SkylightSolarTube
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SkylightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SkylightType.subclass:
            return SkylightType.subclass(*args_, **kwargs_)
        else:
            return SkylightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SkylightLayoutType(self, value):
        # Validate type SkylightLayoutType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['All Zones', 'Core Only', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SkylightLayoutType' % {"value" : value.encode("utf-8")} )
    def validate_SkylightWindowTreatmentsType(self, value):
        # Validate type SkylightWindowTreatmentsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Window film', 'Solar screen', 'Shading', 'None', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SkylightWindowTreatmentsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SkylightLayout is not None or
            self.SkylightPitch is not None or
            self.SkylightWindowTreatments is not None or
            self.SkylightSolarTube is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SkylightType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SkylightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SkylightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SkylightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SkylightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SkylightLayout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSkylightLayout>%s</%sSkylightLayout>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SkylightLayout), input_name='SkylightLayout')), namespace_, eol_))
        if self.SkylightPitch is not None:
            self.SkylightPitch.export(outfile, level, namespace_, name_='SkylightPitch', pretty_print=pretty_print)
        if self.SkylightWindowTreatments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSkylightWindowTreatments>%s</%sSkylightWindowTreatments>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SkylightWindowTreatments), input_name='SkylightWindowTreatments')), namespace_, eol_))
        if self.SkylightSolarTube is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSkylightSolarTube>%s</%sSkylightSolarTube>%s' % (namespace_, self.gds_format_boolean(self.SkylightSolarTube, input_name='SkylightSolarTube'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SkylightLayout':
            SkylightLayout_ = child_.text
            SkylightLayout_ = self.gds_validate_string(SkylightLayout_, node, 'SkylightLayout')
            self.SkylightLayout = SkylightLayout_
            # validate type SkylightLayoutType
            self.validate_SkylightLayoutType(self.SkylightLayout)
        elif nodeName_ == 'SkylightPitch':
            obj_ = SkylightPitchType.factory()
            obj_.build(child_)
            self.SkylightPitch = obj_
            obj_.original_tagname_ = 'SkylightPitch'
        elif nodeName_ == 'SkylightWindowTreatments':
            SkylightWindowTreatments_ = child_.text
            SkylightWindowTreatments_ = self.gds_validate_string(SkylightWindowTreatments_, node, 'SkylightWindowTreatments')
            self.SkylightWindowTreatments = SkylightWindowTreatments_
            # validate type SkylightWindowTreatmentsType
            self.validate_SkylightWindowTreatmentsType(self.SkylightWindowTreatments)
        elif nodeName_ == 'SkylightSolarTube':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SkylightSolarTube')
            self.SkylightSolarTube = ival_
# end class SkylightType


class SkylightPitchType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SkylightPitchType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SkylightPitchType.subclass:
            return SkylightPitchType.subclass(*args_, **kwargs_)
        else:
            return SkylightPitchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SkylightPitchType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SkylightPitchType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SkylightPitchType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SkylightPitchType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SkylightPitchType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SkylightPitchType


class DoorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExteriorDoorType=None, Vestibule=None, DoorOperation=None, DoorGlazedAreaFraction=None):
        self.original_tagname_ = None
        self.ExteriorDoorType = ExteriorDoorType
        self.validate_ExteriorDoorTypeType(self.ExteriorDoorType)
        self.Vestibule = Vestibule
        self.DoorOperation = DoorOperation
        self.validate_DoorOperationType(self.DoorOperation)
        self.DoorGlazedAreaFraction = DoorGlazedAreaFraction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoorType.subclass:
            return DoorType.subclass(*args_, **kwargs_)
        else:
            return DoorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ExteriorDoorTypeType(self, value):
        # Validate type ExteriorDoorTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Solid wood', 'Hollow wood', 'Uninsulated metal', 'Insulated metal', 'Glass', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExteriorDoorTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DoorOperationType(self, value):
        # Validate type DoorOperationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NonSwinging', 'Swinging', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DoorOperationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ExteriorDoorType is not None or
            self.Vestibule is not None or
            self.DoorOperation is not None or
            self.DoorGlazedAreaFraction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DoorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DoorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DoorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DoorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExteriorDoorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExteriorDoorType>%s</%sExteriorDoorType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExteriorDoorType), input_name='ExteriorDoorType')), namespace_, eol_))
        if self.Vestibule is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVestibule>%s</%sVestibule>%s' % (namespace_, self.gds_format_boolean(self.Vestibule, input_name='Vestibule'), namespace_, eol_))
        if self.DoorOperation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDoorOperation>%s</%sDoorOperation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DoorOperation), input_name='DoorOperation')), namespace_, eol_))
        if self.DoorGlazedAreaFraction is not None:
            self.DoorGlazedAreaFraction.export(outfile, level, namespace_, name_='DoorGlazedAreaFraction', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExteriorDoorType':
            ExteriorDoorType_ = child_.text
            ExteriorDoorType_ = self.gds_validate_string(ExteriorDoorType_, node, 'ExteriorDoorType')
            self.ExteriorDoorType = ExteriorDoorType_
            # validate type ExteriorDoorTypeType
            self.validate_ExteriorDoorTypeType(self.ExteriorDoorType)
        elif nodeName_ == 'Vestibule':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Vestibule')
            self.Vestibule = ival_
        elif nodeName_ == 'DoorOperation':
            DoorOperation_ = child_.text
            DoorOperation_ = self.gds_validate_string(DoorOperation_, node, 'DoorOperation')
            self.DoorOperation = DoorOperation_
            # validate type DoorOperationType
            self.validate_DoorOperationType(self.DoorOperation)
        elif nodeName_ == 'DoorGlazedAreaFraction':
            obj_ = DoorGlazedAreaFractionType.factory()
            obj_.build(child_)
            self.DoorGlazedAreaFraction = obj_
            obj_.original_tagname_ = 'DoorGlazedAreaFraction'
# end class DoorType


class DoorGlazedAreaFractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoorGlazedAreaFractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoorGlazedAreaFractionType.subclass:
            return DoorGlazedAreaFractionType.subclass(*args_, **kwargs_)
        else:
            return DoorGlazedAreaFractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DoorGlazedAreaFractionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoorGlazedAreaFractionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DoorGlazedAreaFractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DoorGlazedAreaFractionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DoorGlazedAreaFractionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoorGlazedAreaFractionType


class FenestrationRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationRValueType.subclass:
            return FenestrationRValueType.subclass(*args_, **kwargs_)
        else:
            return FenestrationRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FenestrationRValueType


class FenestrationUFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenestrationUFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenestrationUFactorType.subclass:
            return FenestrationUFactorType.subclass(*args_, **kwargs_)
        else:
            return FenestrationUFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FenestrationUFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FenestrationUFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FenestrationUFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FenestrationUFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FenestrationUFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FenestrationUFactorType


class SolarHeatGainCoefficientType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarHeatGainCoefficientType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarHeatGainCoefficientType.subclass:
            return SolarHeatGainCoefficientType.subclass(*args_, **kwargs_)
        else:
            return SolarHeatGainCoefficientType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SolarHeatGainCoefficientType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SolarHeatGainCoefficientType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SolarHeatGainCoefficientType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SolarHeatGainCoefficientType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SolarHeatGainCoefficientType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SolarHeatGainCoefficientType


class VisibleTransmittanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VisibleTransmittanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VisibleTransmittanceType.subclass:
            return VisibleTransmittanceType.subclass(*args_, **kwargs_)
        else:
            return VisibleTransmittanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VisibleTransmittanceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VisibleTransmittanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VisibleTransmittanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VisibleTransmittanceType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VisibleTransmittanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VisibleTransmittanceType


class GroundCouplingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SlabOnGrade=None, Crawlspace=None, Basement=None, Other=None, Unknown=None):
        self.original_tagname_ = None
        self.SlabOnGrade = SlabOnGrade
        self.Crawlspace = Crawlspace
        self.Basement = Basement
        self.Other = Other
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GroundCouplingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GroundCouplingType.subclass:
            return GroundCouplingType.subclass(*args_, **kwargs_)
        else:
            return GroundCouplingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SlabOnGrade is not None or
            self.Crawlspace is not None or
            self.Basement is not None or
            self.Other is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GroundCouplingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroundCouplingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GroundCouplingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GroundCouplingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GroundCouplingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SlabOnGrade is not None:
            self.SlabOnGrade.export(outfile, level, namespace_, name_='SlabOnGrade', pretty_print=pretty_print)
        if self.Crawlspace is not None:
            self.Crawlspace.export(outfile, level, namespace_, name_='Crawlspace', pretty_print=pretty_print)
        if self.Basement is not None:
            self.Basement.export(outfile, level, namespace_, name_='Basement', pretty_print=pretty_print)
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SlabOnGrade':
            obj_ = SlabOnGradeType.factory()
            obj_.build(child_)
            self.SlabOnGrade = obj_
            obj_.original_tagname_ = 'SlabOnGrade'
        elif nodeName_ == 'Crawlspace':
            obj_ = CrawlspaceType.factory()
            obj_.build(child_)
            self.Crawlspace = obj_
            obj_.original_tagname_ = 'Crawlspace'
        elif nodeName_ == 'Basement':
            obj_ = BasementType.factory()
            obj_.build(child_)
            self.Basement = obj_
            obj_.original_tagname_ = 'Basement'
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class GroundCouplingType


class SlabOnGradeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SlabInsulationOrientation=None, SlabArea=None, SlabPerimeter=None, SlabExposedPerimeter=None, SlabInsulationThickness=None, SlabInsulationCondition=None, SlabHeating=None):
        self.original_tagname_ = None
        self.SlabInsulationOrientation = SlabInsulationOrientation
        self.validate_SlabInsulationOrientation(self.SlabInsulationOrientation)
        self.SlabArea = SlabArea
        self.SlabPerimeter = SlabPerimeter
        self.SlabExposedPerimeter = SlabExposedPerimeter
        self.SlabInsulationThickness = SlabInsulationThickness
        self.SlabInsulationCondition = SlabInsulationCondition
        self.validate_SlabInsulationCondition(self.SlabInsulationCondition)
        self.SlabHeating = SlabHeating
        self.validate_SlabHeating(self.SlabHeating)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabOnGradeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabOnGradeType.subclass:
            return SlabOnGradeType.subclass(*args_, **kwargs_)
        else:
            return SlabOnGradeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SlabInsulationOrientation(self, value):
        # Validate type SlabInsulationOrientation, a restriction on xs:string.
        pass
    def validate_SlabInsulationCondition(self, value):
        # Validate type SlabInsulationCondition, a restriction on xs:string.
        pass
    def validate_SlabHeating(self, value):
        # Validate type SlabHeating, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SlabInsulationOrientation is not None or
            self.SlabArea is not None or
            self.SlabPerimeter is not None or
            self.SlabExposedPerimeter is not None or
            self.SlabInsulationThickness is not None or
            self.SlabInsulationCondition is not None or
            self.SlabHeating is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabOnGradeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabOnGradeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabOnGradeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabOnGradeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabOnGradeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SlabInsulationOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabInsulationOrientation>%s</%sSlabInsulationOrientation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabInsulationOrientation), input_name='SlabInsulationOrientation')), namespace_, eol_))
        if self.SlabArea is not None:
            self.SlabArea.export(outfile, level, namespace_, name_='SlabArea', pretty_print=pretty_print)
        if self.SlabPerimeter is not None:
            self.SlabPerimeter.export(outfile, level, namespace_, name_='SlabPerimeter', pretty_print=pretty_print)
        if self.SlabExposedPerimeter is not None:
            self.SlabExposedPerimeter.export(outfile, level, namespace_, name_='SlabExposedPerimeter', pretty_print=pretty_print)
        if self.SlabInsulationThickness is not None:
            self.SlabInsulationThickness.export(outfile, level, namespace_, name_='SlabInsulationThickness', pretty_print=pretty_print)
        if self.SlabInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabInsulationCondition>%s</%sSlabInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabInsulationCondition), input_name='SlabInsulationCondition')), namespace_, eol_))
        if self.SlabHeating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabHeating>%s</%sSlabHeating>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabHeating), input_name='SlabHeating')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SlabInsulationOrientation':
            SlabInsulationOrientation_ = child_.text
            SlabInsulationOrientation_ = self.gds_validate_string(SlabInsulationOrientation_, node, 'SlabInsulationOrientation')
            self.SlabInsulationOrientation = SlabInsulationOrientation_
            # validate type SlabInsulationOrientation
            self.validate_SlabInsulationOrientation(self.SlabInsulationOrientation)
        elif nodeName_ == 'SlabArea':
            obj_ = SlabAreaType.factory()
            obj_.build(child_)
            self.SlabArea = obj_
            obj_.original_tagname_ = 'SlabArea'
        elif nodeName_ == 'SlabPerimeter':
            obj_ = SlabPerimeterType.factory()
            obj_.build(child_)
            self.SlabPerimeter = obj_
            obj_.original_tagname_ = 'SlabPerimeter'
        elif nodeName_ == 'SlabExposedPerimeter':
            obj_ = SlabExposedPerimeterType.factory()
            obj_.build(child_)
            self.SlabExposedPerimeter = obj_
            obj_.original_tagname_ = 'SlabExposedPerimeter'
        elif nodeName_ == 'SlabInsulationThickness':
            obj_ = SlabInsulationThicknessType.factory()
            obj_.build(child_)
            self.SlabInsulationThickness = obj_
            obj_.original_tagname_ = 'SlabInsulationThickness'
        elif nodeName_ == 'SlabInsulationCondition':
            SlabInsulationCondition_ = child_.text
            SlabInsulationCondition_ = self.gds_validate_string(SlabInsulationCondition_, node, 'SlabInsulationCondition')
            self.SlabInsulationCondition = SlabInsulationCondition_
            # validate type SlabInsulationCondition
            self.validate_SlabInsulationCondition(self.SlabInsulationCondition)
        elif nodeName_ == 'SlabHeating':
            SlabHeating_ = child_.text
            SlabHeating_ = self.gds_validate_string(SlabHeating_, node, 'SlabHeating')
            self.SlabHeating = SlabHeating_
            # validate type SlabHeating
            self.validate_SlabHeating(self.SlabHeating)
# end class SlabOnGradeType


class SlabAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabAreaType.subclass:
            return SlabAreaType.subclass(*args_, **kwargs_)
        else:
            return SlabAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabAreaType


class SlabPerimeterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabPerimeterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabPerimeterType.subclass:
            return SlabPerimeterType.subclass(*args_, **kwargs_)
        else:
            return SlabPerimeterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabPerimeterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabPerimeterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabPerimeterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabPerimeterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabPerimeterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabPerimeterType


class SlabExposedPerimeterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabExposedPerimeterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabExposedPerimeterType.subclass:
            return SlabExposedPerimeterType.subclass(*args_, **kwargs_)
        else:
            return SlabExposedPerimeterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabExposedPerimeterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabExposedPerimeterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabExposedPerimeterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabExposedPerimeterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabExposedPerimeterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabExposedPerimeterType


class SlabInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabInsulationThicknessType.subclass:
            return SlabInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return SlabInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabInsulationThicknessType


class CrawlspaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CrawlspaceVenting=None):
        self.original_tagname_ = None
        self.CrawlspaceVenting = CrawlspaceVenting
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CrawlspaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CrawlspaceType.subclass:
            return CrawlspaceType.subclass(*args_, **kwargs_)
        else:
            return CrawlspaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CrawlspaceVenting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CrawlspaceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CrawlspaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CrawlspaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CrawlspaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CrawlspaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CrawlspaceVenting is not None:
            self.CrawlspaceVenting.export(outfile, level, namespace_, name_='CrawlspaceVenting', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CrawlspaceVenting':
            obj_ = CrawlspaceVentingType.factory()
            obj_.build(child_)
            self.CrawlspaceVenting = obj_
            obj_.original_tagname_ = 'CrawlspaceVenting'
# end class CrawlspaceType


class CrawlspaceVentingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Vented=None, Unvented=None, OtherCombination=None, Unknown=None):
        self.original_tagname_ = None
        self.Vented = Vented
        self.Unvented = Unvented
        self.OtherCombination = OtherCombination
        self.Unknown = Unknown
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CrawlspaceVentingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CrawlspaceVentingType.subclass:
            return CrawlspaceVentingType.subclass(*args_, **kwargs_)
        else:
            return CrawlspaceVentingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Vented is not None or
            self.Unvented is not None or
            self.OtherCombination is not None or
            self.Unknown is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='CrawlspaceVentingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CrawlspaceVentingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='CrawlspaceVentingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='CrawlspaceVentingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='CrawlspaceVentingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Vented is not None:
            self.Vented.export(outfile, level, namespace_, name_='Vented', pretty_print=pretty_print)
        if self.Unvented is not None:
            self.Unvented.export(outfile, level, namespace_, name_='Unvented', pretty_print=pretty_print)
        if self.OtherCombination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherCombination>%s</%sOtherCombination>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherCombination), input_name='OtherCombination')), namespace_, eol_))
        if self.Unknown is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnknown>%s</%sUnknown>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Unknown), input_name='Unknown')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vented':
            obj_ = VentedType.factory()
            obj_.build(child_)
            self.Vented = obj_
            obj_.original_tagname_ = 'Vented'
        elif nodeName_ == 'Unvented':
            obj_ = UnventedType.factory()
            obj_.build(child_)
            self.Unvented = obj_
            obj_.original_tagname_ = 'Unvented'
        elif nodeName_ == 'OtherCombination':
            OtherCombination_ = child_.text
            OtherCombination_ = self.gds_validate_string(OtherCombination_, node, 'OtherCombination')
            self.OtherCombination = OtherCombination_
        elif nodeName_ == 'Unknown':
            Unknown_ = child_.text
            Unknown_ = self.gds_validate_string(Unknown_, node, 'Unknown')
            self.Unknown = Unknown_
# end class CrawlspaceVentingType


class VentedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FloorConstructionType=None, FloorInsulationThickness=None, FloorInsulationCondition=None, FloorRValue=None, FloorUFactor=None, FloorFramingSpacing=None, FloorFramingDepth=None, FloorFramingFactor=None):
        self.original_tagname_ = None
        self.FloorConstructionType = FloorConstructionType
        self.validate_EnvelopeConstructionType(self.FloorConstructionType)
        self.FloorInsulationThickness = FloorInsulationThickness
        self.FloorInsulationCondition = FloorInsulationCondition
        self.validate_FloorInsulationConditionType(self.FloorInsulationCondition)
        self.FloorRValue = FloorRValue
        self.FloorUFactor = FloorUFactor
        self.FloorFramingSpacing = FloorFramingSpacing
        self.FloorFramingDepth = FloorFramingDepth
        self.FloorFramingFactor = FloorFramingFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VentedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VentedType.subclass:
            return VentedType.subclass(*args_, **kwargs_)
        else:
            return VentedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnvelopeConstructionType(self, value):
        # Validate type EnvelopeConstructionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Masonry', 'Structural brick', 'Stone', 'Concrete masonry unit', 'Concrete-solid', 'Concrete-lightweight', 'Concrete-panels', 'Concrete-poured', 'Concrete-load bearing', 'Concrete-insulated forms', 'Concrete-aerated', 'Steel frame', 'Wood frame', 'Double wood frame', 'Structural insulated panel', 'Log-solid wood', 'Straw bale', 'Built-up', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeConstructionType' % {"value" : value.encode("utf-8")} )
    def validate_FloorInsulationConditionType(self, value):
        # Validate type FloorInsulationConditionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Excellent', 'Good', 'Average', 'Poor', 'Other', 'Unknown', 'None']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FloorInsulationConditionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FloorConstructionType is not None or
            self.FloorInsulationThickness is not None or
            self.FloorInsulationCondition is not None or
            self.FloorRValue is not None or
            self.FloorUFactor is not None or
            self.FloorFramingSpacing is not None or
            self.FloorFramingDepth is not None or
            self.FloorFramingFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='VentedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VentedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='VentedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='VentedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='VentedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FloorConstructionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFloorConstructionType>%s</%sFloorConstructionType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FloorConstructionType), input_name='FloorConstructionType')), namespace_, eol_))
        if self.FloorInsulationThickness is not None:
            self.FloorInsulationThickness.export(outfile, level, namespace_, name_='FloorInsulationThickness', pretty_print=pretty_print)
        if self.FloorInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFloorInsulationCondition>%s</%sFloorInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FloorInsulationCondition), input_name='FloorInsulationCondition')), namespace_, eol_))
        if self.FloorRValue is not None:
            self.FloorRValue.export(outfile, level, namespace_, name_='FloorRValue', pretty_print=pretty_print)
        if self.FloorUFactor is not None:
            self.FloorUFactor.export(outfile, level, namespace_, name_='FloorUFactor', pretty_print=pretty_print)
        if self.FloorFramingSpacing is not None:
            self.FloorFramingSpacing.export(outfile, level, namespace_, name_='FloorFramingSpacing', pretty_print=pretty_print)
        if self.FloorFramingDepth is not None:
            self.FloorFramingDepth.export(outfile, level, namespace_, name_='FloorFramingDepth', pretty_print=pretty_print)
        if self.FloorFramingFactor is not None:
            self.FloorFramingFactor.export(outfile, level, namespace_, name_='FloorFramingFactor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FloorConstructionType':
            FloorConstructionType_ = child_.text
            FloorConstructionType_ = self.gds_validate_string(FloorConstructionType_, node, 'FloorConstructionType')
            self.FloorConstructionType = FloorConstructionType_
            # validate type EnvelopeConstructionType
            self.validate_EnvelopeConstructionType(self.FloorConstructionType)
        elif nodeName_ == 'FloorInsulationThickness':
            obj_ = FloorInsulationThicknessType.factory()
            obj_.build(child_)
            self.FloorInsulationThickness = obj_
            obj_.original_tagname_ = 'FloorInsulationThickness'
        elif nodeName_ == 'FloorInsulationCondition':
            FloorInsulationCondition_ = child_.text
            FloorInsulationCondition_ = self.gds_validate_string(FloorInsulationCondition_, node, 'FloorInsulationCondition')
            self.FloorInsulationCondition = FloorInsulationCondition_
            # validate type FloorInsulationConditionType
            self.validate_FloorInsulationConditionType(self.FloorInsulationCondition)
        elif nodeName_ == 'FloorRValue':
            obj_ = FloorRValueType.factory()
            obj_.build(child_)
            self.FloorRValue = obj_
            obj_.original_tagname_ = 'FloorRValue'
        elif nodeName_ == 'FloorUFactor':
            obj_ = FloorUFactorType.factory()
            obj_.build(child_)
            self.FloorUFactor = obj_
            obj_.original_tagname_ = 'FloorUFactor'
        elif nodeName_ == 'FloorFramingSpacing':
            obj_ = FloorFramingSpacingType.factory()
            obj_.build(child_)
            self.FloorFramingSpacing = obj_
            obj_.original_tagname_ = 'FloorFramingSpacing'
        elif nodeName_ == 'FloorFramingDepth':
            obj_ = FloorFramingDepthType.factory()
            obj_.build(child_)
            self.FloorFramingDepth = obj_
            obj_.original_tagname_ = 'FloorFramingDepth'
        elif nodeName_ == 'FloorFramingFactor':
            obj_ = FloorFramingFactorType.factory()
            obj_.build(child_)
            self.FloorFramingFactor = obj_
            obj_.original_tagname_ = 'FloorFramingFactor'
# end class VentedType


class FloorInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorInsulationThicknessType.subclass:
            return FloorInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return FloorInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorInsulationThicknessType


class FloorRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorRValueType.subclass:
            return FloorRValueType.subclass(*args_, **kwargs_)
        else:
            return FloorRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorRValueType


class FloorUFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorUFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorUFactorType.subclass:
            return FloorUFactorType.subclass(*args_, **kwargs_)
        else:
            return FloorUFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorUFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorUFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorUFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorUFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorUFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorUFactorType


class FloorFramingSpacingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorFramingSpacingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorFramingSpacingType.subclass:
            return FloorFramingSpacingType.subclass(*args_, **kwargs_)
        else:
            return FloorFramingSpacingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorFramingSpacingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorFramingSpacingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorFramingSpacingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorFramingSpacingType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorFramingSpacingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorFramingSpacingType


class FloorFramingDepthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorFramingDepthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorFramingDepthType.subclass:
            return FloorFramingDepthType.subclass(*args_, **kwargs_)
        else:
            return FloorFramingDepthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorFramingDepthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorFramingDepthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorFramingDepthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorFramingDepthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorFramingDepthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorFramingDepthType


class FloorFramingFactorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorFramingFactorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorFramingFactorType.subclass:
            return FloorFramingFactorType.subclass(*args_, **kwargs_)
        else:
            return FloorFramingFactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorFramingFactorType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorFramingFactorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorFramingFactorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorFramingFactorType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorFramingFactorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorFramingFactorType


class UnventedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FoundationWallConstruction=None, FoundationHeightAboveGrade=None, FoundationWallInsulationThickness=None, FoundationWallInsulationContinuity=None, FoundationWallInsulationCondition=None):
        self.original_tagname_ = None
        self.FoundationWallConstruction = FoundationWallConstruction
        self.validate_EnvelopeConstructionType(self.FoundationWallConstruction)
        self.FoundationHeightAboveGrade = FoundationHeightAboveGrade
        self.FoundationWallInsulationThickness = FoundationWallInsulationThickness
        self.FoundationWallInsulationContinuity = FoundationWallInsulationContinuity
        self.validate_FoundationWallInsulationContinuity(self.FoundationWallInsulationContinuity)
        self.FoundationWallInsulationCondition = FoundationWallInsulationCondition
        self.validate_FoundationWallInsulationCondition(self.FoundationWallInsulationCondition)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnventedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnventedType.subclass:
            return UnventedType.subclass(*args_, **kwargs_)
        else:
            return UnventedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnvelopeConstructionType(self, value):
        # Validate type EnvelopeConstructionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Masonry', 'Structural brick', 'Stone', 'Concrete masonry unit', 'Concrete-solid', 'Concrete-lightweight', 'Concrete-panels', 'Concrete-poured', 'Concrete-load bearing', 'Concrete-insulated forms', 'Concrete-aerated', 'Steel frame', 'Wood frame', 'Double wood frame', 'Structural insulated panel', 'Log-solid wood', 'Straw bale', 'Built-up', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeConstructionType' % {"value" : value.encode("utf-8")} )
    def validate_FoundationWallInsulationContinuity(self, value):
        # Validate type FoundationWallInsulationContinuity, a restriction on xs:string.
        pass
    def validate_FoundationWallInsulationCondition(self, value):
        # Validate type FoundationWallInsulationCondition, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.FoundationWallConstruction is not None or
            self.FoundationHeightAboveGrade is not None or
            self.FoundationWallInsulationThickness is not None or
            self.FoundationWallInsulationContinuity is not None or
            self.FoundationWallInsulationCondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UnventedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnventedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UnventedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UnventedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UnventedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FoundationWallConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallConstruction>%s</%sFoundationWallConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallConstruction), input_name='FoundationWallConstruction')), namespace_, eol_))
        if self.FoundationHeightAboveGrade is not None:
            self.FoundationHeightAboveGrade.export(outfile, level, namespace_, name_='FoundationHeightAboveGrade', pretty_print=pretty_print)
        if self.FoundationWallInsulationThickness is not None:
            self.FoundationWallInsulationThickness.export(outfile, level, namespace_, name_='FoundationWallInsulationThickness', pretty_print=pretty_print)
        if self.FoundationWallInsulationContinuity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallInsulationContinuity>%s</%sFoundationWallInsulationContinuity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallInsulationContinuity), input_name='FoundationWallInsulationContinuity')), namespace_, eol_))
        if self.FoundationWallInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallInsulationCondition>%s</%sFoundationWallInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallInsulationCondition), input_name='FoundationWallInsulationCondition')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FoundationWallConstruction':
            FoundationWallConstruction_ = child_.text
            FoundationWallConstruction_ = self.gds_validate_string(FoundationWallConstruction_, node, 'FoundationWallConstruction')
            self.FoundationWallConstruction = FoundationWallConstruction_
            # validate type EnvelopeConstructionType
            self.validate_EnvelopeConstructionType(self.FoundationWallConstruction)
        elif nodeName_ == 'FoundationHeightAboveGrade':
            obj_ = FoundationHeightAboveGradeType.factory()
            obj_.build(child_)
            self.FoundationHeightAboveGrade = obj_
            obj_.original_tagname_ = 'FoundationHeightAboveGrade'
        elif nodeName_ == 'FoundationWallInsulationThickness':
            obj_ = FoundationWallInsulationThicknessType.factory()
            obj_.build(child_)
            self.FoundationWallInsulationThickness = obj_
            obj_.original_tagname_ = 'FoundationWallInsulationThickness'
        elif nodeName_ == 'FoundationWallInsulationContinuity':
            FoundationWallInsulationContinuity_ = child_.text
            FoundationWallInsulationContinuity_ = self.gds_validate_string(FoundationWallInsulationContinuity_, node, 'FoundationWallInsulationContinuity')
            self.FoundationWallInsulationContinuity = FoundationWallInsulationContinuity_
            # validate type FoundationWallInsulationContinuity
            self.validate_FoundationWallInsulationContinuity(self.FoundationWallInsulationContinuity)
        elif nodeName_ == 'FoundationWallInsulationCondition':
            FoundationWallInsulationCondition_ = child_.text
            FoundationWallInsulationCondition_ = self.gds_validate_string(FoundationWallInsulationCondition_, node, 'FoundationWallInsulationCondition')
            self.FoundationWallInsulationCondition = FoundationWallInsulationCondition_
            # validate type FoundationWallInsulationCondition
            self.validate_FoundationWallInsulationCondition(self.FoundationWallInsulationCondition)
# end class UnventedType


class FoundationHeightAboveGradeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationHeightAboveGradeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationHeightAboveGradeType.subclass:
            return FoundationHeightAboveGradeType.subclass(*args_, **kwargs_)
        else:
            return FoundationHeightAboveGradeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationHeightAboveGradeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationHeightAboveGradeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationHeightAboveGradeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationHeightAboveGradeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationHeightAboveGradeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationHeightAboveGradeType


class FoundationWallInsulationThicknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationWallInsulationThicknessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationWallInsulationThicknessType.subclass:
            return FoundationWallInsulationThicknessType.subclass(*args_, **kwargs_)
        else:
            return FoundationWallInsulationThicknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationThicknessType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationWallInsulationThicknessType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationWallInsulationThicknessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationWallInsulationThicknessType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationThicknessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationWallInsulationThicknessType


class BasementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BasementConditioning=None, FoundationWallConstruction=None, FoundationHeightAboveGrade=None, FoundationWallRValue=None, FoundationWallInsulationThickness=None, FoundationWallInsulationContinuity=None, FoundationWallInsulationCondition=None, SlabInsulationOrientation=None, SlabArea=None, SlabPerimeter=None, SlabExposedPerimeter=None, SlabInsulationThickness=None, SlabInsulationCondition=None, SlabHeating=None):
        self.original_tagname_ = None
        self.BasementConditioning = BasementConditioning
        self.validate_BasementConditioningType(self.BasementConditioning)
        self.FoundationWallConstruction = FoundationWallConstruction
        self.validate_EnvelopeConstructionType(self.FoundationWallConstruction)
        self.FoundationHeightAboveGrade = FoundationHeightAboveGrade
        self.FoundationWallRValue = FoundationWallRValue
        self.FoundationWallInsulationThickness = FoundationWallInsulationThickness
        self.FoundationWallInsulationContinuity = FoundationWallInsulationContinuity
        self.validate_FoundationWallInsulationContinuity(self.FoundationWallInsulationContinuity)
        self.FoundationWallInsulationCondition = FoundationWallInsulationCondition
        self.validate_FoundationWallInsulationCondition(self.FoundationWallInsulationCondition)
        self.SlabInsulationOrientation = SlabInsulationOrientation
        self.validate_SlabInsulationOrientation(self.SlabInsulationOrientation)
        self.SlabArea = SlabArea
        self.SlabPerimeter = SlabPerimeter
        self.SlabExposedPerimeter = SlabExposedPerimeter
        self.SlabInsulationThickness = SlabInsulationThickness
        self.SlabInsulationCondition = SlabInsulationCondition
        self.validate_SlabInsulationCondition(self.SlabInsulationCondition)
        self.SlabHeating = SlabHeating
        self.validate_SlabHeating(self.SlabHeating)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasementType.subclass:
            return BasementType.subclass(*args_, **kwargs_)
        else:
            return BasementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_BasementConditioningType(self, value):
        # Validate type BasementConditioningType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Conditioned Basement', 'Unconditioned Basement', 'Half Conditioned Basement', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BasementConditioningType' % {"value" : value.encode("utf-8")} )
    def validate_EnvelopeConstructionType(self, value):
        # Validate type EnvelopeConstructionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Masonry', 'Structural brick', 'Stone', 'Concrete masonry unit', 'Concrete-solid', 'Concrete-lightweight', 'Concrete-panels', 'Concrete-poured', 'Concrete-load bearing', 'Concrete-insulated forms', 'Concrete-aerated', 'Steel frame', 'Wood frame', 'Double wood frame', 'Structural insulated panel', 'Log-solid wood', 'Straw bale', 'Built-up', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeConstructionType' % {"value" : value.encode("utf-8")} )
    def validate_FoundationWallInsulationContinuity(self, value):
        # Validate type FoundationWallInsulationContinuity, a restriction on xs:string.
        pass
    def validate_FoundationWallInsulationCondition(self, value):
        # Validate type FoundationWallInsulationCondition, a restriction on xs:string.
        pass
    def validate_SlabInsulationOrientation(self, value):
        # Validate type SlabInsulationOrientation, a restriction on xs:string.
        pass
    def validate_SlabInsulationCondition(self, value):
        # Validate type SlabInsulationCondition, a restriction on xs:string.
        pass
    def validate_SlabHeating(self, value):
        # Validate type SlabHeating, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.BasementConditioning is not None or
            self.FoundationWallConstruction is not None or
            self.FoundationHeightAboveGrade is not None or
            self.FoundationWallRValue is not None or
            self.FoundationWallInsulationThickness is not None or
            self.FoundationWallInsulationContinuity is not None or
            self.FoundationWallInsulationCondition is not None or
            self.SlabInsulationOrientation is not None or
            self.SlabArea is not None or
            self.SlabPerimeter is not None or
            self.SlabExposedPerimeter is not None or
            self.SlabInsulationThickness is not None or
            self.SlabInsulationCondition is not None or
            self.SlabHeating is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BasementType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BasementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BasementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BasementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BasementConditioning is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBasementConditioning>%s</%sBasementConditioning>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.BasementConditioning), input_name='BasementConditioning')), namespace_, eol_))
        if self.FoundationWallConstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallConstruction>%s</%sFoundationWallConstruction>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallConstruction), input_name='FoundationWallConstruction')), namespace_, eol_))
        if self.FoundationHeightAboveGrade is not None:
            self.FoundationHeightAboveGrade.export(outfile, level, namespace_, name_='FoundationHeightAboveGrade', pretty_print=pretty_print)
        if self.FoundationWallRValue is not None:
            self.FoundationWallRValue.export(outfile, level, namespace_, name_='FoundationWallRValue', pretty_print=pretty_print)
        if self.FoundationWallInsulationThickness is not None:
            self.FoundationWallInsulationThickness.export(outfile, level, namespace_, name_='FoundationWallInsulationThickness', pretty_print=pretty_print)
        if self.FoundationWallInsulationContinuity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallInsulationContinuity>%s</%sFoundationWallInsulationContinuity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallInsulationContinuity), input_name='FoundationWallInsulationContinuity')), namespace_, eol_))
        if self.FoundationWallInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoundationWallInsulationCondition>%s</%sFoundationWallInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FoundationWallInsulationCondition), input_name='FoundationWallInsulationCondition')), namespace_, eol_))
        if self.SlabInsulationOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabInsulationOrientation>%s</%sSlabInsulationOrientation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabInsulationOrientation), input_name='SlabInsulationOrientation')), namespace_, eol_))
        if self.SlabArea is not None:
            self.SlabArea.export(outfile, level, namespace_, name_='SlabArea', pretty_print=pretty_print)
        if self.SlabPerimeter is not None:
            self.SlabPerimeter.export(outfile, level, namespace_, name_='SlabPerimeter', pretty_print=pretty_print)
        if self.SlabExposedPerimeter is not None:
            self.SlabExposedPerimeter.export(outfile, level, namespace_, name_='SlabExposedPerimeter', pretty_print=pretty_print)
        if self.SlabInsulationThickness is not None:
            self.SlabInsulationThickness.export(outfile, level, namespace_, name_='SlabInsulationThickness', pretty_print=pretty_print)
        if self.SlabInsulationCondition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabInsulationCondition>%s</%sSlabInsulationCondition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabInsulationCondition), input_name='SlabInsulationCondition')), namespace_, eol_))
        if self.SlabHeating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSlabHeating>%s</%sSlabHeating>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SlabHeating), input_name='SlabHeating')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BasementConditioning':
            BasementConditioning_ = child_.text
            BasementConditioning_ = self.gds_validate_string(BasementConditioning_, node, 'BasementConditioning')
            self.BasementConditioning = BasementConditioning_
            # validate type BasementConditioningType
            self.validate_BasementConditioningType(self.BasementConditioning)
        elif nodeName_ == 'FoundationWallConstruction':
            FoundationWallConstruction_ = child_.text
            FoundationWallConstruction_ = self.gds_validate_string(FoundationWallConstruction_, node, 'FoundationWallConstruction')
            self.FoundationWallConstruction = FoundationWallConstruction_
            # validate type EnvelopeConstructionType
            self.validate_EnvelopeConstructionType(self.FoundationWallConstruction)
        elif nodeName_ == 'FoundationHeightAboveGrade':
            obj_ = FoundationHeightAboveGradeType190.factory()
            obj_.build(child_)
            self.FoundationHeightAboveGrade = obj_
            obj_.original_tagname_ = 'FoundationHeightAboveGrade'
        elif nodeName_ == 'FoundationWallRValue':
            obj_ = FoundationWallRValueType.factory()
            obj_.build(child_)
            self.FoundationWallRValue = obj_
            obj_.original_tagname_ = 'FoundationWallRValue'
        elif nodeName_ == 'FoundationWallInsulationThickness':
            obj_ = FoundationWallInsulationThicknessType191.factory()
            obj_.build(child_)
            self.FoundationWallInsulationThickness = obj_
            obj_.original_tagname_ = 'FoundationWallInsulationThickness'
        elif nodeName_ == 'FoundationWallInsulationContinuity':
            FoundationWallInsulationContinuity_ = child_.text
            FoundationWallInsulationContinuity_ = self.gds_validate_string(FoundationWallInsulationContinuity_, node, 'FoundationWallInsulationContinuity')
            self.FoundationWallInsulationContinuity = FoundationWallInsulationContinuity_
            # validate type FoundationWallInsulationContinuity
            self.validate_FoundationWallInsulationContinuity(self.FoundationWallInsulationContinuity)
        elif nodeName_ == 'FoundationWallInsulationCondition':
            FoundationWallInsulationCondition_ = child_.text
            FoundationWallInsulationCondition_ = self.gds_validate_string(FoundationWallInsulationCondition_, node, 'FoundationWallInsulationCondition')
            self.FoundationWallInsulationCondition = FoundationWallInsulationCondition_
            # validate type FoundationWallInsulationCondition
            self.validate_FoundationWallInsulationCondition(self.FoundationWallInsulationCondition)
        elif nodeName_ == 'SlabInsulationOrientation':
            SlabInsulationOrientation_ = child_.text
            SlabInsulationOrientation_ = self.gds_validate_string(SlabInsulationOrientation_, node, 'SlabInsulationOrientation')
            self.SlabInsulationOrientation = SlabInsulationOrientation_
            # validate type SlabInsulationOrientation
            self.validate_SlabInsulationOrientation(self.SlabInsulationOrientation)
        elif nodeName_ == 'SlabArea':
            obj_ = SlabAreaType192.factory()
            obj_.build(child_)
            self.SlabArea = obj_
            obj_.original_tagname_ = 'SlabArea'
        elif nodeName_ == 'SlabPerimeter':
            obj_ = SlabPerimeterType193.factory()
            obj_.build(child_)
            self.SlabPerimeter = obj_
            obj_.original_tagname_ = 'SlabPerimeter'
        elif nodeName_ == 'SlabExposedPerimeter':
            obj_ = SlabExposedPerimeterType194.factory()
            obj_.build(child_)
            self.SlabExposedPerimeter = obj_
            obj_.original_tagname_ = 'SlabExposedPerimeter'
        elif nodeName_ == 'SlabInsulationThickness':
            obj_ = SlabInsulationThicknessType195.factory()
            obj_.build(child_)
            self.SlabInsulationThickness = obj_
            obj_.original_tagname_ = 'SlabInsulationThickness'
        elif nodeName_ == 'SlabInsulationCondition':
            SlabInsulationCondition_ = child_.text
            SlabInsulationCondition_ = self.gds_validate_string(SlabInsulationCondition_, node, 'SlabInsulationCondition')
            self.SlabInsulationCondition = SlabInsulationCondition_
            # validate type SlabInsulationCondition
            self.validate_SlabInsulationCondition(self.SlabInsulationCondition)
        elif nodeName_ == 'SlabHeating':
            SlabHeating_ = child_.text
            SlabHeating_ = self.gds_validate_string(SlabHeating_, node, 'SlabHeating')
            self.SlabHeating = SlabHeating_
            # validate type SlabHeating
            self.validate_SlabHeating(self.SlabHeating)
# end class BasementType


class FoundationHeightAboveGradeType190(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationHeightAboveGradeType190)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationHeightAboveGradeType190.subclass:
            return FoundationHeightAboveGradeType190.subclass(*args_, **kwargs_)
        else:
            return FoundationHeightAboveGradeType190(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationHeightAboveGradeType190', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationHeightAboveGradeType190')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationHeightAboveGradeType190', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationHeightAboveGradeType190'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationHeightAboveGradeType190', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationHeightAboveGradeType190


class FoundationWallRValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationWallRValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationWallRValueType.subclass:
            return FoundationWallRValueType.subclass(*args_, **kwargs_)
        else:
            return FoundationWallRValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationWallRValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationWallRValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationWallRValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationWallRValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationWallRValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationWallRValueType


class FoundationWallInsulationThicknessType191(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FoundationWallInsulationThicknessType191)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FoundationWallInsulationThicknessType191.subclass:
            return FoundationWallInsulationThicknessType191.subclass(*args_, **kwargs_)
        else:
            return FoundationWallInsulationThicknessType191(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationThicknessType191', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FoundationWallInsulationThicknessType191')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FoundationWallInsulationThicknessType191', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FoundationWallInsulationThicknessType191'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FoundationWallInsulationThicknessType191', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FoundationWallInsulationThicknessType191


class SlabAreaType192(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabAreaType192)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabAreaType192.subclass:
            return SlabAreaType192.subclass(*args_, **kwargs_)
        else:
            return SlabAreaType192(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabAreaType192', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabAreaType192')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabAreaType192', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabAreaType192'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabAreaType192', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabAreaType192


class SlabPerimeterType193(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabPerimeterType193)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabPerimeterType193.subclass:
            return SlabPerimeterType193.subclass(*args_, **kwargs_)
        else:
            return SlabPerimeterType193(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabPerimeterType193', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabPerimeterType193')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabPerimeterType193', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabPerimeterType193'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabPerimeterType193', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabPerimeterType193


class SlabExposedPerimeterType194(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabExposedPerimeterType194)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabExposedPerimeterType194.subclass:
            return SlabExposedPerimeterType194.subclass(*args_, **kwargs_)
        else:
            return SlabExposedPerimeterType194(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabExposedPerimeterType194', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabExposedPerimeterType194')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabExposedPerimeterType194', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabExposedPerimeterType194'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabExposedPerimeterType194', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabExposedPerimeterType194


class SlabInsulationThicknessType195(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SlabInsulationThicknessType195)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SlabInsulationThicknessType195.subclass:
            return SlabInsulationThicknessType195.subclass(*args_, **kwargs_)
        else:
            return SlabInsulationThicknessType195(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SlabInsulationThicknessType195', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SlabInsulationThicknessType195')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SlabInsulationThicknessType195', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SlabInsulationThicknessType195'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SlabInsulationThicknessType195', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SlabInsulationThicknessType195


class ITPeakPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITPeakPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITPeakPowerType.subclass:
            return ITPeakPowerType.subclass(*args_, **kwargs_)
        else:
            return ITPeakPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ITPeakPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ITPeakPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ITPeakPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ITPeakPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ITPeakPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ITPeakPowerType


class ITStandbyPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITStandbyPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITStandbyPowerType.subclass:
            return ITStandbyPowerType.subclass(*args_, **kwargs_)
        else:
            return ITStandbyPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ITStandbyPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ITStandbyPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ITStandbyPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ITStandbyPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ITStandbyPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ITStandbyPowerType


class ITNominalPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ITNominalPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ITNominalPowerType.subclass:
            return ITNominalPowerType.subclass(*args_, **kwargs_)
        else:
            return ITNominalPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ITNominalPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ITNominalPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ITNominalPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ITNominalPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ITNominalPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ITNominalPowerType


class PlugLoadPeakPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadPeakPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadPeakPowerType.subclass:
            return PlugLoadPeakPowerType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadPeakPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadPeakPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadPeakPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadPeakPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadPeakPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadPeakPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlugLoadPeakPowerType


class PlugLoadStandbyPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadStandbyPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadStandbyPowerType.subclass:
            return PlugLoadStandbyPowerType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadStandbyPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadStandbyPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadStandbyPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadStandbyPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadStandbyPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadStandbyPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlugLoadStandbyPowerType


class PlugLoadNominalPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlugLoadNominalPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlugLoadNominalPowerType.subclass:
            return PlugLoadNominalPowerType.subclass(*args_, **kwargs_)
        else:
            return PlugLoadNominalPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PlugLoadNominalPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlugLoadNominalPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PlugLoadNominalPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PlugLoadNominalPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PlugLoadNominalPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlugLoadNominalPowerType


class ProcessLoadPeakPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessLoadPeakPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessLoadPeakPowerType.subclass:
            return ProcessLoadPeakPowerType.subclass(*args_, **kwargs_)
        else:
            return ProcessLoadPeakPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ProcessLoadPeakPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessLoadPeakPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ProcessLoadPeakPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ProcessLoadPeakPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ProcessLoadPeakPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProcessLoadPeakPowerType


class ProcessLoadStandbyPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessLoadStandbyPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessLoadStandbyPowerType.subclass:
            return ProcessLoadStandbyPowerType.subclass(*args_, **kwargs_)
        else:
            return ProcessLoadStandbyPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ProcessLoadStandbyPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessLoadStandbyPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ProcessLoadStandbyPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ProcessLoadStandbyPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ProcessLoadStandbyPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProcessLoadStandbyPowerType


class HeatGainFractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatGainFractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatGainFractionType.subclass:
            return HeatGainFractionType.subclass(*args_, **kwargs_)
        else:
            return HeatGainFractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatGainFractionType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatGainFractionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatGainFractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatGainFractionType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatGainFractionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeatGainFractionType


class DutyCycleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DutyCycleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DutyCycleType.subclass:
            return DutyCycleType.subclass(*args_, **kwargs_)
        else:
            return DutyCycleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DutyCycleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DutyCycleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DutyCycleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DutyCycleType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DutyCycleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DutyCycleType


class ConveyancePeakPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConveyancePeakPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConveyancePeakPowerType.subclass:
            return ConveyancePeakPowerType.subclass(*args_, **kwargs_)
        else:
            return ConveyancePeakPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConveyancePeakPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConveyancePeakPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConveyancePeakPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConveyancePeakPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConveyancePeakPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConveyancePeakPowerType


class ConveyanceStandbyPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConveyanceStandbyPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConveyanceStandbyPowerType.subclass:
            return ConveyanceStandbyPowerType.subclass(*args_, **kwargs_)
        else:
            return ConveyanceStandbyPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ConveyanceStandbyPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConveyanceStandbyPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ConveyanceStandbyPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ConveyanceStandbyPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ConveyanceStandbyPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConveyanceStandbyPowerType


class EnergyConversionTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Storage=None, Generation=None):
        self.original_tagname_ = None
        self.Storage = Storage
        self.Generation = Generation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyConversionTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyConversionTypeType.subclass:
            return EnergyConversionTypeType.subclass(*args_, **kwargs_)
        else:
            return EnergyConversionTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Storage is not None or
            self.Generation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyConversionTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyConversionTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyConversionTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyConversionTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyConversionTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Storage is not None:
            self.Storage.export(outfile, level, namespace_, name_='Storage', pretty_print=pretty_print)
        if self.Generation is not None:
            self.Generation.export(outfile, level, namespace_, name_='Generation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Storage':
            obj_ = StorageType.factory()
            obj_.build(child_)
            self.Storage = obj_
            obj_.original_tagname_ = 'Storage'
        elif nodeName_ == 'Generation':
            obj_ = GenerationType.factory()
            obj_.build(child_)
            self.Generation = obj_
            obj_.original_tagname_ = 'Generation'
# end class EnergyConversionTypeType


class StorageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyStorageTechnology=None, ThermalMedium=None):
        self.original_tagname_ = None
        self.EnergyStorageTechnology = EnergyStorageTechnology
        self.validate_EnergyStorageTechnologyType(self.EnergyStorageTechnology)
        self.ThermalMedium = ThermalMedium
        self.validate_ThermalMediumType(self.ThermalMedium)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageType.subclass:
            return StorageType.subclass(*args_, **kwargs_)
        else:
            return StorageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EnergyStorageTechnologyType(self, value):
        # Validate type EnergyStorageTechnologyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Battery', 'Thermal Energy Storage (TES)', 'Pumped-Storage Hydroelectricity (PSH)', 'Fly wheel', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnergyStorageTechnologyType' % {"value" : value.encode("utf-8")} )
    def validate_ThermalMediumType(self, value):
        # Validate type ThermalMediumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Air', 'Ice', 'Pool water', 'Domestic water', 'Molten salt', 'Sand', 'Rock', 'Chemical oxides', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThermalMediumType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EnergyStorageTechnology is not None or
            self.ThermalMedium is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StorageType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StorageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StorageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StorageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyStorageTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergyStorageTechnology>%s</%sEnergyStorageTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnergyStorageTechnology), input_name='EnergyStorageTechnology')), namespace_, eol_))
        if self.ThermalMedium is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThermalMedium>%s</%sThermalMedium>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ThermalMedium), input_name='ThermalMedium')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyStorageTechnology':
            EnergyStorageTechnology_ = child_.text
            EnergyStorageTechnology_ = self.gds_validate_string(EnergyStorageTechnology_, node, 'EnergyStorageTechnology')
            self.EnergyStorageTechnology = EnergyStorageTechnology_
            # validate type EnergyStorageTechnologyType
            self.validate_EnergyStorageTechnologyType(self.EnergyStorageTechnology)
        elif nodeName_ == 'ThermalMedium':
            ThermalMedium_ = child_.text
            ThermalMedium_ = self.gds_validate_string(ThermalMedium_, node, 'ThermalMedium')
            self.ThermalMedium = ThermalMedium_
            # validate type ThermalMediumType
            self.validate_ThermalMediumType(self.ThermalMedium)
# end class StorageType


class GenerationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OnSiteGenerationType=None, ExternalPowerSupply=None):
        self.original_tagname_ = None
        self.OnSiteGenerationType = OnSiteGenerationType
        self.ExternalPowerSupply = ExternalPowerSupply
        self.validate_ExternalPowerSupplyType(self.ExternalPowerSupply)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenerationType.subclass:
            return GenerationType.subclass(*args_, **kwargs_)
        else:
            return GenerationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_ExternalPowerSupplyType(self, value):
        # Validate type ExternalPowerSupplyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC-to-AC', 'AC-to-DC', 'Low Voltage', 'No-Load Mode', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExternalPowerSupplyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OnSiteGenerationType is not None or
            self.ExternalPowerSupply is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='GenerationType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenerationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='GenerationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='GenerationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='GenerationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OnSiteGenerationType is not None:
            self.OnSiteGenerationType.export(outfile, level, namespace_, name_='OnSiteGenerationType', pretty_print=pretty_print)
        if self.ExternalPowerSupply is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalPowerSupply>%s</%sExternalPowerSupply>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ExternalPowerSupply), input_name='ExternalPowerSupply')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OnSiteGenerationType':
            obj_ = OnSiteGenerationTypeType.factory()
            obj_.build(child_)
            self.OnSiteGenerationType = obj_
            obj_.original_tagname_ = 'OnSiteGenerationType'
        elif nodeName_ == 'ExternalPowerSupply':
            ExternalPowerSupply_ = child_.text
            ExternalPowerSupply_ = self.gds_validate_string(ExternalPowerSupply_, node, 'ExternalPowerSupply')
            self.ExternalPowerSupply = ExternalPowerSupply_
            # validate type ExternalPowerSupplyType
            self.validate_ExternalPowerSupplyType(self.ExternalPowerSupply)
# end class GenerationType


class OnSiteGenerationTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PV=None, Other=None):
        self.original_tagname_ = None
        self.PV = PV
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnSiteGenerationTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnSiteGenerationTypeType.subclass:
            return OnSiteGenerationTypeType.subclass(*args_, **kwargs_)
        else:
            return OnSiteGenerationTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.PV is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OnSiteGenerationTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OnSiteGenerationTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OnSiteGenerationTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OnSiteGenerationTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OnSiteGenerationTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PV is not None:
            self.PV.export(outfile, level, namespace_, name_='PV', pretty_print=pretty_print)
        if self.Other is not None:
            self.Other.export(outfile, level, namespace_, name_='Other', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PV':
            obj_ = PVType.factory()
            obj_.build(child_)
            self.PV = obj_
            obj_.original_tagname_ = 'PV'
        elif nodeName_ == 'Other':
            obj_ = OtherType196.factory()
            obj_.build(child_)
            self.Other = obj_
            obj_.original_tagname_ = 'Other'
# end class OnSiteGenerationTypeType


class PVType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PhotovoltaicSystemNumberOfModulesPerArray=None, PhotovoltaicSystemNumberOfArrays=None, PhotovoltaicSystemMaximumPowerOutput=None, PhotovoltaicSystemInverterEfficiency=None, PhotovoltaicSystemArrayAzimuth=None, PhotovoltaicSystemRackingSystemTiltAngleMin=None, PhotovoltaicSystemRackingSystemTiltAngleMax=None, PhotovoltaicSystemLocation=None, PhotovoltaicModuleRatedPower=None, PhotovoltaicModuleLength=None, PhotovoltaicModuleWidth=None):
        self.original_tagname_ = None
        self.PhotovoltaicSystemNumberOfModulesPerArray = PhotovoltaicSystemNumberOfModulesPerArray
        self.PhotovoltaicSystemNumberOfArrays = PhotovoltaicSystemNumberOfArrays
        self.PhotovoltaicSystemMaximumPowerOutput = PhotovoltaicSystemMaximumPowerOutput
        self.PhotovoltaicSystemInverterEfficiency = PhotovoltaicSystemInverterEfficiency
        self.PhotovoltaicSystemArrayAzimuth = PhotovoltaicSystemArrayAzimuth
        self.PhotovoltaicSystemRackingSystemTiltAngleMin = PhotovoltaicSystemRackingSystemTiltAngleMin
        self.PhotovoltaicSystemRackingSystemTiltAngleMax = PhotovoltaicSystemRackingSystemTiltAngleMax
        self.PhotovoltaicSystemLocation = PhotovoltaicSystemLocation
        self.validate_PhotovoltaicSystemLocationType(self.PhotovoltaicSystemLocation)
        self.PhotovoltaicModuleRatedPower = PhotovoltaicModuleRatedPower
        self.PhotovoltaicModuleLength = PhotovoltaicModuleLength
        self.PhotovoltaicModuleWidth = PhotovoltaicModuleWidth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PVType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PVType.subclass:
            return PVType.subclass(*args_, **kwargs_)
        else:
            return PVType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PhotovoltaicSystemLocationType(self, value):
        # Validate type PhotovoltaicSystemLocationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Roof', 'Ground', 'Building-integrated', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhotovoltaicSystemLocationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PhotovoltaicSystemNumberOfModulesPerArray is not None or
            self.PhotovoltaicSystemNumberOfArrays is not None or
            self.PhotovoltaicSystemMaximumPowerOutput is not None or
            self.PhotovoltaicSystemInverterEfficiency is not None or
            self.PhotovoltaicSystemArrayAzimuth is not None or
            self.PhotovoltaicSystemRackingSystemTiltAngleMin is not None or
            self.PhotovoltaicSystemRackingSystemTiltAngleMax is not None or
            self.PhotovoltaicSystemLocation is not None or
            self.PhotovoltaicModuleRatedPower is not None or
            self.PhotovoltaicModuleLength is not None or
            self.PhotovoltaicModuleWidth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PVType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PVType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PVType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PVType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PVType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhotovoltaicSystemNumberOfModulesPerArray is not None:
            self.PhotovoltaicSystemNumberOfModulesPerArray.export(outfile, level, namespace_, name_='PhotovoltaicSystemNumberOfModulesPerArray', pretty_print=pretty_print)
        if self.PhotovoltaicSystemNumberOfArrays is not None:
            self.PhotovoltaicSystemNumberOfArrays.export(outfile, level, namespace_, name_='PhotovoltaicSystemNumberOfArrays', pretty_print=pretty_print)
        if self.PhotovoltaicSystemMaximumPowerOutput is not None:
            self.PhotovoltaicSystemMaximumPowerOutput.export(outfile, level, namespace_, name_='PhotovoltaicSystemMaximumPowerOutput', pretty_print=pretty_print)
        if self.PhotovoltaicSystemInverterEfficiency is not None:
            self.PhotovoltaicSystemInverterEfficiency.export(outfile, level, namespace_, name_='PhotovoltaicSystemInverterEfficiency', pretty_print=pretty_print)
        if self.PhotovoltaicSystemArrayAzimuth is not None:
            self.PhotovoltaicSystemArrayAzimuth.export(outfile, level, namespace_, name_='PhotovoltaicSystemArrayAzimuth', pretty_print=pretty_print)
        if self.PhotovoltaicSystemRackingSystemTiltAngleMin is not None:
            self.PhotovoltaicSystemRackingSystemTiltAngleMin.export(outfile, level, namespace_, name_='PhotovoltaicSystemRackingSystemTiltAngleMin', pretty_print=pretty_print)
        if self.PhotovoltaicSystemRackingSystemTiltAngleMax is not None:
            self.PhotovoltaicSystemRackingSystemTiltAngleMax.export(outfile, level, namespace_, name_='PhotovoltaicSystemRackingSystemTiltAngleMax', pretty_print=pretty_print)
        if self.PhotovoltaicSystemLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhotovoltaicSystemLocation>%s</%sPhotovoltaicSystemLocation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PhotovoltaicSystemLocation), input_name='PhotovoltaicSystemLocation')), namespace_, eol_))
        if self.PhotovoltaicModuleRatedPower is not None:
            self.PhotovoltaicModuleRatedPower.export(outfile, level, namespace_, name_='PhotovoltaicModuleRatedPower', pretty_print=pretty_print)
        if self.PhotovoltaicModuleLength is not None:
            self.PhotovoltaicModuleLength.export(outfile, level, namespace_, name_='PhotovoltaicModuleLength', pretty_print=pretty_print)
        if self.PhotovoltaicModuleWidth is not None:
            self.PhotovoltaicModuleWidth.export(outfile, level, namespace_, name_='PhotovoltaicModuleWidth', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhotovoltaicSystemNumberOfModulesPerArray':
            obj_ = PhotovoltaicSystemNumberOfModulesPerArrayType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemNumberOfModulesPerArray = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemNumberOfModulesPerArray'
        elif nodeName_ == 'PhotovoltaicSystemNumberOfArrays':
            obj_ = PhotovoltaicSystemNumberOfArraysType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemNumberOfArrays = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemNumberOfArrays'
        elif nodeName_ == 'PhotovoltaicSystemMaximumPowerOutput':
            obj_ = PhotovoltaicSystemMaximumPowerOutputType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemMaximumPowerOutput = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemMaximumPowerOutput'
        elif nodeName_ == 'PhotovoltaicSystemInverterEfficiency':
            obj_ = PhotovoltaicSystemInverterEfficiencyType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemInverterEfficiency = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemInverterEfficiency'
        elif nodeName_ == 'PhotovoltaicSystemArrayAzimuth':
            obj_ = PhotovoltaicSystemArrayAzimuthType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemArrayAzimuth = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemArrayAzimuth'
        elif nodeName_ == 'PhotovoltaicSystemRackingSystemTiltAngleMin':
            obj_ = PhotovoltaicSystemRackingSystemTiltAngleMinType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemRackingSystemTiltAngleMin = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemRackingSystemTiltAngleMin'
        elif nodeName_ == 'PhotovoltaicSystemRackingSystemTiltAngleMax':
            obj_ = PhotovoltaicSystemRackingSystemTiltAngleMaxType.factory()
            obj_.build(child_)
            self.PhotovoltaicSystemRackingSystemTiltAngleMax = obj_
            obj_.original_tagname_ = 'PhotovoltaicSystemRackingSystemTiltAngleMax'
        elif nodeName_ == 'PhotovoltaicSystemLocation':
            PhotovoltaicSystemLocation_ = child_.text
            PhotovoltaicSystemLocation_ = self.gds_validate_string(PhotovoltaicSystemLocation_, node, 'PhotovoltaicSystemLocation')
            self.PhotovoltaicSystemLocation = PhotovoltaicSystemLocation_
            # validate type PhotovoltaicSystemLocationType
            self.validate_PhotovoltaicSystemLocationType(self.PhotovoltaicSystemLocation)
        elif nodeName_ == 'PhotovoltaicModuleRatedPower':
            obj_ = PhotovoltaicModuleRatedPowerType.factory()
            obj_.build(child_)
            self.PhotovoltaicModuleRatedPower = obj_
            obj_.original_tagname_ = 'PhotovoltaicModuleRatedPower'
        elif nodeName_ == 'PhotovoltaicModuleLength':
            obj_ = PhotovoltaicModuleLengthType.factory()
            obj_.build(child_)
            self.PhotovoltaicModuleLength = obj_
            obj_.original_tagname_ = 'PhotovoltaicModuleLength'
        elif nodeName_ == 'PhotovoltaicModuleWidth':
            obj_ = PhotovoltaicModuleWidthType.factory()
            obj_.build(child_)
            self.PhotovoltaicModuleWidth = obj_
            obj_.original_tagname_ = 'PhotovoltaicModuleWidth'
# end class PVType


class PhotovoltaicSystemNumberOfModulesPerArrayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemNumberOfModulesPerArrayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemNumberOfModulesPerArrayType.subclass:
            return PhotovoltaicSystemNumberOfModulesPerArrayType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemNumberOfModulesPerArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemNumberOfModulesPerArrayType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemNumberOfModulesPerArrayType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemNumberOfModulesPerArrayType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemNumberOfModulesPerArrayType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemNumberOfModulesPerArrayType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemNumberOfModulesPerArrayType


class PhotovoltaicSystemNumberOfArraysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemNumberOfArraysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemNumberOfArraysType.subclass:
            return PhotovoltaicSystemNumberOfArraysType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemNumberOfArraysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemNumberOfArraysType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemNumberOfArraysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemNumberOfArraysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemNumberOfArraysType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemNumberOfArraysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemNumberOfArraysType


class PhotovoltaicSystemMaximumPowerOutputType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemMaximumPowerOutputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemMaximumPowerOutputType.subclass:
            return PhotovoltaicSystemMaximumPowerOutputType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemMaximumPowerOutputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemMaximumPowerOutputType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemMaximumPowerOutputType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemMaximumPowerOutputType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemMaximumPowerOutputType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemMaximumPowerOutputType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemMaximumPowerOutputType


class PhotovoltaicSystemInverterEfficiencyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemInverterEfficiencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemInverterEfficiencyType.subclass:
            return PhotovoltaicSystemInverterEfficiencyType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemInverterEfficiencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemInverterEfficiencyType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemInverterEfficiencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemInverterEfficiencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemInverterEfficiencyType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemInverterEfficiencyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemInverterEfficiencyType


class PhotovoltaicSystemArrayAzimuthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemArrayAzimuthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemArrayAzimuthType.subclass:
            return PhotovoltaicSystemArrayAzimuthType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemArrayAzimuthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemArrayAzimuthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemArrayAzimuthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemArrayAzimuthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemArrayAzimuthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemArrayAzimuthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemArrayAzimuthType


class PhotovoltaicSystemRackingSystemTiltAngleMinType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemRackingSystemTiltAngleMinType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemRackingSystemTiltAngleMinType.subclass:
            return PhotovoltaicSystemRackingSystemTiltAngleMinType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemRackingSystemTiltAngleMinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMinType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemRackingSystemTiltAngleMinType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMinType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMinType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMinType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemRackingSystemTiltAngleMinType


class PhotovoltaicSystemRackingSystemTiltAngleMaxType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicSystemRackingSystemTiltAngleMaxType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicSystemRackingSystemTiltAngleMaxType.subclass:
            return PhotovoltaicSystemRackingSystemTiltAngleMaxType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicSystemRackingSystemTiltAngleMaxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMaxType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicSystemRackingSystemTiltAngleMaxType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMaxType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMaxType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicSystemRackingSystemTiltAngleMaxType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicSystemRackingSystemTiltAngleMaxType


class PhotovoltaicModuleRatedPowerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicModuleRatedPowerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicModuleRatedPowerType.subclass:
            return PhotovoltaicModuleRatedPowerType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicModuleRatedPowerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleRatedPowerType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicModuleRatedPowerType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicModuleRatedPowerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicModuleRatedPowerType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleRatedPowerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicModuleRatedPowerType


class PhotovoltaicModuleLengthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicModuleLengthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicModuleLengthType.subclass:
            return PhotovoltaicModuleLengthType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicModuleLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleLengthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicModuleLengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicModuleLengthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicModuleLengthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleLengthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicModuleLengthType


class PhotovoltaicModuleWidthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotovoltaicModuleWidthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotovoltaicModuleWidthType.subclass:
            return PhotovoltaicModuleWidthType.subclass(*args_, **kwargs_)
        else:
            return PhotovoltaicModuleWidthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleWidthType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhotovoltaicModuleWidthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PhotovoltaicModuleWidthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PhotovoltaicModuleWidthType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PhotovoltaicModuleWidthType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhotovoltaicModuleWidthType


class OtherType196(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OtherEnergyGenerationTechnology=None, OutputResourceType=None):
        self.original_tagname_ = None
        self.OtherEnergyGenerationTechnology = OtherEnergyGenerationTechnology
        self.validate_OtherEnergyGenerationTechnologyType(self.OtherEnergyGenerationTechnology)
        self.OutputResourceType = OutputResourceType
        self.validate_FuelTypes(self.OutputResourceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherType196)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherType196.subclass:
            return OtherType196.subclass(*args_, **kwargs_)
        else:
            return OtherType196(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OtherEnergyGenerationTechnologyType(self, value):
        # Validate type OtherEnergyGenerationTechnologyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Standby generator', 'Turbine', 'Microturbine', 'Fuel cell', 'Gasification', 'Binary Cycle', 'Anaerobic biodigester', 'Hydrokinetic', 'Solar parabolic trough', 'Solar power tower', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OtherEnergyGenerationTechnologyType' % {"value" : value.encode("utf-8")} )
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherEnergyGenerationTechnology is not None or
            self.OutputResourceType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OtherType196', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtherType196')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OtherType196', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OtherType196'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OtherType196', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherEnergyGenerationTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherEnergyGenerationTechnology>%s</%sOtherEnergyGenerationTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OtherEnergyGenerationTechnology), input_name='OtherEnergyGenerationTechnology')), namespace_, eol_))
        if self.OutputResourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutputResourceType>%s</%sOutputResourceType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OutputResourceType), input_name='OutputResourceType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherEnergyGenerationTechnology':
            OtherEnergyGenerationTechnology_ = child_.text
            OtherEnergyGenerationTechnology_ = self.gds_validate_string(OtherEnergyGenerationTechnology_, node, 'OtherEnergyGenerationTechnology')
            self.OtherEnergyGenerationTechnology = OtherEnergyGenerationTechnology_
            # validate type OtherEnergyGenerationTechnologyType
            self.validate_OtherEnergyGenerationTechnologyType(self.OtherEnergyGenerationTechnology)
        elif nodeName_ == 'OutputResourceType':
            OutputResourceType_ = child_.text
            OutputResourceType_ = self.gds_validate_string(OutputResourceType_, node, 'OutputResourceType')
            self.OutputResourceType = OutputResourceType_
            # validate type FuelTypes
            self.validate_FuelTypes(self.OutputResourceType)
# end class OtherType196


class PoolAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoolAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoolAreaType.subclass:
            return PoolAreaType.subclass(*args_, **kwargs_)
        else:
            return PoolAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PoolAreaType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolAreaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PoolAreaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PoolAreaType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PoolAreaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PoolAreaType


class PoolVolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoolVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoolVolumeType.subclass:
            return PoolVolumeType.subclass(*args_, **kwargs_)
        else:
            return PoolVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PoolVolumeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolVolumeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PoolVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PoolVolumeType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PoolVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PoolVolumeType


class PumpDutyCycleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PumpDutyCycleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PumpDutyCycleType.subclass:
            return PumpDutyCycleType.subclass(*args_, **kwargs_)
        else:
            return PumpDutyCycleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='PumpDutyCycleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PumpDutyCycleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='PumpDutyCycleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='PumpDutyCycleType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='PumpDutyCycleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PumpDutyCycleType


class HeatedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, True=None, False=None):
        self.original_tagname_ = None
        self.True = True
        self.False = False
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatedType.subclass:
            return HeatedType.subclass(*args_, **kwargs_)
        else:
            return HeatedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.True is not None or
            self.False is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HeatedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeatedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HeatedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HeatedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HeatedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.True is not None:
            self.True.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFalse>%s</%sFalse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.False), input_name='False')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'True':
            obj_ = TrueType197.factory()
            obj_.build(child_)
            self.True = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            False_ = child_.text
            False_ = self.gds_validate_string(False_, node, 'False')
            self.False = False_
# end class HeatedType


class TrueType197(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PrimaryFuel=None, WaterTemperature=None, HoursUncovered=None, ControlTechnology=None):
        self.original_tagname_ = None
        self.PrimaryFuel = PrimaryFuel
        self.validate_FuelTypes(self.PrimaryFuel)
        self.WaterTemperature = WaterTemperature
        self.HoursUncovered = HoursUncovered
        self.ControlTechnology = ControlTechnology
        self.validate_ControlTechnology(self.ControlTechnology)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrueType197)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrueType197.subclass:
            return TrueType197.subclass(*args_, **kwargs_)
        else:
            return TrueType197(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FuelTypes(self, value):
        # Validate type FuelTypes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Electricity', 'Natural gas', 'Fuel oil', 'Fuel oil No-1', 'Fuel oil No-2', 'Fuel oil No-4', 'Fuel oil No-5 and No-6', 'District steam', 'District hot water', 'District chilled water', 'Propane', 'Liquid propane', 'Kerosene', 'Diesel', 'Coal', 'Coal (anthracite)', 'Coal (bituminous)', 'Coke', 'Wood', 'Wood pellets', 'Hydropower', 'Biofuel', 'Wind', 'Geothermal', 'Solar', 'Biomass', 'Hydrothermal', 'Dry steam', 'Flash steam', 'Ethanol', 'Biodiesel', 'Waste heat', 'Combination', 'Other', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FuelTypes' % {"value" : value.encode("utf-8")} )
    def validate_ControlTechnology(self, value):
        # Validate type ControlTechnology, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.PrimaryFuel is not None or
            self.WaterTemperature is not None or
            self.HoursUncovered is not None or
            self.ControlTechnology is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TrueType197', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrueType197')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TrueType197', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TrueType197'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TrueType197', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrimaryFuel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryFuel>%s</%sPrimaryFuel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PrimaryFuel), input_name='PrimaryFuel')), namespace_, eol_))
        if self.WaterTemperature is not None:
            self.WaterTemperature.export(outfile, level, namespace_, name_='WaterTemperature', pretty_print=pretty_print)
        if self.HoursUncovered is not None:
            self.HoursUncovered.export(outfile, level, namespace_, name_='HoursUncovered', pretty_print=pretty_print)
        if self.ControlTechnology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlTechnology>%s</%sControlTechnology>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ControlTechnology), input_name='ControlTechnology')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimaryFuel':
            PrimaryFuel_ = child_.text
            PrimaryFuel_ = self.gds_validate_string(PrimaryFuel_, node, 'PrimaryFuel')
            self.PrimaryFuel = PrimaryFuel_
            # validate type FuelTypes
            self.validate_FuelTypes(self.PrimaryFuel)
        elif nodeName_ == 'WaterTemperature':
            obj_ = WaterTemperatureType.factory()
            obj_.build(child_)
            self.WaterTemperature = obj_
            obj_.original_tagname_ = 'WaterTemperature'
        elif nodeName_ == 'HoursUncovered':
            obj_ = HoursUncoveredType.factory()
            obj_.build(child_)
            self.HoursUncovered = obj_
            obj_.original_tagname_ = 'HoursUncovered'
        elif nodeName_ == 'ControlTechnology':
            ControlTechnology_ = child_.text
            ControlTechnology_ = self.gds_validate_string(ControlTechnology_, node, 'ControlTechnology')
            self.ControlTechnology = ControlTechnology_
            # validate type ControlTechnology
            self.validate_ControlTechnology(self.ControlTechnology)
# end class TrueType197


class WaterTemperatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterTemperatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterTemperatureType.subclass:
            return WaterTemperatureType.subclass(*args_, **kwargs_)
        else:
            return WaterTemperatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterTemperatureType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterTemperatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterTemperatureType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterTemperatureType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterTemperatureType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterTemperatureType


class HoursUncoveredType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HoursUncoveredType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HoursUncoveredType.subclass:
            return HoursUncoveredType.subclass(*args_, **kwargs_)
        else:
            return HoursUncoveredType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='HoursUncoveredType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HoursUncoveredType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='HoursUncoveredType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='HoursUncoveredType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='HoursUncoveredType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HoursUncoveredType


class WaterFixtureRatedFlowRateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterFixtureRatedFlowRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterFixtureRatedFlowRateType.subclass:
            return WaterFixtureRatedFlowRateType.subclass(*args_, **kwargs_)
        else:
            return WaterFixtureRatedFlowRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterFixtureRatedFlowRateType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterFixtureRatedFlowRateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterFixtureRatedFlowRateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterFixtureRatedFlowRateType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterFixtureRatedFlowRateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterFixtureRatedFlowRateType


class WaterFixtureVolumePerCycleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterFixtureVolumePerCycleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterFixtureVolumePerCycleType.subclass:
            return WaterFixtureVolumePerCycleType.subclass(*args_, **kwargs_)
        else:
            return WaterFixtureVolumePerCycleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterFixtureVolumePerCycleType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterFixtureVolumePerCycleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterFixtureVolumePerCycleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterFixtureVolumePerCycleType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterFixtureVolumePerCycleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterFixtureVolumePerCycleType


class WaterFixtureCyclesPerDayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterFixtureCyclesPerDayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterFixtureCyclesPerDayType.subclass:
            return WaterFixtureCyclesPerDayType.subclass(*args_, **kwargs_)
        else:
            return WaterFixtureCyclesPerDayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterFixtureCyclesPerDayType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterFixtureCyclesPerDayType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterFixtureCyclesPerDayType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterFixtureCyclesPerDayType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterFixtureCyclesPerDayType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterFixtureCyclesPerDayType


class WaterFixtureFractionHotWaterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterFixtureFractionHotWaterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterFixtureFractionHotWaterType.subclass:
            return WaterFixtureFractionHotWaterType.subclass(*args_, **kwargs_)
        else:
            return WaterFixtureFractionHotWaterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WaterFixtureFractionHotWaterType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WaterFixtureFractionHotWaterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WaterFixtureFractionHotWaterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WaterFixtureFractionHotWaterType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WaterFixtureFractionHotWaterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WaterFixtureFractionHotWaterType


class SimulatedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SoftwareProgramUsed=None, SoftwareProgramVersion=None):
        self.original_tagname_ = None
        self.SoftwareProgramUsed = SoftwareProgramUsed
        self.SoftwareProgramVersion = SoftwareProgramVersion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimulatedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimulatedType.subclass:
            return SimulatedType.subclass(*args_, **kwargs_)
        else:
            return SimulatedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.SoftwareProgramUsed is not None or
            self.SoftwareProgramVersion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimulatedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimulatedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimulatedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimulatedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimulatedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SoftwareProgramUsed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSoftwareProgramUsed>%s</%sSoftwareProgramUsed>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SoftwareProgramUsed), input_name='SoftwareProgramUsed')), namespace_, eol_))
        if self.SoftwareProgramVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSoftwareProgramVersion>%s</%sSoftwareProgramVersion>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SoftwareProgramVersion), input_name='SoftwareProgramVersion')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SoftwareProgramUsed':
            SoftwareProgramUsed_ = child_.text
            SoftwareProgramUsed_ = self.gds_validate_string(SoftwareProgramUsed_, node, 'SoftwareProgramUsed')
            self.SoftwareProgramUsed = SoftwareProgramUsed_
        elif nodeName_ == 'SoftwareProgramVersion':
            SoftwareProgramVersion_ = child_.text
            SoftwareProgramVersion_ = self.gds_validate_string(SoftwareProgramVersion_, node, 'SoftwareProgramVersion')
            self.SoftwareProgramVersion = SoftwareProgramVersion_
# end class SimulatedType


class MeasuredType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MeasuredEnergySource=None):
        self.original_tagname_ = None
        self.MeasuredEnergySource = MeasuredEnergySource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuredType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuredType.subclass:
            return MeasuredType.subclass(*args_, **kwargs_)
        else:
            return MeasuredType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.MeasuredEnergySource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasuredType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasuredType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasuredType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasuredType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasuredType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasuredEnergySource is not None:
            self.MeasuredEnergySource.export(outfile, level, namespace_, name_='MeasuredEnergySource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeasuredEnergySource':
            obj_ = MeasuredEnergySourceType.factory()
            obj_.build(child_)
            self.MeasuredEnergySource = obj_
            obj_.original_tagname_ = 'MeasuredEnergySource'
# end class MeasuredType


class MeasuredEnergySourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UtilityBills=None, DirectMeasurement=None, Other=None):
        self.original_tagname_ = None
        self.UtilityBills = UtilityBills
        self.DirectMeasurement = DirectMeasurement
        self.Other = Other
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuredEnergySourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuredEnergySourceType.subclass:
            return MeasuredEnergySourceType.subclass(*args_, **kwargs_)
        else:
            return MeasuredEnergySourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.UtilityBills is not None or
            self.DirectMeasurement is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='MeasuredEnergySourceType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasuredEnergySourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='MeasuredEnergySourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='MeasuredEnergySourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='MeasuredEnergySourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UtilityBills is not None:
            self.UtilityBills.export(outfile, level, namespace_, name_='UtilityBills', pretty_print=pretty_print)
        if self.DirectMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirectMeasurement>%s</%sDirectMeasurement>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.DirectMeasurement), input_name='DirectMeasurement')), namespace_, eol_))
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Other), input_name='Other')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UtilityBills':
            obj_ = UtilityBillsType.factory()
            obj_.build(child_)
            self.UtilityBills = obj_
            obj_.original_tagname_ = 'UtilityBills'
        elif nodeName_ == 'DirectMeasurement':
            DirectMeasurement_ = child_.text
            DirectMeasurement_ = self.gds_validate_string(DirectMeasurement_, node, 'DirectMeasurement')
            self.DirectMeasurement = DirectMeasurement_
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class MeasuredEnergySourceType


class DirectMeasurement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectMeasurement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectMeasurement.subclass:
            return DirectMeasurement.subclass(*args_, **kwargs_)
        else:
            return DirectMeasurement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='DirectMeasurement', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectMeasurement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='DirectMeasurement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='DirectMeasurement'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='DirectMeasurement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DirectMeasurement


class UtilityBillsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UtilityMeterNumber=None, UtilityAccountNumber=None, UtilityBillpayer=None):
        self.original_tagname_ = None
        self.UtilityMeterNumber = UtilityMeterNumber
        self.UtilityAccountNumber = UtilityAccountNumber
        self.UtilityBillpayer = UtilityBillpayer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UtilityBillsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UtilityBillsType.subclass:
            return UtilityBillsType.subclass(*args_, **kwargs_)
        else:
            return UtilityBillsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.UtilityMeterNumber is not None or
            self.UtilityAccountNumber is not None or
            self.UtilityBillpayer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UtilityBillsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UtilityBillsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UtilityBillsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UtilityBillsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UtilityBillsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UtilityMeterNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityMeterNumber>%s</%sUtilityMeterNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityMeterNumber), input_name='UtilityMeterNumber')), namespace_, eol_))
        if self.UtilityAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityAccountNumber>%s</%sUtilityAccountNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityAccountNumber), input_name='UtilityAccountNumber')), namespace_, eol_))
        if self.UtilityBillpayer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilityBillpayer>%s</%sUtilityBillpayer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UtilityBillpayer), input_name='UtilityBillpayer')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UtilityMeterNumber':
            UtilityMeterNumber_ = child_.text
            UtilityMeterNumber_ = self.gds_validate_string(UtilityMeterNumber_, node, 'UtilityMeterNumber')
            self.UtilityMeterNumber = UtilityMeterNumber_
        elif nodeName_ == 'UtilityAccountNumber':
            UtilityAccountNumber_ = child_.text
            UtilityAccountNumber_ = self.gds_validate_string(UtilityAccountNumber_, node, 'UtilityAccountNumber')
            self.UtilityAccountNumber = UtilityAccountNumber_
        elif nodeName_ == 'UtilityBillpayer':
            UtilityBillpayer_ = child_.text
            UtilityBillpayer_ = self.gds_validate_string(UtilityBillpayer_, node, 'UtilityBillpayer')
            self.UtilityBillpayer = UtilityBillpayer_
# end class UtilityBillsType


class SiteType198(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedSiteID=None):
        self.original_tagname_ = None
        if LinkedSiteID is None:
            self.LinkedSiteID = []
        else:
            self.LinkedSiteID = LinkedSiteID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SiteType198)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SiteType198.subclass:
            return SiteType198.subclass(*args_, **kwargs_)
        else:
            return SiteType198(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedSiteID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SiteType198', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteType198')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SiteType198', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SiteType198'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SiteType198', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedSiteID_ in self.LinkedSiteID:
            LinkedSiteID_.export(outfile, level, namespace_, name_='LinkedSiteID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedSiteID':
            obj_ = LinkedSiteIDType.factory()
            obj_.build(child_)
            self.LinkedSiteID.append(obj_)
            obj_.original_tagname_ = 'LinkedSiteID'
# end class SiteType198


class LinkedSiteIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, LinkedScheduleID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        if LinkedScheduleID is None:
            self.LinkedScheduleID = []
        else:
            self.LinkedScheduleID = LinkedScheduleID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedSiteIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedSiteIDType.subclass:
            return LinkedSiteIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedSiteIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedScheduleID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedSiteIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedSiteIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedSiteIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedSiteIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedSiteIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedScheduleID_ in self.LinkedScheduleID:
            LinkedScheduleID_.export(outfile, level, namespace_, name_='LinkedScheduleID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedScheduleID':
            obj_ = LinkedScheduleIDType.factory()
            obj_.build(child_)
            self.LinkedScheduleID.append(obj_)
            obj_.original_tagname_ = 'LinkedScheduleID'
# end class LinkedSiteIDType


class LinkedScheduleIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedScheduleIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedScheduleIDType.subclass:
            return LinkedScheduleIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedScheduleIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedScheduleIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedScheduleIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedScheduleIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedScheduleIDType


class FacilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedFacilityID=None):
        self.original_tagname_ = None
        if LinkedFacilityID is None:
            self.LinkedFacilityID = []
        else:
            self.LinkedFacilityID = LinkedFacilityID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityType.subclass:
            return FacilityType.subclass(*args_, **kwargs_)
        else:
            return FacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedFacilityID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FacilityType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FacilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FacilityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FacilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedFacilityID_ in self.LinkedFacilityID:
            LinkedFacilityID_.export(outfile, level, namespace_, name_='LinkedFacilityID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedFacilityID':
            obj_ = LinkedFacilityIDType.factory()
            obj_.build(child_)
            self.LinkedFacilityID.append(obj_)
            obj_.original_tagname_ = 'LinkedFacilityID'
# end class FacilityType


class LinkedFacilityIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, LinkedScheduleID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        if LinkedScheduleID is None:
            self.LinkedScheduleID = []
        else:
            self.LinkedScheduleID = LinkedScheduleID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedFacilityIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedFacilityIDType.subclass:
            return LinkedFacilityIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedFacilityIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedScheduleID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedFacilityIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedFacilityIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedFacilityIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedFacilityIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedFacilityIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedScheduleID_ in self.LinkedScheduleID:
            LinkedScheduleID_.export(outfile, level, namespace_, name_='LinkedScheduleID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedScheduleID':
            obj_ = LinkedScheduleIDType199.factory()
            obj_.build(child_)
            self.LinkedScheduleID.append(obj_)
            obj_.original_tagname_ = 'LinkedScheduleID'
# end class LinkedFacilityIDType


class LinkedScheduleIDType199(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedScheduleIDType199)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedScheduleIDType199.subclass:
            return LinkedScheduleIDType199.subclass(*args_, **kwargs_)
        else:
            return LinkedScheduleIDType199(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType199', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedScheduleIDType199')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedScheduleIDType199', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedScheduleIDType199'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType199', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedScheduleIDType199


class BlockType200(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedBlockID=None):
        self.original_tagname_ = None
        if LinkedBlockID is None:
            self.LinkedBlockID = []
        else:
            self.LinkedBlockID = LinkedBlockID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockType200)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockType200.subclass:
            return BlockType200.subclass(*args_, **kwargs_)
        else:
            return BlockType200(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedBlockID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='BlockType200', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlockType200')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='BlockType200', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='BlockType200'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='BlockType200', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedBlockID_ in self.LinkedBlockID:
            LinkedBlockID_.export(outfile, level, namespace_, name_='LinkedBlockID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedBlockID':
            obj_ = LinkedBlockIDType.factory()
            obj_.build(child_)
            self.LinkedBlockID.append(obj_)
            obj_.original_tagname_ = 'LinkedBlockID'
# end class BlockType200


class LinkedBlockIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, LinkedScheduleID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        if LinkedScheduleID is None:
            self.LinkedScheduleID = []
        else:
            self.LinkedScheduleID = LinkedScheduleID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedBlockIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedBlockIDType.subclass:
            return LinkedBlockIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedBlockIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedScheduleID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedBlockIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedBlockIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedBlockIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedBlockIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedBlockIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedScheduleID_ in self.LinkedScheduleID:
            LinkedScheduleID_.export(outfile, level, namespace_, name_='LinkedScheduleID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedScheduleID':
            obj_ = LinkedScheduleIDType201.factory()
            obj_.build(child_)
            self.LinkedScheduleID.append(obj_)
            obj_.original_tagname_ = 'LinkedScheduleID'
# end class LinkedBlockIDType


class LinkedScheduleIDType201(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedScheduleIDType201)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedScheduleIDType201.subclass:
            return LinkedScheduleIDType201.subclass(*args_, **kwargs_)
        else:
            return LinkedScheduleIDType201(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType201', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedScheduleIDType201')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedScheduleIDType201', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedScheduleIDType201'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType201', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedScheduleIDType201


class ZoneType202(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedZoneID=None):
        self.original_tagname_ = None
        if LinkedZoneID is None:
            self.LinkedZoneID = []
        else:
            self.LinkedZoneID = LinkedZoneID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoneType202)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoneType202.subclass:
            return ZoneType202.subclass(*args_, **kwargs_)
        else:
            return ZoneType202(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedZoneID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ZoneType202', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZoneType202')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ZoneType202', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ZoneType202'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ZoneType202', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedZoneID_ in self.LinkedZoneID:
            LinkedZoneID_.export(outfile, level, namespace_, name_='LinkedZoneID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedZoneID':
            obj_ = LinkedZoneIDType.factory()
            obj_.build(child_)
            self.LinkedZoneID.append(obj_)
            obj_.original_tagname_ = 'LinkedZoneID'
# end class ZoneType202


class LinkedZoneIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, LinkedScheduleID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        if LinkedScheduleID is None:
            self.LinkedScheduleID = []
        else:
            self.LinkedScheduleID = LinkedScheduleID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedZoneIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedZoneIDType.subclass:
            return LinkedZoneIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedZoneIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedScheduleID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedZoneIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedZoneIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedZoneIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedZoneIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedZoneIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedScheduleID_ in self.LinkedScheduleID:
            LinkedScheduleID_.export(outfile, level, namespace_, name_='LinkedScheduleID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedScheduleID':
            obj_ = LinkedScheduleIDType203.factory()
            obj_.build(child_)
            self.LinkedScheduleID.append(obj_)
            obj_.original_tagname_ = 'LinkedScheduleID'
# end class LinkedZoneIDType


class LinkedScheduleIDType203(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedScheduleIDType203)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedScheduleIDType203.subclass:
            return LinkedScheduleIDType203.subclass(*args_, **kwargs_)
        else:
            return LinkedScheduleIDType203(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType203', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedScheduleIDType203')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedScheduleIDType203', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedScheduleIDType203'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType203', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedScheduleIDType203


class SpaceType204(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinkedSpaceID=None):
        self.original_tagname_ = None
        if LinkedSpaceID is None:
            self.LinkedSpaceID = []
        else:
            self.LinkedSpaceID = LinkedSpaceID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpaceType204)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpaceType204.subclass:
            return SpaceType204.subclass(*args_, **kwargs_)
        else:
            return SpaceType204(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedSpaceID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SpaceType204', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpaceType204')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SpaceType204', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SpaceType204'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SpaceType204', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedSpaceID_ in self.LinkedSpaceID:
            LinkedSpaceID_.export(outfile, level, namespace_, name_='LinkedSpaceID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedSpaceID':
            obj_ = LinkedSpaceIDType.factory()
            obj_.build(child_)
            self.LinkedSpaceID.append(obj_)
            obj_.original_tagname_ = 'LinkedSpaceID'
# end class SpaceType204


class LinkedSpaceIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None, LinkedScheduleID=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
        if LinkedScheduleID is None:
            self.LinkedScheduleID = []
        else:
            self.LinkedScheduleID = LinkedScheduleID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedSpaceIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedSpaceIDType.subclass:
            return LinkedSpaceIDType.subclass(*args_, **kwargs_)
        else:
            return LinkedSpaceIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.LinkedScheduleID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedSpaceIDType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedSpaceIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedSpaceIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedSpaceIDType'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedSpaceIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LinkedScheduleID_ in self.LinkedScheduleID:
            LinkedScheduleID_.export(outfile, level, namespace_, name_='LinkedScheduleID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinkedScheduleID':
            obj_ = LinkedScheduleIDType205.factory()
            obj_.build(child_)
            self.LinkedScheduleID.append(obj_)
            obj_.original_tagname_ = 'LinkedScheduleID'
# end class LinkedSpaceIDType


class LinkedScheduleIDType205(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDref=None):
        self.original_tagname_ = None
        self.IDref = _cast(None, IDref)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkedScheduleIDType205)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkedScheduleIDType205.subclass:
            return LinkedScheduleIDType205.subclass(*args_, **kwargs_)
        else:
            return LinkedScheduleIDType205(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType205', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkedScheduleIDType205')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='LinkedScheduleIDType205', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='LinkedScheduleIDType205'):
        if self.IDref is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            outfile.write(' IDref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IDref), input_name='IDref')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='LinkedScheduleIDType205', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDref', node)
        if value is not None and 'IDref' not in already_processed:
            already_processed.add('IDref')
            self.IDref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LinkedScheduleIDType205


class StreetAddressDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Simplified=None, Complex=None):
        self.original_tagname_ = None
        self.Simplified = Simplified
        self.Complex = Complex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetAddressDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetAddressDetailType.subclass:
            return StreetAddressDetailType.subclass(*args_, **kwargs_)
        else:
            return StreetAddressDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Simplified is not None or
            self.Complex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StreetAddressDetailType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetAddressDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StreetAddressDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StreetAddressDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StreetAddressDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Simplified is not None:
            self.Simplified.export(outfile, level, namespace_, name_='Simplified', pretty_print=pretty_print)
        if self.Complex is not None:
            self.Complex.export(outfile, level, namespace_, name_='Complex', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Simplified':
            obj_ = SimplifiedType.factory()
            obj_.build(child_)
            self.Simplified = obj_
            obj_.original_tagname_ = 'Simplified'
        elif nodeName_ == 'Complex':
            obj_ = ComplexType.factory()
            obj_.build(child_)
            self.Complex = obj_
            obj_.original_tagname_ = 'Complex'
# end class StreetAddressDetailType


class SimplifiedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StreetAddress=None, StreetAdditionalInfo=None):
        self.original_tagname_ = None
        self.StreetAddress = StreetAddress
        self.StreetAdditionalInfo = StreetAdditionalInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplifiedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplifiedType.subclass:
            return SimplifiedType.subclass(*args_, **kwargs_)
        else:
            return SimplifiedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.StreetAddress is not None or
            self.StreetAdditionalInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SimplifiedType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplifiedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SimplifiedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SimplifiedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SimplifiedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetAddress>%s</%sStreetAddress>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetAddress), input_name='StreetAddress')), namespace_, eol_))
        if self.StreetAdditionalInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetAdditionalInfo>%s</%sStreetAdditionalInfo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetAdditionalInfo), input_name='StreetAdditionalInfo')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetAddress':
            StreetAddress_ = child_.text
            StreetAddress_ = self.gds_validate_string(StreetAddress_, node, 'StreetAddress')
            self.StreetAddress = StreetAddress_
        elif nodeName_ == 'StreetAdditionalInfo':
            StreetAdditionalInfo_ = child_.text
            StreetAdditionalInfo_ = self.gds_validate_string(StreetAdditionalInfo_, node, 'StreetAdditionalInfo')
            self.StreetAdditionalInfo = StreetAdditionalInfo_
# end class SimplifiedType


class ComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StreetNumberPrefix=None, StreetNumberNumeric=None, StreetNumberSuffix=None, StreetDirPrefix=None, StreetName=None, StreetAdditionalInfo=None, StreetSuffix=None, StreetSuffixModifier=None, StreetDirSuffix=None, SubaddressType=None, SubaddressIdentifier=None):
        self.original_tagname_ = None
        self.StreetNumberPrefix = StreetNumberPrefix
        self.StreetNumberNumeric = StreetNumberNumeric
        self.StreetNumberSuffix = StreetNumberSuffix
        self.StreetDirPrefix = StreetDirPrefix
        self.validate_StreetDirPrefixType(self.StreetDirPrefix)
        self.StreetName = StreetName
        self.StreetAdditionalInfo = StreetAdditionalInfo
        self.StreetSuffix = StreetSuffix
        self.validate_StreetSuffixType(self.StreetSuffix)
        self.StreetSuffixModifier = StreetSuffixModifier
        self.StreetDirSuffix = StreetDirSuffix
        self.validate_StreetDirSuffixType(self.StreetDirSuffix)
        self.SubaddressType = SubaddressType
        self.validate_SubaddressTypeType(self.SubaddressType)
        self.SubaddressIdentifier = SubaddressIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplexType.subclass:
            return ComplexType.subclass(*args_, **kwargs_)
        else:
            return ComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_StreetDirPrefixType(self, value):
        # Validate type StreetDirPrefixType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StreetDirPrefixType' % {"value" : value.encode("utf-8")} )
    def validate_StreetSuffixType(self, value):
        # Validate type StreetSuffixType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Alley', 'Annex', 'Arcade', 'Avenue', 'Bayou', 'Beach', 'Bend', 'Bluff', 'Bluffs', 'Bottom', 'Boulevard', 'Branch', 'Bridge', 'Brook', 'Brooks', 'Burg', 'Burgs', 'Bypass', 'Camp', 'Canyon', 'Cape', 'Causeway', 'Center', 'Centers', 'Circle', 'Circles', 'Cliff', 'Club', 'Common', 'Commons', 'Corner', 'Corners', 'Course', 'Court', 'Courts', 'Cove', 'Coves', 'Creek', 'Crescent', 'Crest', 'Crossing', 'Crossroad', 'Crossroads', 'Curve', 'Dale', 'Dam', 'Divide', 'Drive', 'Drives', 'Estate', 'Estates', 'Expressway', 'Extension', 'Extensions', 'Fall', 'Falls', 'Ferry', 'Field', 'Fields', 'Flat', 'Flats', 'Ford', 'Fords', 'Forest', 'Forge', 'Forges', 'Fork', 'Forks', 'Fort', 'Freeway', 'Garden', 'Gardens', 'Gateway', 'Glen', 'Glens', 'Green', 'Greens', 'Grove', 'Groves', 'Harbor', 'Harbors', 'Haven', 'Heights', 'Highway', 'Hill', 'Hills', 'Hollow', 'Inlet', 'Island', 'Islands', 'Isle', 'Junction', 'Junctions', 'Key', 'Keys', 'Knoll', 'Knolls', 'Lake', 'Lakes', 'Land', 'Landing', 'Lane', 'Light', 'Lights', 'Loaf', 'Lock', 'Locks', 'Lodge', 'Loop', 'Mall', 'Manor', 'Manors', 'Meadow', 'Meadows', 'Mews', 'Mill', 'Mills', 'Mission', 'Motorway', 'Mount', 'Mountain', 'Mountains', 'Neck', 'Orchard', 'Oval', 'Overpass', 'Park', 'Parks', 'Parkway', 'Parkways', 'Pass', 'Passage', 'Path', 'Pike', 'Pine', 'Pines', 'Place', 'Plain', 'Plains', 'Plaza', 'Point', 'Points', 'Port', 'Ports', 'Prairie', 'Radial', 'Ramp', 'Ranch', 'Rapid', 'Rapids', 'Rest', 'Ridge', 'Ridges', 'River', 'Road', 'Roads', 'Route', 'Row', 'Rue', 'Run', 'Shoal', 'Shoals', 'Shore', 'Shores', 'Skyway', 'Spring', 'Springs', 'Spur', 'Spurs', 'Square', 'Squares', 'Station', 'Stravenue', 'Stream', 'Street', 'Streets', 'Summit', 'Terrace', 'Throughway', 'Trace', 'Track', 'Trafficway', 'Trail', 'Trailer', 'Tunnel', 'Turnpike', 'Underpass', 'Union', 'Unions', 'Valley', 'Valleys', 'Viaduct', 'View', 'Views', 'Village', 'Villages', 'Ville', 'Vista', 'Walk', 'Walks', 'Wall', 'Way', 'Ways', 'Well', 'Wells']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StreetSuffixType' % {"value" : value.encode("utf-8")} )
    def validate_StreetDirSuffixType(self, value):
        # Validate type StreetDirSuffixType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StreetDirSuffixType' % {"value" : value.encode("utf-8")} )
    def validate_SubaddressTypeType(self, value):
        # Validate type SubaddressTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Apartment', 'Basement', 'Berth', 'Block', 'Building', 'Corridor', 'Cubicle', 'Department', 'Floor', 'Front', 'Hanger', 'Key', 'Lobby', 'Lot', 'Lower', 'Office', 'Penthouse', 'Pier', 'PO Box', 'Rear', 'Room', 'Seat', 'Side', 'Slip', 'Space', 'Stop', 'Suite', 'Terminal', 'Tower', 'Trailer', 'Unit', 'Upper', 'Wing']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SubaddressTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.StreetNumberPrefix is not None or
            self.StreetNumberNumeric is not None or
            self.StreetNumberSuffix is not None or
            self.StreetDirPrefix is not None or
            self.StreetName is not None or
            self.StreetAdditionalInfo is not None or
            self.StreetSuffix is not None or
            self.StreetSuffixModifier is not None or
            self.StreetDirSuffix is not None or
            self.SubaddressType is not None or
            self.SubaddressIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ComplexType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ComplexType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ComplexType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ComplexType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetNumberPrefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetNumberPrefix>%s</%sStreetNumberPrefix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetNumberPrefix), input_name='StreetNumberPrefix')), namespace_, eol_))
        if self.StreetNumberNumeric is not None:
            self.StreetNumberNumeric.export(outfile, level, namespace_, name_='StreetNumberNumeric', pretty_print=pretty_print)
        if self.StreetNumberSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetNumberSuffix>%s</%sStreetNumberSuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetNumberSuffix), input_name='StreetNumberSuffix')), namespace_, eol_))
        if self.StreetDirPrefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetDirPrefix>%s</%sStreetDirPrefix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetDirPrefix), input_name='StreetDirPrefix')), namespace_, eol_))
        if self.StreetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetName>%s</%sStreetName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetName), input_name='StreetName')), namespace_, eol_))
        if self.StreetAdditionalInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetAdditionalInfo>%s</%sStreetAdditionalInfo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetAdditionalInfo), input_name='StreetAdditionalInfo')), namespace_, eol_))
        if self.StreetSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetSuffix>%s</%sStreetSuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetSuffix), input_name='StreetSuffix')), namespace_, eol_))
        if self.StreetSuffixModifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetSuffixModifier>%s</%sStreetSuffixModifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetSuffixModifier), input_name='StreetSuffixModifier')), namespace_, eol_))
        if self.StreetDirSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreetDirSuffix>%s</%sStreetDirSuffix>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.StreetDirSuffix), input_name='StreetDirSuffix')), namespace_, eol_))
        if self.SubaddressType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubaddressType>%s</%sSubaddressType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SubaddressType), input_name='SubaddressType')), namespace_, eol_))
        if self.SubaddressIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubaddressIdentifier>%s</%sSubaddressIdentifier>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SubaddressIdentifier), input_name='SubaddressIdentifier')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetNumberPrefix':
            StreetNumberPrefix_ = child_.text
            StreetNumberPrefix_ = self.gds_validate_string(StreetNumberPrefix_, node, 'StreetNumberPrefix')
            self.StreetNumberPrefix = StreetNumberPrefix_
        elif nodeName_ == 'StreetNumberNumeric':
            obj_ = StreetNumberNumericType.factory()
            obj_.build(child_)
            self.StreetNumberNumeric = obj_
            obj_.original_tagname_ = 'StreetNumberNumeric'
        elif nodeName_ == 'StreetNumberSuffix':
            StreetNumberSuffix_ = child_.text
            StreetNumberSuffix_ = self.gds_validate_string(StreetNumberSuffix_, node, 'StreetNumberSuffix')
            self.StreetNumberSuffix = StreetNumberSuffix_
        elif nodeName_ == 'StreetDirPrefix':
            StreetDirPrefix_ = child_.text
            StreetDirPrefix_ = self.gds_validate_string(StreetDirPrefix_, node, 'StreetDirPrefix')
            self.StreetDirPrefix = StreetDirPrefix_
            # validate type StreetDirPrefixType
            self.validate_StreetDirPrefixType(self.StreetDirPrefix)
        elif nodeName_ == 'StreetName':
            StreetName_ = child_.text
            StreetName_ = self.gds_validate_string(StreetName_, node, 'StreetName')
            self.StreetName = StreetName_
        elif nodeName_ == 'StreetAdditionalInfo':
            StreetAdditionalInfo_ = child_.text
            StreetAdditionalInfo_ = self.gds_validate_string(StreetAdditionalInfo_, node, 'StreetAdditionalInfo')
            self.StreetAdditionalInfo = StreetAdditionalInfo_
        elif nodeName_ == 'StreetSuffix':
            StreetSuffix_ = child_.text
            StreetSuffix_ = self.gds_validate_string(StreetSuffix_, node, 'StreetSuffix')
            self.StreetSuffix = StreetSuffix_
            # validate type StreetSuffixType
            self.validate_StreetSuffixType(self.StreetSuffix)
        elif nodeName_ == 'StreetSuffixModifier':
            StreetSuffixModifier_ = child_.text
            StreetSuffixModifier_ = self.gds_validate_string(StreetSuffixModifier_, node, 'StreetSuffixModifier')
            self.StreetSuffixModifier = StreetSuffixModifier_
        elif nodeName_ == 'StreetDirSuffix':
            StreetDirSuffix_ = child_.text
            StreetDirSuffix_ = self.gds_validate_string(StreetDirSuffix_, node, 'StreetDirSuffix')
            self.StreetDirSuffix = StreetDirSuffix_
            # validate type StreetDirSuffixType
            self.validate_StreetDirSuffixType(self.StreetDirSuffix)
        elif nodeName_ == 'SubaddressType':
            SubaddressType_ = child_.text
            SubaddressType_ = self.gds_validate_string(SubaddressType_, node, 'SubaddressType')
            self.SubaddressType = SubaddressType_
            # validate type SubaddressTypeType
            self.validate_SubaddressTypeType(self.SubaddressType)
        elif nodeName_ == 'SubaddressIdentifier':
            SubaddressIdentifier_ = child_.text
            SubaddressIdentifier_ = self.gds_validate_string(SubaddressIdentifier_, node, 'SubaddressIdentifier')
            self.SubaddressIdentifier = SubaddressIdentifier_
# end class ComplexType


class StreetNumberNumericType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNumberNumericType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNumberNumericType.subclass:
            return StreetNumberNumericType.subclass(*args_, **kwargs_)
        else:
            return StreetNumberNumericType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='StreetNumberNumericType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetNumberNumericType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='StreetNumberNumericType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='StreetNumberNumericType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='StreetNumberNumericType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNumberNumericType


class UserDefinedFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FieldName=None, FieldValue=None):
        self.original_tagname_ = None
        self.FieldName = FieldName
        self.FieldValue = FieldValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UserDefinedFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UserDefinedFieldType.subclass:
            return UserDefinedFieldType.subclass(*args_, **kwargs_)
        else:
            return UserDefinedFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.FieldName is not None or
            self.FieldValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UserDefinedFieldType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedFieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UserDefinedFieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UserDefinedFieldType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UserDefinedFieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FieldName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFieldName>%s</%sFieldName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FieldName), input_name='FieldName')), namespace_, eol_))
        if self.FieldValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFieldValue>%s</%sFieldValue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FieldValue), input_name='FieldValue')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FieldName':
            FieldName_ = child_.text
            FieldName_ = self.gds_validate_string(FieldName_, node, 'FieldName')
            self.FieldName = FieldName_
        elif nodeName_ == 'FieldValue':
            FieldValue_ = child_.text
            FieldValue_ = self.gds_validate_string(FieldValue_, node, 'FieldValue')
            self.FieldValue = FieldValue_
# end class UserDefinedFieldType


class FloorAreaType206(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FloorAreaType=None, FloorAreaCustomName=None, FloorAreaValue=None):
        self.original_tagname_ = None
        self.FloorAreaType = FloorAreaType
        self.validate_FloorAreaTypeType(self.FloorAreaType)
        self.FloorAreaCustomName = FloorAreaCustomName
        self.FloorAreaValue = FloorAreaValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorAreaType206)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorAreaType206.subclass:
            return FloorAreaType206.subclass(*args_, **kwargs_)
        else:
            return FloorAreaType206(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_FloorAreaTypeType(self, value):
        # Validate type FloorAreaTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Gross', 'Net', 'Finished', 'Footprint', 'Rentable', 'Occupied', 'Lighted', 'Daylit', 'Heated', 'Cooled', 'Conditioned', 'Unconditioned', 'Semi-conditioned', 'Heated and Cooled', 'Heated only', 'Cooled only', 'Ventilated', 'Enclosed', 'Non-Enclosed', 'Open', 'Lot', 'Custom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FloorAreaTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FloorAreaType is not None or
            self.FloorAreaCustomName is not None or
            self.FloorAreaValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorAreaType206', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorAreaType206')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorAreaType206', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorAreaType206'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorAreaType206', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FloorAreaType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFloorAreaType>%s</%sFloorAreaType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FloorAreaType), input_name='FloorAreaType')), namespace_, eol_))
        if self.FloorAreaCustomName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFloorAreaCustomName>%s</%sFloorAreaCustomName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.FloorAreaCustomName), input_name='FloorAreaCustomName')), namespace_, eol_))
        if self.FloorAreaValue is not None:
            self.FloorAreaValue.export(outfile, level, namespace_, name_='FloorAreaValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FloorAreaType':
            FloorAreaType_ = child_.text
            FloorAreaType_ = self.gds_validate_string(FloorAreaType_, node, 'FloorAreaType')
            self.FloorAreaType = FloorAreaType_
            # validate type FloorAreaTypeType
            self.validate_FloorAreaTypeType(self.FloorAreaType)
        elif nodeName_ == 'FloorAreaCustomName':
            FloorAreaCustomName_ = child_.text
            FloorAreaCustomName_ = self.gds_validate_string(FloorAreaCustomName_, node, 'FloorAreaCustomName')
            self.FloorAreaCustomName = FloorAreaCustomName_
        elif nodeName_ == 'FloorAreaValue':
            obj_ = FloorAreaValueType.factory()
            obj_.build(child_)
            self.FloorAreaValue = obj_
            obj_.original_tagname_ = 'FloorAreaValue'
# end class FloorAreaType206


class FloorAreaValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloorAreaValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloorAreaValueType.subclass:
            return FloorAreaValueType.subclass(*args_, **kwargs_)
        else:
            return FloorAreaValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='FloorAreaValueType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloorAreaValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='FloorAreaValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='FloorAreaValueType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='FloorAreaValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloorAreaValueType


class OccupancyLevelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OccupantType=None, OccupantQuantityType=None, OccupantQuantity=None):
        self.original_tagname_ = None
        self.OccupantType = OccupantType
        self.validate_OccupantTypeType(self.OccupantType)
        self.OccupantQuantityType = OccupantQuantityType
        self.validate_OccupantQuantityTypeType(self.OccupantQuantityType)
        self.OccupantQuantity = OccupantQuantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OccupancyLevelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OccupancyLevelType.subclass:
            return OccupancyLevelType.subclass(*args_, **kwargs_)
        else:
            return OccupancyLevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_OccupantTypeType(self, value):
        # Validate type OccupantTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Family household', 'Married couple, no children', 'Male householder, no spouse', 'Female householder, no spouse', 'Cooperative household', 'Nonfamily household', 'Single male', 'Single female', 'Student community', 'Military community', 'Independent seniors community', 'Special accessibility needs community', 'Government subsidized community', 'Therapeutic community', 'No specific occupant type', 'For-profit organization', 'Religious organization', 'Non-profit organization', 'Government organization', 'Federal government', 'State government', 'Local government', 'Property', 'Animals', 'Other', 'Vacant', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OccupantTypeType' % {"value" : value.encode("utf-8")} )
    def validate_OccupantQuantityTypeType(self, value):
        # Validate type OccupantQuantityTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Peak total occupants', 'Adults', 'Children', 'Average residents', 'Workers on main shift', 'Full-time equivalent workers', 'Average daily salaried labor hours', 'Registered students', 'Staffed beds', 'Licensed beds', 'Capacity', 'Capacity percentage']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OccupantQuantityTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OccupantType is not None or
            self.OccupantQuantityType is not None or
            self.OccupantQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OccupancyLevelType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupancyLevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OccupancyLevelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OccupancyLevelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OccupancyLevelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OccupantType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupantType>%s</%sOccupantType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupantType), input_name='OccupantType')), namespace_, eol_))
        if self.OccupantQuantityType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOccupantQuantityType>%s</%sOccupantQuantityType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OccupantQuantityType), input_name='OccupantQuantityType')), namespace_, eol_))
        if self.OccupantQuantity is not None:
            self.OccupantQuantity.export(outfile, level, namespace_, name_='OccupantQuantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OccupantType':
            OccupantType_ = child_.text
            OccupantType_ = self.gds_validate_string(OccupantType_, node, 'OccupantType')
            self.OccupantType = OccupantType_
            # validate type OccupantTypeType
            self.validate_OccupantTypeType(self.OccupantType)
        elif nodeName_ == 'OccupantQuantityType':
            OccupantQuantityType_ = child_.text
            OccupantQuantityType_ = self.gds_validate_string(OccupantQuantityType_, node, 'OccupantQuantityType')
            self.OccupantQuantityType = OccupantQuantityType_
            # validate type OccupantQuantityTypeType
            self.validate_OccupantQuantityTypeType(self.OccupantQuantityType)
        elif nodeName_ == 'OccupantQuantity':
            obj_ = OccupantQuantityType207.factory()
            obj_.build(child_)
            self.OccupantQuantity = obj_
            obj_.original_tagname_ = 'OccupantQuantity'
# end class OccupancyLevelType


class OccupantQuantityType207(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OccupantQuantityType207)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OccupantQuantityType207.subclass:
            return OccupantQuantityType207.subclass(*args_, **kwargs_)
        else:
            return OccupantQuantityType207(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='OccupantQuantityType207', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupantQuantityType207')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='OccupantQuantityType207', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='OccupantQuantityType207'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='OccupantQuantityType207', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OccupantQuantityType207


class EnergyUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyUseType.subclass:
            return EnergyUseType.subclass(*args_, **kwargs_)
        else:
            return EnergyUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyUseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyUseType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyUseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyUseType


class ScoreType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScoreType.subclass:
            return ScoreType.subclass(*args_, **kwargs_)
        else:
            return ScoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='ScoreType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScoreType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='ScoreType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='ScoreType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='ScoreType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ScoreType


class SiteEnergyUseType208(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyUseByFuelType=None):
        self.original_tagname_ = None
        if EnergyUseByFuelType is None:
            self.EnergyUseByFuelType = []
        else:
            self.EnergyUseByFuelType = EnergyUseByFuelType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SiteEnergyUseType208)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SiteEnergyUseType208.subclass:
            return SiteEnergyUseType208.subclass(*args_, **kwargs_)
        else:
            return SiteEnergyUseType208(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.EnergyUseByFuelType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseType208', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiteEnergyUseType208')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SiteEnergyUseType208', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SiteEnergyUseType208'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SiteEnergyUseType208', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnergyUseByFuelType_ in self.EnergyUseByFuelType:
            EnergyUseByFuelType_.export(outfile, level, namespace_='auc:', name_='EnergyUseByFuelType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyUseByFuelType':
            obj_ = EnergyUseByFuelType.factory()
            obj_.build(child_)
            self.EnergyUseByFuelType.append(obj_)
            obj_.original_tagname_ = 'EnergyUseByFuelType'
# end class SiteEnergyUseType208


class SourceEnergyUseType209(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyUseByFuelType=None, SourceEnergyUseIntensity=None):
        self.original_tagname_ = None
        if EnergyUseByFuelType is None:
            self.EnergyUseByFuelType = []
        else:
            self.EnergyUseByFuelType = EnergyUseByFuelType
        self.SourceEnergyUseIntensity = SourceEnergyUseIntensity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceEnergyUseType209)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceEnergyUseType209.subclass:
            return SourceEnergyUseType209.subclass(*args_, **kwargs_)
        else:
            return SourceEnergyUseType209(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.EnergyUseByFuelType or
            self.SourceEnergyUseIntensity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseType209', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceEnergyUseType209')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceEnergyUseType209', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceEnergyUseType209'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseType209', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnergyUseByFuelType_ in self.EnergyUseByFuelType:
            EnergyUseByFuelType_.export(outfile, level, namespace_='auc:', name_='EnergyUseByFuelType', pretty_print=pretty_print)
        if self.SourceEnergyUseIntensity is not None:
            self.SourceEnergyUseIntensity.export(outfile, level, namespace_, name_='SourceEnergyUseIntensity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyUseByFuelType':
            obj_ = EnergyUseByFuelType.factory()
            obj_.build(child_)
            self.EnergyUseByFuelType.append(obj_)
            obj_.original_tagname_ = 'EnergyUseByFuelType'
        elif nodeName_ == 'SourceEnergyUseIntensity':
            obj_ = SourceEnergyUseIntensityType210.factory()
            obj_.build(child_)
            self.SourceEnergyUseIntensity = obj_
            obj_.original_tagname_ = 'SourceEnergyUseIntensity'
# end class SourceEnergyUseType209


class SourceEnergyUseIntensityType210(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceEnergyUseIntensityType210)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceEnergyUseIntensityType210.subclass:
            return SourceEnergyUseIntensityType210.subclass(*args_, **kwargs_)
        else:
            return SourceEnergyUseIntensityType210(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseIntensityType210', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceEnergyUseIntensityType210')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='SourceEnergyUseIntensityType210', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='SourceEnergyUseIntensityType210'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='SourceEnergyUseIntensityType210', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceEnergyUseIntensityType210


class WholeBuildingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AssetScoreData=None, EnergyUseByEndUse=None, Rankings=None):
        self.original_tagname_ = None
        self.AssetScoreData = AssetScoreData
        if EnergyUseByEndUse is None:
            self.EnergyUseByEndUse = []
        else:
            self.EnergyUseByEndUse = EnergyUseByEndUse
        self.Rankings = Rankings
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WholeBuildingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WholeBuildingType.subclass:
            return WholeBuildingType.subclass(*args_, **kwargs_)
        else:
            return WholeBuildingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.AssetScoreData is not None or
            self.EnergyUseByEndUse or
            self.Rankings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='WholeBuildingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WholeBuildingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='WholeBuildingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='WholeBuildingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='WholeBuildingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssetScoreData is not None:
            self.AssetScoreData.export(outfile, level, namespace_='auc:', name_='AssetScoreData', pretty_print=pretty_print)
        for EnergyUseByEndUse_ in self.EnergyUseByEndUse:
            EnergyUseByEndUse_.export(outfile, level, namespace_, name_='EnergyUseByEndUse', pretty_print=pretty_print)
        if self.Rankings is not None:
            self.Rankings.export(outfile, level, namespace_, name_='Rankings', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssetScoreData':
            obj_ = AssetScoreData.factory()
            obj_.build(child_)
            self.AssetScoreData = obj_
            obj_.original_tagname_ = 'AssetScoreData'
        elif nodeName_ == 'EnergyUseByEndUse':
            obj_ = EnergyUseByEndUseType.factory()
            obj_.build(child_)
            self.EnergyUseByEndUse.append(obj_)
            obj_.original_tagname_ = 'EnergyUseByEndUse'
        elif nodeName_ == 'Rankings':
            obj_ = RankingsType.factory()
            obj_.build(child_)
            self.Rankings = obj_
            obj_.original_tagname_ = 'Rankings'
# end class WholeBuildingType


class EnergyUseByEndUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnergyUse=None, EndUse=None):
        self.original_tagname_ = None
        self.EnergyUse = EnergyUse
        self.EndUse = EndUse
        self.validate_EndUse(self.EndUse)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyUseByEndUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyUseByEndUseType.subclass:
            return EnergyUseByEndUseType.subclass(*args_, **kwargs_)
        else:
            return EnergyUseByEndUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_EndUse(self, value):
        # Validate type EndUse, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Whole building', 'Total lighting', 'Interior lighting', 'Exterior lighting', 'Heating', 'Cooling', 'Ventilation', 'Pump', 'IT', 'Plug-in electric vehicle', 'Plug load', 'Process load', 'Conveyance', 'Domestic hot water', 'Refrigeration', 'Cooking', 'Dishwasher', 'Laundry', 'Pool heating', 'On-site generation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EndUse' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EnergyUse is not None or
            self.EndUse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyUseByEndUseType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyUseByEndUseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyUseByEndUseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyUseByEndUseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyUseByEndUseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EnergyUse is not None:
            self.EnergyUse.export(outfile, level, namespace_, name_='EnergyUse', pretty_print=pretty_print)
        if self.EndUse is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndUse>%s</%sEndUse>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EndUse), input_name='EndUse')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnergyUse':
            obj_ = EnergyUseType211.factory()
            obj_.build(child_)
            self.EnergyUse = obj_
            obj_.original_tagname_ = 'EnergyUse'
        elif nodeName_ == 'EndUse':
            EndUse_ = child_.text
            EndUse_ = self.gds_validate_string(EndUse_, node, 'EndUse')
            self.EndUse = EndUse_
            # validate type EndUse
            self.validate_EndUse(self.EndUse)
# end class EnergyUseByEndUseType


class EnergyUseType211(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyUseType211)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyUseType211.subclass:
            return EnergyUseType211.subclass(*args_, **kwargs_)
        else:
            return EnergyUseType211(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='EnergyUseType211', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnergyUseType211')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='EnergyUseType211', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='EnergyUseType211'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')), ))
    def exportChildren(self, outfile, level, namespace_='auc:', name_='EnergyUseType211', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyUseType211


class RankingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ranking=None):
        self.original_tagname_ = None
        if Ranking is None:
            self.Ranking = []
        else:
            self.Ranking = Ranking
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RankingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RankingsType.subclass:
            return RankingsType.subclass(*args_, **kwargs_)
        else:
            return RankingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Ranking
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RankingsType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RankingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RankingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RankingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RankingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Ranking_ in self.Ranking:
            Ranking_.export(outfile, level, namespace_, name_='Ranking', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ranking':
            obj_ = RankingType.factory()
            obj_.build(child_)
            self.Ranking.append(obj_)
            obj_.original_tagname_ = 'Ranking'
# end class RankingsType


class RankingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Rank=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Rank = Rank
        self.validate_RankType(self.Rank)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RankingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RankingType.subclass:
            return RankingType.subclass(*args_, **kwargs_)
        else:
            return RankingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_RankType(self, value):
        # Validate type RankType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Fair', 'Good', 'Superior']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RankType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Rank is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='RankingType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RankingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='RankingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='RankingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='RankingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Rank is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRank>%s</%sRank>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Rank), input_name='Rank')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = TypeType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Rank':
            Rank_ = child_.text
            Rank_ = self.gds_validate_string(Rank_, node, 'Rank')
            self.Rank = Rank_
            # validate type RankType
            self.validate_RankType(self.Rank)
# end class RankingType


class TypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SystemsType=None, EnvelopeType=None):
        self.original_tagname_ = None
        self.SystemsType = SystemsType
        self.validate_SystemsTypeType(self.SystemsType)
        self.EnvelopeType = EnvelopeType
        self.validate_EnvelopeTypeType(self.EnvelopeType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TypeType.subclass:
            return TypeType.subclass(*args_, **kwargs_)
        else:
            return TypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_SystemsTypeType(self, value):
        # Validate type SystemsTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Cooling', 'Heating', 'Hot Water', 'Interior Lighting', 'Overall HVAC Systems']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SystemsTypeType' % {"value" : value.encode("utf-8")} )
    def validate_EnvelopeTypeType(self, value):
        # Validate type EnvelopeTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Floor U-Value, Mass', 'Roof U-Value, Non-Attic', 'Walls U-Value, Framed', 'Walls + Windows U-Value', 'Window Solar Heat Gain Coefficient', 'Windows U-Value']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnvelopeTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SystemsType is not None or
            self.EnvelopeType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='TypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='TypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='TypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='TypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SystemsType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystemsType>%s</%sSystemsType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SystemsType), input_name='SystemsType')), namespace_, eol_))
        if self.EnvelopeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnvelopeType>%s</%sEnvelopeType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.EnvelopeType), input_name='EnvelopeType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SystemsType':
            SystemsType_ = child_.text
            SystemsType_ = self.gds_validate_string(SystemsType_, node, 'SystemsType')
            self.SystemsType = SystemsType_
            # validate type SystemsTypeType
            self.validate_SystemsTypeType(self.SystemsType)
        elif nodeName_ == 'EnvelopeType':
            EnvelopeType_ = child_.text
            EnvelopeType_ = self.gds_validate_string(EnvelopeType_, node, 'EnvelopeType')
            self.EnvelopeType = EnvelopeType_
            # validate type EnvelopeTypeType
            self.validate_EnvelopeTypeType(self.EnvelopeType)
# end class TypeType


class UseTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AssetScoreData=None, AssetScoreUseType=None):
        self.original_tagname_ = None
        self.AssetScoreData = AssetScoreData
        self.AssetScoreUseType = AssetScoreUseType
        self.validate_AssetScoreUseTypeType(self.AssetScoreUseType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseTypeType.subclass:
            return UseTypeType.subclass(*args_, **kwargs_)
        else:
            return UseTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_AssetScoreUseTypeType(self, value):
        # Validate type AssetScoreUseTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Assisted Living Facility', 'City Hall', 'Community Center', 'Courthouse', 'Education', 'Library', 'Lodging', 'Medical Office', 'Multi-family (4 floors or greater)', 'Multi-family (fewer than 4 floors)', 'Office', 'Parking Garage (Ventilation Only)', 'Police Station', 'Post Office', 'Religious Building', 'Retail', 'Senior Center', 'Warehouse non-refrigerated']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssetScoreUseTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AssetScoreData is not None or
            self.AssetScoreUseType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='auc:', name_='UseTypeType', namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UseTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='auc:', name_='UseTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='auc:', name_='UseTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='auc:', name_='UseTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssetScoreData is not None:
            self.AssetScoreData.export(outfile, level, namespace_='auc:', name_='AssetScoreData', pretty_print=pretty_print)
        if self.AssetScoreUseType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssetScoreUseType>%s</%sAssetScoreUseType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AssetScoreUseType), input_name='AssetScoreUseType')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssetScoreData':
            obj_ = AssetScoreData.factory()
            obj_.build(child_)
            self.AssetScoreData = obj_
            obj_.original_tagname_ = 'AssetScoreData'
        elif nodeName_ == 'AssetScoreUseType':
            AssetScoreUseType_ = child_.text
            AssetScoreUseType_ = self.gds_validate_string(AssetScoreUseType_, node, 'AssetScoreUseType')
            self.AssetScoreUseType = AssetScoreUseType_
            # validate type AssetScoreUseTypeType
            self.validate_AssetScoreUseTypeType(self.AssetScoreUseType)
# end class UseTypeType


GDSClassesMapping = {
    'ASHRAE': ASHRAEType,
    'Actual': ActualType,
    'Addition': AdditionType,
    'AdjustedToYear': AdjustedToYearType,
    'AdvancedMeteringSystems': AdvancedMeteringSystemsType,
    'AirCleaner': AirCleanerType,
    'AirCooled': AirCooledType,
    'AirInfiltrationValue': AirInfiltrationValueType,
    'AirSideEconomizer': AirSideEconomizerType128,
    'AllResourceTotal': AllResourceTotalType,
    'AllResourceTotals': AllResourceTotalsType,
    'AlternativeSystemAdded': AlternativeSystemAddedType,
    'AlternativeSystemReplacement': AlternativeSystemReplacementType,
    'AnalysisPeriod': AnalysisPeriodType,
    'AnnualCoolingDegreeDays': AnnualCoolingDegreeDaysType,
    'AnnualCoolingEfficiencyValue': AnnualCoolingEfficiencyValueType145,
    'AnnualDemandSavingsCost': AnnualDemandSavingsCostType,
    'AnnualFuelUseConsistentUnits': AnnualFuelUseConsistentUnitsType,
    'AnnualFuelUseNativeUnits': AnnualFuelUseNativeUnitsType,
    'AnnualHeatingDegreeDays': AnnualHeatingDegreeDaysType,
    'AnnualHeatingEfficiencyValue': AnnualHeatingEfficiencyValueType120,
    'AnnualSavingsByFuel': AnnualSavingsByFuelType89,
    'AnnualSavingsCost': AnnualSavingsCostType88,
    'AnnualSavingsNativeUnits': AnnualSavingsNativeUnitsType90,
    'AnnualSavingsSiteEnergy': AnnualSavingsSiteEnergyType86,
    'AnnualSavingsSourceEnergy': AnnualSavingsSourceEnergyType87,
    'AnnualWaterCostSavings': AnnualWaterCostSavingsType94,
    'AnnualWaterSavings': AnnualWaterSavingsType93,
    'AntiSweatHeaterPower': AntiSweatHeaterPowerType,
    'AntiSweatHeaters': AntiSweatHeatersType,
    'AspectRatio': AspectRatioType,
    'Assessment': AssessmentType,
    'Audit': AuditType,
    'AuditCost': AuditCostType,
    'AuditorContactID': AuditorContactIDType,
    'AverageMarginalCostRate': AverageMarginalCostRateType,
    'AverageMarginalSellRate': AverageMarginalSellRateType,
    'AvoidedEmissions': AvoidedEmissionsType,
    'Basement': BasementType,
    'Benchmark': BenchmarkType16,
    'BenchmarkType': BenchmarkTypeType,
    'Block': BlockType,
    'BlockID': BlockIDType,
    'Boiler': BoilerType104,
    'BoilerEWT': BoilerEWTType,
    'BoilerInsulationRValue': BoilerInsulationRValueType,
    'BoilerInsulationThickness': BoilerInsulationThicknessType,
    'BoilerLWT': BoilerLWTType109,
    'BoilerPercentCondensateReturn': BoilerPercentCondensateReturnType,
    'BoilerPlantImprovements': BoilerPlantImprovementsType,
    'BuildingAmerica': BuildingAmericaType,
    'BuildingAutomationSystems': BuildingAutomationSystemsType,
    'BuildingEnvelopeModifications': BuildingEnvelopeModificationsType,
    'BurnerTurndownRatio': BurnerTurndownRatioType116,
    'CBECS': CBECSType,
    'CDDBaseTemperature': CDDBaseTemperatureType59,
    'CalculationMethod': CalculationMethodType,
    'CaliforniaTitle24': CaliforniaTitle24Type,
    'CapitalReplacementCost': CapitalReplacementCostType,
    'CaseReturnLineDiameter': CaseReturnLineDiameterType,
    'CeilingVisibleAbsorptance': CeilingVisibleAbsorptanceType,
    'CellCount': CellCountType,
    'CentralAirDistribution': CentralAirDistributionType,
    'CentralRefrigerationSystem': CentralRefrigerationSystemType,
    'CertifiedAuditTeamMemberContactID': CertifiedAuditTeamMemberContactIDType,
    'ChilledWaterHotWaterAndSteamDistributionSystems': ChilledWaterHotWaterAndSteamDistributionSystemsType,
    'ChilledWaterSupplyTemperature': ChilledWaterSupplyTemperatureType147,
    'Chiller': ChillerType137,
    'ChillerPlantImprovements': ChillerPlantImprovementsType,
    'ClimateZoneType': ClimateZoneTypeType,
    'ClothesWasherCapacity': ClothesWasherCapacityType184,
    'ClothesWasherModifiedEnergyFactor': ClothesWasherModifiedEnergyFactorType182,
    'ClothesWasherWaterFactor': ClothesWasherWaterFactorType183,
    'CodeMinimum': CodeMinimumType,
    'Combination': CombinationType,
    'Combustion': CombustionType170,
    'CombustionEfficiency': CombustionEfficiencyType117,
    'CommercialFacilities': CommercialFacilitiesType,
    'CommercialFacility': CommercialFacilityType,
    'CompactFluorescent': CompactFluorescentType,
    'Complex': ComplexType,
    'CompressorUnloader': CompressorUnloaderType,
    'CompressorUnloaderStages': CompressorUnloaderStagesType,
    'CondenserPlant': CondenserPlantType,
    'CondenserPlantID': CondenserPlantIDType177,
    'CondenserWaterTemperature': CondenserWaterTemperatureType153,
    'CondensingTemperature': CondensingTemperatureType159,
    'ConditionedVolume': ConditionedVolumeType,
    'ConsumptionEnergyTierDesignation': ConsumptionEnergyTierDesignationType,
    'Contact': ContactType,
    'ContactEmailAddresses': ContactEmailAddressesType,
    'ContactTelephoneNumbers': ContactTelephoneNumbersType,
    'Contacts': ContactsType,
    'Convection': ConvectionType130,
    'ConveyancePeakPower': ConveyancePeakPowerType,
    'ConveyanceStandbyPower': ConveyanceStandbyPowerType,
    'ConveyanceSystem': ConveyanceSystemType,
    'ConveyanceSystems': ConveyanceSystemsType,
    'CookingEnergyPerMeal': CookingEnergyPerMealType,
    'CookingSystem': CookingSystemType,
    'CookingSystems': CookingSystemsType,
    'CoolingDegreeDays': CoolingDegreeDaysType,
    'CoolingDeliveryID': CoolingDeliveryIDType,
    'CoolingPlantID': CoolingPlantIDType,
    'CoolingPlantType': CoolingPlantTypeType,
    'CoolingSource': CoolingSourceType125,
    'CoolingSourceID': CoolingSourceIDType136,
    'CoolingSourceType': CoolingSourceTypeType,
    'CoolingStageCapacity': CoolingStageCapacityType139,
    'CoolingSupplyAirTemperature': CoolingSupplyAirTemperatureType,
    'Crawlspace': CrawlspaceType,
    'CrawlspaceVenting': CrawlspaceVentingType,
    'CriticalITSystem': CriticalITSystemType,
    'CriticalITSystems': CriticalITSystemsType,
    'CurrentBuilding': CurrentBuildingType,
    'DOE': DOEType,
    'DX': DXType,
    'DailyHotWaterDraw': DailyHotWaterDrawType,
    'DailyWaterUse': DailyWaterUseType,
    'DaylightingControlSteps': DaylightingControlStepsType,
    'DaylightingIlluminanceSetPoint': DaylightingIlluminanceSetPointType,
    'Dehumidifier': DehumidifierType,
    'Delivery': DeliveryType126,
    'DeliveryID': DeliveryIDType,
    'DeliveryType': DeliveryTypeType,
    'DemandRatchetPercentage': DemandRatchetPercentageType53,
    'DemandRateAdjustment': DemandRateAdjustmentType51,
    'DemandWindow': DemandWindowType52,
    'DesignAmbientTemperature': DesignAmbientTemperatureType,
    'DesignStaticPressure': DesignStaticPressureType,
    'DesignTemperatureDifference': DesignTemperatureDifferenceType,
    'DimmingCapability': DimmingCapabilityType,
    'Direct': DirectType,
    'DirectTankHeatingSource': DirectTankHeatingSourceType,
    'DiscountFactor': DiscountFactorType,
    'DishwasherEnergyFactor': DishwasherEnergyFactorType,
    'DishwasherHotWaterUse': DishwasherHotWaterUseType,
    'DishwasherLoadsPerWeek': DishwasherLoadsPerWeekType,
    'DishwasherSystem': DishwasherSystemType,
    'DishwasherSystems': DishwasherSystemsType,
    'DistanceBetweenVerticalFins': DistanceBetweenVerticalFinsType,
    'DistributedGeneration': DistributedGenerationType,
    'DistrictChilledWater': DistrictChilledWaterType,
    'DistrictHeating': DistrictHeatingType105,
    'DomesticHotWaterSystem': DomesticHotWaterSystemType,
    'DomesticHotWaterSystems': DomesticHotWaterSystemsType,
    'DomesticHotWaterType': DomesticHotWaterTypeType,
    'Door': DoorType,
    'DoorGlazedAreaFraction': DoorGlazedAreaFractionType,
    'DoorID': DoorIDType,
    'DriveEfficiency': DriveEfficiencyType,
    'Dryer': DryerType181,
    'DryerElectricEnergyUsePerLoad': DryerElectricEnergyUsePerLoadType185,
    'DryerGasEnergyUsePerLoad': DryerGasEnergyUsePerLoadType186,
    'DuctInsulationRValue': DuctInsulationRValueType,
    'DuctPressureTestLeakagePercentage': DuctPressureTestLeakagePercentageType,
    'DuctPressureTestLeakageRate': DuctPressureTestLeakageRateType,
    'DuctSurfaceArea': DuctSurfaceAreaType,
    'DuctSystems': DuctSystemType,
    'DutyCycle': DutyCycleType,
    'EconomizerDryBulbControlPoint': EconomizerDryBulbControlPointType,
    'EconomizerEnthalpyControlPoint': EconomizerEnthalpyControlPointType,
    'EconomizerLowTemperatureLockout': EconomizerLowTemperatureLockoutType,
    'ElectricDemandRate': ElectricDemandRateType49,
    'ElectricMotorsAndDrives': ElectricMotorsAndDrivesType,
    'ElectricalPeakShavingLoadShifting': ElectricalPeakShavingLoadShiftingType,
    'ElectricityPriceEscalationRate': ElectricityPriceEscalationRateType,
    'ElectricitySourcedFromOnsiteRenewableSystems': ElectricitySourcedFromOnsiteRenewableSystemsType,
    'Emissions': EmissionsType56,
    'EmissionsFactor': EmissionsFactorType,
    'EnergyConversionType': EnergyConversionTypeType,
    'EnergyCost': EnergyCostType,
    'EnergyCostRate': EnergyCostRateType48,
    'EnergyCostReductionThroughRateAdjustments': EnergyCostReductionThroughRateAdjustmentsType,
    'EnergyDistributionSystems': EnergyDistributionSystemsType,
    'EnergyRateAdjustment': EnergyRateAdjustmentType50,
    'EnergyRecoveryEfficiency': EnergyRecoveryEfficiencyType,
    'EnergyRelatedProcessImprovements': EnergyRelatedProcessImprovementsType,
    'EnergySellRate': EnergySellRateType54,
    'EnergyStar': EnergyStarType,
    'EnergyUse': EnergyUseType211,
    'EnergyUseByEndUse': EnergyUseByEndUseType,
    'EquipmentDisposalAndSalvageCosts': EquipmentDisposalAndSalvageCostsType96,
    'EvaporativeCooler': EvaporativeCoolerType,
    'EvaporativelyCooledCondenser': EvaporativelyCooledCondenserType,
    'EvaporativelyCooledCondenserMaximumTemperature': EvaporativelyCooledCondenserMaximumTemperatureType,
    'EvaporativelyCooledCondenserMinimumTemperature': EvaporativelyCooledCondenserMinimumTemperatureType,
    'ExistingScheduleAffected': ExistingScheduleAffectedType64,
    'ExistingSystemAffected': ExistingSystemAffectedType,
    'ExistingSystemRemoved': ExistingSystemRemovedType,
    'ExistingSystemReplaced': ExistingSystemReplacedType,
    'Facility': FacilityType,
    'FanBased': FanBasedType,
    'FanBasedDistributionType': FanBasedDistributionTypeType,
    'FanCoil': FanCoilType127,
    'FanEfficiency': FanEfficiencyType,
    'FanPowerMinimumRatio': FanPowerMinimumRatioType,
    'FanSize': FanSizeType,
    'FanSystem': FanSystemType,
    'FanSystems': FanSystemsType,
    'FederalBuilding': FederalBuildingType,
    'FederalSustainabilityChecklistCompletionPercentage': FederalSustainabilityChecklistCompletionPercentageType,
    'FenestrationArea': FenestrationAreaType10,
    'FenestrationRValue': FenestrationRValueType,
    'FenestrationSystem': FenestrationSystemType,
    'FenestrationSystems': FenestrationSystemsType,
    'FenestrationType': FenestrationTypeType,
    'FenestrationUFactor': FenestrationUFactorType,
    'FixedMonthlyCharge': FixedMonthlyChargeType,
    'FixtureSpacing': FixtureSpacingType,
    'FlatRate': FlatRateType,
    'FloorArea': FloorAreaType206,
    'FloorAreaValue': FloorAreaValueType,
    'FloorFramingDepth': FloorFramingDepthType,
    'FloorFramingFactor': FloorFramingFactorType,
    'FloorFramingSpacing': FloorFramingSpacingType,
    'FloorInsulationThickness': FloorInsulationThicknessType,
    'FloorRValue': FloorRValueType,
    'FloorToCeilingHeight': FloorToCeilingHeightType,
    'FloorToFloorHeight': FloorToFloorHeightType,
    'FloorUFactor': FloorUFactorType,
    'FloorsAboveGrade': FloorsAboveGradeType,
    'FloorsBelowGrade': FloorsBelowGradeType,
    'FloorsPartiallyBelowGrade': FloorsPartiallyBelowGradeType,
    'FoundationArea': FoundationAreaType,
    'FoundationHeightAboveGrade': FoundationHeightAboveGradeType190,
    'FoundationID': FoundationIDType,
    'FoundationSystem': FoundationSystemType,
    'FoundationSystems': FoundationSystemsType,
    'FoundationWallInsulationThickness': FoundationWallInsulationThicknessType191,
    'FoundationWallRValue': FoundationWallRValueType,
    'FuelUseIntensity': FuelUseIntensityType,
    'FullLoadAmps': FullLoadAmpsType,
    'FundingFromIncentives': FundingFromIncentivesType97,
    'FundingFromTaxCredits': FundingFromTaxCreditsType98,
    'Furnace': FurnaceType115,
    'FutureOtherECMs': FutureOtherECMsType,
    'GHGEmissions': GHGEmissionsType,
    'GasPriceEscalationRate': GasPriceEscalationRateType,
    'Generation': GenerationType,
    'GlycolCooledDryCooler': GlycolCooledDryCoolerType,
    'GroundCoupling': GroundCouplingType,
    'GroundSource': GroundSourceType152,
    'HDDBaseTemperature': HDDBaseTemperatureType58,
    'HPWHMinimumAirTemperature': HPWHMinimumAirTemperatureType,
    'HVACScheduleID': HVACScheduleIDType,
    'HVACSystem': HVACSystemType,
    'HVACSystems': HVACSystemsType,
    'Halogen': HalogenType,
    'HealthAndSafety': HealthAndSafetyType,
    'HeatGainFraction': HeatGainFractionType,
    'HeatPump': HeatPumpType169,
    'HeatPumpBackupAFUE': HeatPumpBackupAFUEType,
    'HeatPumpBackupHeatingSwitchoverTemperature': HeatPumpBackupHeatingSwitchoverTemperatureType,
    'HeatRecoveryEfficiency': HeatRecoveryEfficiencyType,
    'HeatRecoverySystem': HeatRecoverySystemType,
    'HeatRecoverySystems': HeatRecoverySystemsType,
    'Heated': HeatedType,
    'HeatingAndCoolingSystems': HeatingAndCoolingSystemsType,
    'HeatingDegreeDays': HeatingDegreeDaysType,
    'HeatingDeliveryID': HeatingDeliveryIDType,
    'HeatingPlantID': HeatingPlantIDType,
    'HeatingPlantType': HeatingPlantTypeType,
    'HeatingSource': HeatingSourceType114,
    'HeatingSourceID': HeatingSourceIDType,
    'HeatingSourceType': HeatingSourceTypeType,
    'HeatingStageCapacityFraction': HeatingStageCapacityFractionType124,
    'HeatingSupplyAirTemperature': HeatingSupplyAirTemperatureType,
    'HighIntensityDischarge': HighIntensityDischargeType,
    'HotWaterBoilerMaximumFlowRate': HotWaterBoilerMaximumFlowRateType108,
    'HotWaterBoilerMinimumFlowRate': HotWaterBoilerMinimumFlowRateType,
    'HotWaterSetpointTemperature': HotWaterSetpointTemperatureType,
    'HoursUncovered': HoursUncoveredType,
    'Humidifier': HumidifierType,
    'HumidityControlMaximum': HumidityControlMaximumType,
    'HumidityControlMinimum': HumidityControlMinimumType,
    'IECC': IECCType,
    'ITNominalPower': ITNominalPowerType,
    'ITPeakPower': ITPeakPowerType,
    'ITStandbyPower': ITStandbyPowerType,
    'ImplementationPeriodCostSavings': ImplementationPeriodCostSavingsType,
    'Incandescent': IncandescentType,
    'Indirect': IndirectType,
    'IndirectTankHeatingSource': IndirectTankHeatingSourceType,
    'Induction': InductionType,
    'InfiltrationIntrusion': InfiltrationIntrusionType,
    'InflationRate': InflationRateType,
    'InputCapacity': InputCapacityType121,
    'InstalledFlowRate': InstalledFlowRateType,
    'InstalledPower': InstalledPowerType,
    'Instantaneous': InstantaneousType,
    'InstantaneousWaterHeatingSource': InstantaneousWaterHeatingSourceType,
    'InteriorVisibleAbsorptance': InteriorVisibleAbsorptanceType,
    'InternalRateOfReturn': InternalRateOfReturnType102,
    'IntervalReading': IntervalReadingType,
    'LampPower': LampPowerType179,
    'LampType': LampTypeType,
    'Latitude': LatitudeType,
    'LaundryEquipmentUsage': LaundryEquipmentUsageType,
    'LaundrySystem': LaundrySystemType,
    'LaundrySystems': LaundrySystemsType,
    'LaundryType': LaundryTypeType,
    'LightShelfDistanceFromTop': LightShelfDistanceFromTopType,
    'LightShelfExteriorProtrusion': LightShelfExteriorProtrusionType,
    'LightShelfInteriorProtrusion': LightShelfInteriorProtrusionType,
    'LightShelves': LightShelvesType,
    'LightingEfficacy': LightingEfficacyType,
    'LightingImprovements': LightingImprovementsType,
    'LightingSystem': LightingSystemType,
    'LightingSystems': LightingSystemsType,
    'LinearFluorescent': LinearFluorescentType,
    'LinkedBlockID': LinkedBlockIDType,
    'LinkedFacilityID': LinkedFacilityIDType,
    'LinkedHeatingPlantID': LinkedHeatingPlantIDType,
    'LinkedScheduleID': LinkedScheduleIDType205,
    'LinkedSiteID': LinkedSiteIDType,
    'LinkedSpaceID': LinkedSpaceIDType,
    'LinkedSystemID': LinkedSystemIDType188,
    'LinkedZoneID': LinkedZoneIDType,
    'Longitude': LongitudeType,
    'LuminaireHeight': LuminaireHeightType,
    'MVCost': MVCostType,
    'MakeupAirSourceID': MakeupAirSourceIDType162,
    'MaximumFanPower': MaximumFanPowerType,
    'MaximumOAFlowRate': MaximumOAFlowRateType,
    'MaxkWUsage': MaxkWUsageType,
    'MaxkWhUsage': MaxkWhUsageType,
    'Measure': MeasureType,
    'MeasureCoverage': MeasureCoverageType,
    'MeasureFirstCost': MeasureFirstCostType,
    'MeasureRank': MeasureRankType,
    'MeasureSavingsAnalysis': MeasureSavingsAnalysisType,
    'Measured': MeasuredType,
    'MeasuredEnergySource': MeasuredEnergySourceType,
    'Measures': MeasuresType,
    'MeasuresID': MeasuresIDType,
    'MechanicalVentilation': MechanicalVentilationType,
    'MinimumDimmingLightFraction': MinimumDimmingLightFractionType,
    'MinimumDimmingPowerFraction': MinimumDimmingPowerFractionType,
    'MinimumFlowRate': MinimumFlowRateType,
    'MinimumOutsideAirPercentage': MinimumOutsideAirPercentageType,
    'MinimumPartLoadRatio': MinimumPartLoadRatioType143,
    'MinimumPowerFactorWithoutPenalty': MinimumPowerFactorWithoutPenaltyType,
    'MiscellaneousElectricLoad': MiscellaneousElectricLoadType,
    'MiscellaneousGasLoad': MiscellaneousGasLoadType,
    'ModificationRetrocommissioning': ModificationRetrocommissioningType,
    'ModifiedSchedule': ModifiedScheduleType65,
    'ModifiedSystem': ModifiedSystemType,
    'MotorBrakeHP': MotorBrakeHPType,
    'MotorEfficiency': MotorEfficiencyType,
    'MotorHP': MotorHPType,
    'MotorPoleCount': MotorPoleCountType,
    'MotorRPM': MotorRPMType,
    'MotorSystem': MotorSystemType,
    'MotorSystems': MotorSystemsType,
    'NPVofTaxImplications': NPVofTaxImplicationsType99,
    'NaturalVentilation': NaturalVentilationType,
    'NaturalVentilationRate': NaturalVentilationRateType,
    'NetMetering': NetMeteringType,
    'NetPresentValue': NetPresentValueType101,
    'NetRefrigerationCapacity': NetRefrigerationCapacityType,
    'NormalizationYears': NormalizationYearsType,
    'Normalized': NormalizedType,
    'NumberOfBallastsPerLuminaire': NumberOfBallastsPerLuminaireType,
    'NumberOfBusinesses': NumberOfBusinessesType,
    'NumberOfDiscreteCoolingStages': NumberOfDiscreteCoolingStagesType138,
    'NumberOfDiscreteFanSpeedsCooling': NumberOfDiscreteFanSpeedsCoolingType,
    'NumberOfDiscreteFanSpeedsHeating': NumberOfDiscreteFanSpeedsHeatingType,
    'NumberOfHeatingStages': NumberOfHeatingStagesType123,
    'NumberOfLampsPerBallast': NumberOfLampsPerBallastType,
    'NumberOfLampsPerLuminaire': NumberOfLampsPerLuminaireType,
    'NumberOfLuminaires': NumberOfLuminairesType,
    'NumberOfMeals': NumberOfMealsType,
    'NumberOfRefrigerantReturnLines': NumberOfRefrigerantReturnLinesType,
    'NumberOfUnits': NumberOfUnitsType,
    'OMCostAnnualSavings': OMCostAnnualSavingsType95,
    'OccupancyLevel': OccupancyLevelType,
    'OccupancyScheduleID': OccupancyScheduleIDType,
    'OccupantQuantity': OccupantQuantityType207,
    'OffCycleHeatLossCoefficient': OffCycleHeatLossCoefficientType,
    'OnSiteGenerationType': OnSiteGenerationTypeType,
    'OnSiteStorageTransmissionGenerationSystem': OnSiteStorageTransmissionGenerationSystemType,
    'OnSiteStorageTransmissionGenerationSystems': OnSiteStorageTransmissionGenerationSystemsType,
    'OnsiteRenewableSystemElectricityExported': OnsiteRenewableSystemElectricityExportedType,
    'Other': OtherType196,
    'OtherCostAnnualSavings': OtherCostAnnualSavingsType,
    'OtherEscalationRates': OtherEscalationRatesType,
    'OtherFinancialIncentives': OtherFinancialIncentivesType,
    'OtherHVAC': OtherHVACType68,
    'OtherHVACSystem': OtherHVACSystemType,
    'OtherHVACSystems': OtherHVACSystemsType,
    'OtherHVACType': OtherHVACTypeType,
    'OutputCapacity': OutputCapacityType122,
    'OutsideAirResetMaximumCoolingSupplyTemperature': OutsideAirResetMaximumCoolingSupplyTemperatureType,
    'OutsideAirResetMaximumHeatingSupplyTemperature': OutsideAirResetMaximumHeatingSupplyTemperatureType,
    'OutsideAirResetMinimumCoolingSupplyTemperature': OutsideAirResetMinimumCoolingSupplyTemperatureType,
    'OutsideAirResetMinimumHeatingSupplyTemperature': OutsideAirResetMinimumHeatingSupplyTemperatureType,
    'OutsideAirTemperatureLowerLimitCoolingResetControl': OutsideAirTemperatureLowerLimitCoolingResetControlType,
    'OutsideAirTemperatureLowerLimitHeatingResetControl': OutsideAirTemperatureLowerLimitHeatingResetControlType,
    'OutsideAirTemperatureUpperLimitCoolingResetControl': OutsideAirTemperatureUpperLimitCoolingResetControlType,
    'OutsideAirTemperatureUpperLimitHeatingResetControl': OutsideAirTemperatureUpperLimitHeatingResetControlType,
    'OverhangHeightAboveWindow': OverhangHeightAboveWindowType,
    'OverhangProjection': OverhangProjectionType,
    'PV': PVType,
    'PackageFirstCost': PackageFirstCostType,
    'PackageOfMeasures': PackageOfMeasuresType,
    'ParasiticFuelConsumptionRate': ParasiticFuelConsumptionRateType,
    'PartLoadRatioBelowWhichHotGasBypassOperates': PartLoadRatioBelowWhichHotGasBypassOperatesType,
    'PartialOperationPercentage': PartialOperationPercentageType,
    'PercentGuaranteedSavings': PercentGuaranteedSavingsType,
    'PercentOccupiedByOwner': PercentOccupiedByOwnerType,
    'PercentOfWindowAreaShaded': PercentOfWindowAreaShadedType,
    'PercentPremisesServed': PercentPremisesServedType,
    'PercentSkylightArea': PercentSkylightAreaType,
    'PercentageOfCommonSpace': PercentageOfCommonSpaceType,
    'Perimeter': PerimeterType,
    'PerimeterZoneDepth': PerimeterZoneDepthType,
    'PhotovoltaicModuleLength': PhotovoltaicModuleLengthType,
    'PhotovoltaicModuleRatedPower': PhotovoltaicModuleRatedPowerType,
    'PhotovoltaicModuleWidth': PhotovoltaicModuleWidthType,
    'PhotovoltaicSystemArrayAzimuth': PhotovoltaicSystemArrayAzimuthType,
    'PhotovoltaicSystemInverterEfficiency': PhotovoltaicSystemInverterEfficiencyType,
    'PhotovoltaicSystemMaximumPowerOutput': PhotovoltaicSystemMaximumPowerOutputType,
    'PhotovoltaicSystemNumberOfArrays': PhotovoltaicSystemNumberOfArraysType,
    'PhotovoltaicSystemNumberOfModulesPerArray': PhotovoltaicSystemNumberOfModulesPerArrayType,
    'PhotovoltaicSystemRackingSystemTiltAngleMax': PhotovoltaicSystemRackingSystemTiltAngleMaxType,
    'PhotovoltaicSystemRackingSystemTiltAngleMin': PhotovoltaicSystemRackingSystemTiltAngleMinType,
    'PipeInsulationThickness': PipeInsulationThicknessType172,
    'PipeLocation': PipeLocationType173,
    'Plants': PlantsType,
    'PlugLoad': PlugLoadType,
    'PlugLoadNominalPower': PlugLoadNominalPowerType,
    'PlugLoadPeakPower': PlugLoadPeakPowerType,
    'PlugLoadReductions': PlugLoadReductionsType,
    'PlugLoadStandbyPower': PlugLoadStandbyPowerType,
    'PlugLoads': PlugLoadsType,
    'Pool': PoolType,
    'PoolArea': PoolAreaType,
    'PoolVolume': PoolVolumeType,
    'Pools': PoolsType,
    'PortfolioManager': PortfolioManagerType,
    'PremisesAffected': PremisesAffectedType,
    'ProcessLoad': ProcessLoadType,
    'ProcessLoadPeakPower': ProcessLoadPeakPowerType,
    'ProcessLoadStandbyPower': ProcessLoadStandbyPowerType,
    'ProcessLoads': ProcessLoadsType,
    'ProjectMarkup': ProjectMarkupType,
    'PumpDutyCycle': PumpDutyCycleType,
    'PumpEfficiency': PumpEfficiencyType,
    'PumpInstalledFlowRate': PumpInstalledFlowRateType,
    'PumpMaximumFlowRate': PumpMaximumFlowRateType,
    'PumpMinimumFlowRate': PumpMinimumFlowRateType,
    'PumpPowerDemand': PumpPowerDemandType,
    'PumpSystem': PumpSystemType,
    'PumpSystems': PumpSystemsType,
    'Qualifications': QualificationsType,
    'QuantityOfLaundry': QuantityOfLaundryType,
    'Radiant': RadiantType133,
    'Ranking': RankingType,
    'Rankings': RankingsType,
    'RatePeriod': RatePeriodType47,
    'RateSchedule': RateScheduleType,
    'RateTier': RateTierType,
    'RatedCoolingSensibleHeatRatio': RatedCoolingSensibleHeatRatioType146,
    'RatedHeatPumpSensibleHeatRatio': RatedHeatPumpSensibleHeatRatioType,
    'RatedLampLife': RatedLampLifeType,
    'ReactivePowerCharge': ReactivePowerChargeType,
    'Recirculation': RecirculationType,
    'RecirculationEnergyLossRate': RecirculationEnergyLossRateType,
    'RecirculationFlowRate': RecirculationFlowRateType,
    'RecirculationLoopCount': RecirculationLoopCountType,
    'RecoveryEfficiency': RecoveryEfficiencyType,
    'RecurringIncentives': RecurringIncentivesType,
    'RefrigerantChargeFactor': RefrigerantChargeFactorType141,
    'Refrigeration': RefrigerationType,
    'RefrigerationCompressor': RefrigerationCompressorType175,
    'RefrigerationEnergy': RefrigerationEnergyType,
    'RefrigerationSystem': RefrigerationSystemType,
    'RefrigerationSystemCategory': RefrigerationSystemCategoryType,
    'RefrigerationSystems': RefrigerationSystemsType,
    'RefrigerationUnit': RefrigerationUnitType178,
    'RefrigerationUnitSize': RefrigerationUnitSizeType,
    'Removal': RemovalType,
    'RenewableEnergySystems': RenewableEnergySystemsType,
    'Replacement': ReplacementType,
    'Report': ReportType,
    'RequiredVentilationRate': RequiredVentilationRateType161,
    'ResidualValue': ResidualValueType,
    'ResourceUse': ResourceUseType,
    'ResourceUseID': ResourceUseIDType,
    'ResourceUses': ResourceUsesType,
    'ReturnDuctPercentConditionedSpace': ReturnDuctPercentConditionedSpaceType,
    'RoofArea': RoofAreaType,
    'RoofCeilingSystem': RoofCeilingSystemType,
    'RoofCeilingSystems': RoofCeilingSystemsType,
    'RoofExteriorSolarAbsorptance': RoofExteriorSolarAbsorptanceType,
    'RoofExteriorThermalAbsorptance': RoofExteriorThermalAbsorptanceType,
    'RoofFramingDepth': RoofFramingDepthType,
    'RoofFramingFactor': RoofFramingFactorType,
    'RoofFramingSpacing': RoofFramingSpacingType,
    'RoofID': RoofIDType,
    'RoofInsulatedArea': RoofInsulatedAreaType,
    'RoofInsulation': RoofInsulationType,
    'RoofInsulationThickness': RoofInsulationThicknessType,
    'RoofRValue': RoofRValueType,
    'RoofUFactor': RoofUFactorType,
    'Scenario': ScenarioType,
    'ScenarioType': ScenarioTypeType,
    'Scenarios': ScenariosType,
    'Schedule': ScheduleType,
    'ScheduleDetails': ScheduleDetailsType,
    'Schedules': SchedulesType,
    'Score': ScoreType,
    'SetbackTemperatureHeating': SetbackTemperatureHeatingType,
    'SetpointTemperatureCooling': SetpointTemperatureCoolingType,
    'SetpointTemperatureHeating': SetpointTemperatureHeatingType,
    'SetupTemperatureCooling': SetupTemperatureCoolingType,
    'Side': SideType,
    'SideA1Orientation': SideA1OrientationType,
    'SideLength': SideLengthType,
    'Sides': SidesType,
    'SimplePayback': SimplePaybackType100,
    'Simplified': SimplifiedType,
    'Simulated': SimulatedType,
    'Site': SiteType,
    'SiteEnergyUse': SiteEnergyUseType208,
    'SiteEnergyUseIntensity': SiteEnergyUseIntensityType,
    'Sites': SitesType,
    'Skylight': SkylightType,
    'SkylightID': SkylightIDType,
    'SkylightPitch': SkylightPitchType,
    'SlabArea': SlabAreaType192,
    'SlabExposedPerimeter': SlabExposedPerimeterType194,
    'SlabInsulationThickness': SlabInsulationThicknessType195,
    'SlabOnGrade': SlabOnGradeType,
    'SlabPerimeter': SlabPerimeterType193,
    'Solar': SolarType,
    'SolarHeatGainCoefficient': SolarHeatGainCoefficientType,
    'SolarThermal': SolarThermalType,
    'SolarThermalSystemCollectorArea': SolarThermalSystemCollectorAreaType,
    'SolarThermalSystemCollectorAzimuth': SolarThermalSystemCollectorAzimuthType,
    'SolarThermalSystemCollectorTilt': SolarThermalSystemCollectorTiltType,
    'SolarThermalSystemStorageVolume': SolarThermalSystemStorageVolumeType,
    'SolidStateLighting': SolidStateLightingType,
    'SourceEnergyUse': SourceEnergyUseType209,
    'SourceEnergyUseIntensity': SourceEnergyUseIntensityType210,
    'SourceHeatingPlantID': SourceHeatingPlantIDType,
    'SourceSiteRatio': SourceSiteRatioType,
    'Space': SpaceType,
    'SpaceHeatingSystem': SpaceHeatingSystemType,
    'SpaceID': SpaceIDType14,
    'SpatialUnits': SpatialUnitsType,
    'SpotExhaust': SpotExhaustType,
    'StandardPractice': StandardPracticeType,
    'StaticPressureInstalled': StaticPressureInstalledType,
    'SteamBoilerMaximumOperatingPressure': SteamBoilerMaximumOperatingPressureType111,
    'SteamBoilerMinimumOperatingPressure': SteamBoilerMinimumOperatingPressureType110,
    'Storage': StorageType,
    'StorageTank': StorageTankType,
    'StorageTankInsulationRValue': StorageTankInsulationRValueType,
    'StorageTankInsulationThickness': StorageTankInsulationThicknessType,
    'StreetAddressDetail': StreetAddressDetailType,
    'StreetNumberNumeric': StreetNumberNumericType,
    'Subsection': SubsectionType,
    'Subsections': SubsectionsType,
    'SuctionVaporTemperature': SuctionVaporTemperatureType,
    'SummerPeak': SummerPeakType,
    'SummerPeakElectricityReduction': SummerPeakElectricityReductionType91,
    'SupplyDuctPercentConditionedSpace': SupplyDuctPercentConditionedSpaceType,
    'SupplyFractionOfDuctLeakage': SupplyFractionOfDuctLeakageType,
    'SystemIDProvidingHeat': SystemIDProvidingHeatType,
    'SystemIDReceivingHeat': SystemIDReceivingHeatType,
    'Systems': SystemsType1,
    'TankHeatingType': TankHeatingTypeType,
    'TankHeight': TankHeightType,
    'TankPerimeter': TankPerimeterType,
    'TankVolume': TankVolumeType,
    'Target': TargetType,
    'TechnologyCategory': TechnologyCategoryType,
    'ThermalEfficiency': ThermalEfficiencyType118,
    'TieredRate': TieredRateType,
    'TimeOfUsePeriod': TimeOfUsePeriodType,
    'TimeOfUseRate': TimeOfUseRateType,
    'TimeSeries': TimeSeriesType,
    'TimeSeriesData': TimeSeriesDataType,
    'TotalHeatRejection': TotalHeatRejectionType,
    'True': TrueType197,
    'Type': TypeType,
    'TypeOfMeasure': TypeOfMeasureType,
    'TypeOfRateStructure': TypeOfRateStructureType,
    'Uncategorized': UncategorizedType,
    'UnitDensity': UnitDensityType,
    'Unvented': UnventedType,
    'UseType': UseTypeType,
    'UsefulLife': UsefulLifeType,
    'UserDefinedField': UserDefinedFieldType,
    'Utility': UtilityType,
    'UtilityBills': UtilityBillsType,
    'Vented': VentedType,
    'VentilationRate': VentilationRateType160,
    'VerticalFinDepth': VerticalFinDepthType,
    'VisibleTransmittance': VisibleTransmittanceType,
    'WallArea': WallAreaType,
    'WallExteriorSolarAbsorptance': WallExteriorSolarAbsorptanceType,
    'WallExteriorThermalAbsorptance': WallExteriorThermalAbsorptanceType,
    'WallFramingDepth': WallFramingDepthType,
    'WallFramingFactor': WallFramingFactorType,
    'WallFramingSpacing': WallFramingSpacingType,
    'WallID': WallIDType,
    'WallInsulation': WallInsulationType,
    'WallInsulationThickness': WallInsulationThicknessType,
    'WallRValue': WallRValueType,
    'WallSystem': WallSystemType,
    'WallSystems': WallSystemsType,
    'WallUFactor': WallUFactorType,
    'Washer': WasherType,
    'WasteWaterVolume': WasteWaterVolumeType,
    'WaterAndSewerConservationSystems': WaterAndSewerConservationSystemsType,
    'WaterCooled': WaterCooledType,
    'WaterCost': WaterCostType,
    'WaterFixtureCyclesPerDay': WaterFixtureCyclesPerDayType,
    'WaterFixtureFractionHotWater': WaterFixtureFractionHotWaterType,
    'WaterFixtureRatedFlowRate': WaterFixtureRatedFlowRateType,
    'WaterFixtureVolumePerCycle': WaterFixtureVolumePerCycleType,
    'WaterHeaterEfficiency': WaterHeaterEfficiencyType174,
    'WaterIntensity': WaterIntensityType,
    'WaterPriceEscalationRate': WaterPriceEscalationRateType,
    'WaterSideEconomizer': WaterSideEconomizerType155,
    'WaterSideEconomizerDBTemperatureMaximum': WaterSideEconomizerDBTemperatureMaximumType158,
    'WaterSideEconomizerTemperatureMaximum': WaterSideEconomizerTemperatureMaximumType157,
    'WaterSideEconomizerTemperatureSetpoint': WaterSideEconomizerTemperatureSetpointType,
    'WaterTemperature': WaterTemperatureType,
    'WaterUse': WaterUseType,
    'WaterUses': WaterUsesType,
    'WeatherDataStationID': WeatherDataStationIDType,
    'WeatherType': WeatherTypeType,
    'WellCount': WellCountType,
    'WholeBuilding': WholeBuildingType,
    'Window': WindowType,
    'WindowHeight': WindowHeightType,
    'WindowHorizontalSpacing': WindowHorizontalSpacingType,
    'WindowID': WindowIDType,
    'WindowSillHeight': WindowSillHeightType,
    'WindowToWallRatio': WindowToWallRatioType,
    'WindowWidth': WindowWidthType,
    'WinterPeak': WinterPeakType,
    'WinterPeakElectricityReduction': WinterPeakElectricityReductionType92,
    'WorkPlaneHeight': WorkPlaneHeightType,
    'XOffset': XOffsetType,
    'YOffset': YOffsetType,
    'ZOffset': ZOffsetType,
    'Zone': ZoneType,
    'ZoneID': ZoneIDType13,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Audits'
        rootClass = Audits
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Audits'
        rootClass = Audits
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Audits'
        rootClass = Audits
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:auc="http://nrel.gov/schemas/bedes-auc/2014"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Audits'
        rootClass = Audits
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from classes import *\n\n')
        sys.stdout.write('import classes as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ASHRAEType",
    "ActualType",
    "AdditionType",
    "Address",
    "AdjustedToYearType",
    "AdvancedMeteringSystemsType",
    "AirCleanerType",
    "AirCooledType",
    "AirInfiltrationValueType",
    "AirSideEconomizerType128",
    "AllResourceTotalType",
    "AllResourceTotalsType",
    "AlternativeSystemAddedType",
    "AlternativeSystemReplacementType",
    "AnalysisPeriodType",
    "AnnualCoolingDegreeDaysType",
    "AnnualCoolingEfficiencyUnits",
    "AnnualCoolingEfficiencyValueType",
    "AnnualCoolingEfficiencyValueType142",
    "AnnualCoolingEfficiencyValueType145",
    "AnnualDemandSavingsCostType",
    "AnnualFuelUseConsistentUnitsType",
    "AnnualFuelUseNativeUnitsType",
    "AnnualHeatingDegreeDaysType",
    "AnnualHeatingEfficiencyUnit",
    "AnnualHeatingEfficiencyValueType",
    "AnnualHeatingEfficiencyValueType107",
    "AnnualHeatingEfficiencyValueType113",
    "AnnualHeatingEfficiencyValueType120",
    "AnnualSavingsByFuelType",
    "AnnualSavingsByFuelType89",
    "AnnualSavingsCostType",
    "AnnualSavingsCostType20",
    "AnnualSavingsCostType31",
    "AnnualSavingsCostType88",
    "AnnualSavingsNativeUnitsType",
    "AnnualSavingsNativeUnitsType90",
    "AnnualSavingsSiteEnergyType",
    "AnnualSavingsSiteEnergyType18",
    "AnnualSavingsSiteEnergyType29",
    "AnnualSavingsSiteEnergyType86",
    "AnnualSavingsSourceEnergyType",
    "AnnualSavingsSourceEnergyType19",
    "AnnualSavingsSourceEnergyType30",
    "AnnualSavingsSourceEnergyType87",
    "AnnualWaterCostSavingsType",
    "AnnualWaterCostSavingsType24",
    "AnnualWaterCostSavingsType35",
    "AnnualWaterCostSavingsType94",
    "AnnualWaterSavingsType",
    "AnnualWaterSavingsType23",
    "AnnualWaterSavingsType34",
    "AnnualWaterSavingsType93",
    "AntiSweatHeaterPowerType",
    "AntiSweatHeatersType",
    "AspectRatioType",
    "AssessmentType",
    "AssetScore",
    "AssetScoreData",
    "AuditCostType",
    "AuditType",
    "AuditorContactIDType",
    "Audits",
    "AverageMarginalCostRateType",
    "AverageMarginalSellRateType",
    "AvoidedEmissionsType",
    "BasementType",
    "BenchmarkType16",
    "BenchmarkTypeType",
    "BlockIDType",
    "BlockType",
    "BlockType200",
    "BoilerEWTType",
    "BoilerInsulationRValueType",
    "BoilerInsulationThicknessType",
    "BoilerLWTType",
    "BoilerLWTType109",
    "BoilerPercentCondensateReturnType",
    "BoilerPlantImprovementsType",
    "BoilerType104",
    "BuildingAmericaType",
    "BuildingAutomationSystemsType",
    "BuildingEnvelopeModificationsType",
    "BurnerTurndownRatioType",
    "BurnerTurndownRatioType116",
    "BurnerType",
    "CBECS",
    "CBECSType",
    "CDDBaseTemperatureType",
    "CDDBaseTemperatureType59",
    "CalculationMethodType",
    "CaliforniaTitle24Type",
    "Capacity",
    "CapacityUnits",
    "CapitalReplacementCostType",
    "CaseReturnLineDiameterType",
    "CeilingVisibleAbsorptanceType",
    "CellCountType",
    "CentralAirDistributionType",
    "CentralRefrigerationSystemType",
    "CertifiedAuditTeamMemberContactIDType",
    "ChilledWaterHotWaterAndSteamDistributionSystemsType",
    "ChilledWaterSupplyTemperatureType",
    "ChilledWaterSupplyTemperatureType147",
    "ChillerPlantImprovementsType",
    "ChillerType137",
    "ClimateZoneTypeType",
    "ClothesWasherCapacityType",
    "ClothesWasherCapacityType184",
    "ClothesWasherClassification",
    "ClothesWasherLoaderType",
    "ClothesWasherModifiedEnergyFactorType",
    "ClothesWasherModifiedEnergyFactorType182",
    "ClothesWasherWaterFactorType",
    "ClothesWasherWaterFactorType183",
    "CodeMinimumType",
    "CombinationType",
    "CombustionEfficiencyType",
    "CombustionEfficiencyType117",
    "CombustionType",
    "CombustionType170",
    "CommercialFacilitiesType",
    "CommercialFacilityType",
    "CompactFluorescentType",
    "ComplexType",
    "CompressorStaging",
    "CompressorUnloaderStagesType",
    "CompressorUnloaderType",
    "CondenserPlantIDType",
    "CondenserPlantIDType140",
    "CondenserPlantIDType177",
    "CondenserPlantType",
    "CondenserWaterTemperatureType",
    "CondenserWaterTemperatureType153",
    "CondensingTemperatureType",
    "CondensingTemperatureType149",
    "CondensingTemperatureType154",
    "CondensingTemperatureType159",
    "ConditionedVolumeType",
    "ConsumptionEnergyTierDesignationType",
    "ContactEmailAddressesType",
    "ContactTelephoneNumbersType",
    "ContactType",
    "ContactsType",
    "ControlTechnology",
    "ConvectionType130",
    "ConveyancePeakPowerType",
    "ConveyanceStandbyPowerType",
    "ConveyanceSystemType",
    "ConveyanceSystemsType",
    "CookingEnergyPerMealType",
    "CookingSystemType",
    "CookingSystemsType",
    "CoolingDegreeDaysType",
    "CoolingDeliveryIDType",
    "CoolingPlantIDType",
    "CoolingPlantTypeType",
    "CoolingSourceIDType",
    "CoolingSourceIDType136",
    "CoolingSourceType125",
    "CoolingSourceTypeType",
    "CoolingStageCapacityType",
    "CoolingStageCapacityType139",
    "CoolingSupplyAirTemperatureType",
    "CostEffectivenessScreeningMethod",
    "CrawlspaceType",
    "CrawlspaceVentingType",
    "CriticalITSystemType",
    "CriticalITSystemsType",
    "CurrentBuildingType",
    "DOEType",
    "DXType",
    "DailyHotWaterDrawType",
    "DailyWaterUseType",
    "DaylightingControlStepsType",
    "DaylightingIlluminanceSetPointType",
    "DehumidifierType",
    "DeliveryIDType",
    "DeliveryType126",
    "DeliveryTypeType",
    "DemandRatchetPercentageType",
    "DemandRatchetPercentageType45",
    "DemandRatchetPercentageType53",
    "DemandRateAdjustmentType",
    "DemandRateAdjustmentType43",
    "DemandRateAdjustmentType51",
    "DemandWindowType",
    "DemandWindowType44",
    "DemandWindowType52",
    "DesignAmbientTemperatureType",
    "DesignStaticPressureType",
    "DesignTemperatureDifferenceType",
    "DimmingCapabilityType",
    "DirectMeasurement",
    "DirectTankHeatingSourceType",
    "DirectType",
    "DiscountFactorType",
    "DishwasherEnergyFactorType",
    "DishwasherHotWaterUseType",
    "DishwasherLoadsPerWeekType",
    "DishwasherSystemType",
    "DishwasherSystemsType",
    "DistanceBetweenVerticalFinsType",
    "DistributedGenerationType",
    "DistrictChilledWaterType",
    "DistrictHeatingType105",
    "DomesticHotWaterSystemType",
    "DomesticHotWaterSystemsType",
    "DomesticHotWaterTypeType",
    "DoorGlazedAreaFractionType",
    "DoorIDType",
    "DoorType",
    "DraftType",
    "DriveEfficiencyType",
    "DryerElectricEnergyUsePerLoadType",
    "DryerElectricEnergyUsePerLoadType185",
    "DryerGasEnergyUsePerLoadType",
    "DryerGasEnergyUsePerLoadType186",
    "DryerType",
    "DryerType181",
    "DuctInsulationRValueType",
    "DuctPressureTestLeakagePercentageType",
    "DuctPressureTestLeakageRateType",
    "DuctSurfaceAreaType",
    "DuctSystemType",
    "DuctSystemsType",
    "DutyCycle",
    "DutyCycleType",
    "ENERGYSTARScore",
    "EconomizerDryBulbControlPointType",
    "EconomizerEnthalpyControlPointType",
    "EconomizerLowTemperatureLockoutType",
    "ElectricDemandRateType",
    "ElectricDemandRateType41",
    "ElectricDemandRateType49",
    "ElectricMotorsAndDrivesType",
    "ElectricResistance",
    "ElectricalPeakShavingLoadShiftingType",
    "ElectricityPriceEscalationRateType",
    "ElectricitySourcedFromOnsiteRenewableSystemsType",
    "EmissionsFactorType",
    "EmissionsType56",
    "EnergyConversionTypeType",
    "EnergyCostRateType",
    "EnergyCostRateType40",
    "EnergyCostRateType48",
    "EnergyCostReductionThroughRateAdjustmentsType",
    "EnergyCostType",
    "EnergyDistributionSystemsType",
    "EnergyRateAdjustmentType",
    "EnergyRateAdjustmentType42",
    "EnergyRateAdjustmentType50",
    "EnergyRecoveryEfficiencyType",
    "EnergyRelatedProcessImprovementsType",
    "EnergyResource",
    "EnergySellRateType",
    "EnergySellRateType46",
    "EnergySellRateType54",
    "EnergyStarType",
    "EnergyUseByEndUseType",
    "EnergyUseByFuelType",
    "EnergyUseType",
    "EnergyUseType211",
    "EquipmentDisposalAndSalvageCostsType",
    "EquipmentDisposalAndSalvageCostsType96",
    "Estimated",
    "EvaporativeCoolerType",
    "EvaporativelyCooledCondenserMaximumTemperatureType",
    "EvaporativelyCooledCondenserMinimumTemperatureType",
    "EvaporativelyCooledCondenserType",
    "ExistingScheduleAffectedType",
    "ExistingScheduleAffectedType60",
    "ExistingScheduleAffectedType62",
    "ExistingScheduleAffectedType64",
    "ExistingSystemAffectedType",
    "ExistingSystemRemovedType",
    "ExistingSystemReplacedType",
    "FacilityType",
    "False",
    "FanBasedDistributionTypeType",
    "FanBasedType",
    "FanCoilType127",
    "FanEfficiencyType",
    "FanPowerMinimumRatioType",
    "FanSizeType",
    "FanSystemType",
    "FanSystemsType",
    "FederalBuildingType",
    "FederalSustainabilityChecklistCompletionPercentageType",
    "FenestrationAreaType",
    "FenestrationAreaType10",
    "FenestrationRValueType",
    "FenestrationSystemType",
    "FenestrationSystemsType",
    "FenestrationTypeType",
    "FenestrationUFactorType",
    "FixedMonthlyChargeType",
    "FixtureSpacingType",
    "FlatRateType",
    "FloorAreaType206",
    "FloorAreaValueType",
    "FloorAreas",
    "FloorFramingDepthType",
    "FloorFramingFactorType",
    "FloorFramingSpacingType",
    "FloorInsulationThicknessType",
    "FloorRValueType",
    "FloorToCeilingHeightType",
    "FloorToFloorHeightType",
    "FloorUFactorType",
    "FloorsAboveGradeType",
    "FloorsBelowGradeType",
    "FloorsPartiallyBelowGradeType",
    "FluorescentStartType",
    "FoundationAreaType",
    "FoundationHeightAboveGradeType",
    "FoundationHeightAboveGradeType190",
    "FoundationIDType",
    "FoundationSystemType",
    "FoundationSystemsType",
    "FoundationWallInsulationCondition",
    "FoundationWallInsulationContinuity",
    "FoundationWallInsulationThicknessType",
    "FoundationWallInsulationThicknessType191",
    "FoundationWallRValueType",
    "FuelUseIntensityType",
    "FullLoadAmpsType",
    "FundingFromIncentivesType",
    "FundingFromIncentivesType97",
    "FundingFromTaxCreditsType",
    "FundingFromTaxCreditsType98",
    "FurnaceType115",
    "FutureOtherECMsType",
    "GHGEmissionsType",
    "GasPriceEscalationRateType",
    "GenerationType",
    "GlycolCooledDryCoolerType",
    "GroundCouplingType",
    "GroundSourceType152",
    "HDDBaseTemperatureType",
    "HDDBaseTemperatureType58",
    "HPWHMinimumAirTemperatureType",
    "HVACScheduleIDType",
    "HVACSystemType",
    "HVACSystemsType",
    "HalogenType",
    "HealthAndSafetyType",
    "HeatExchanger",
    "HeatGainFractionType",
    "HeatPumpBackupAFUEType",
    "HeatPumpBackupHeatingSwitchoverTemperatureType",
    "HeatPumpType119",
    "HeatPumpType169",
    "HeatRecoveryEfficiencyType",
    "HeatRecoverySystemType",
    "HeatRecoverySystemsType",
    "HeatedType",
    "HeatingAndCoolingSystemsType",
    "HeatingDegreeDaysType",
    "HeatingDeliveryIDType",
    "HeatingPlantIDType",
    "HeatingPlantTypeType",
    "HeatingSourceIDType",
    "HeatingSourceType114",
    "HeatingSourceTypeType",
    "HeatingStageCapacityFractionType",
    "HeatingStageCapacityFractionType124",
    "HeatingStaging",
    "HeatingSupplyAirTemperatureType",
    "HighIntensityDischargeType",
    "HotWaterBoilerMaximumFlowRateType",
    "HotWaterBoilerMaximumFlowRateType108",
    "HotWaterBoilerMinimumFlowRateType",
    "HotWaterSetpointTemperatureType",
    "HoursUncoveredType",
    "HumidifierType",
    "HumidityControlMaximumType",
    "HumidityControlMinimumType",
    "IECCType",
    "ITNominalPowerType",
    "ITPeakPowerType",
    "ITStandbyPowerType",
    "IdentifierLabel",
    "IgnitionType",
    "ImplementationPeriodCostSavingsType",
    "IncandescentType",
    "IndirectTankHeatingSourceType",
    "IndirectType",
    "InductionType",
    "InfiltrationIntrusionType",
    "InflationRateType",
    "InputCapacityType",
    "InputCapacityType121",
    "InstalledFlowRateType",
    "InstalledPowerType",
    "InstantaneousType",
    "InstantaneousWaterHeatingSourceType",
    "InteriorVisibleAbsorptanceType",
    "InternalRateOfReturnType",
    "InternalRateOfReturnType102",
    "InternalRateOfReturnType27",
    "InternalRateOfReturnType38",
    "IntervalReadingType",
    "LampPowerType",
    "LampPowerType179",
    "LampTypeType",
    "LatitudeType",
    "LaundryEquipmentUsageType",
    "LaundrySystemType",
    "LaundrySystemsType",
    "LaundryTypeType",
    "LightShelfDistanceFromTopType",
    "LightShelfExteriorProtrusionType",
    "LightShelfInteriorProtrusionType",
    "LightShelvesType",
    "LightingEfficacyType",
    "LightingImprovementsType",
    "LightingSystemType",
    "LightingSystemsType",
    "LinearFluorescentType",
    "LinkedBlockIDType",
    "LinkedFacilityIDType",
    "LinkedHeatingPlantIDType",
    "LinkedPremises",
    "LinkedScheduleIDType",
    "LinkedScheduleIDType199",
    "LinkedScheduleIDType201",
    "LinkedScheduleIDType203",
    "LinkedScheduleIDType205",
    "LinkedSiteIDType",
    "LinkedSpaceIDType",
    "LinkedSystemIDType",
    "LinkedSystemIDType187",
    "LinkedSystemIDType188",
    "LinkedZoneIDType",
    "Location",
    "LongitudeType",
    "LuminaireHeightType",
    "MVCostType",
    "MVCostType103",
    "MakeupAirSourceIDType",
    "MakeupAirSourceIDType162",
    "MaximumFanPowerType",
    "MaximumOAFlowRateType",
    "MaxkWUsageType",
    "MaxkWhUsageType",
    "MeasureCoverageType",
    "MeasureFirstCostType",
    "MeasureRankType",
    "MeasureSavingsAnalysisType",
    "MeasureType",
    "MeasuredEnergySourceType",
    "MeasuredType",
    "MeasuresIDType",
    "MeasuresType",
    "MechanicalVentilationType",
    "MinimumDimmingLightFractionType",
    "MinimumDimmingPowerFractionType",
    "MinimumFlowRateType",
    "MinimumOutsideAirPercentageType",
    "MinimumPartLoadRatioType",
    "MinimumPartLoadRatioType143",
    "MinimumPowerFactorWithoutPenaltyType",
    "MiscellaneousElectricLoadType",
    "MiscellaneousGasLoadType",
    "ModificationRetrocommissioningType",
    "ModifiedScheduleType",
    "ModifiedScheduleType61",
    "ModifiedScheduleType63",
    "ModifiedScheduleType65",
    "ModifiedSystemType",
    "MotorBrakeHPType",
    "MotorEfficiencyType",
    "MotorHPType",
    "MotorPoleCountType",
    "MotorRPMType",
    "MotorSystemType",
    "MotorSystemsType",
    "NPVofTaxImplicationsType",
    "NPVofTaxImplicationsType99",
    "NaturalVentilationRateType",
    "NaturalVentilationType",
    "Neon",
    "NetMeteringType",
    "NetPresentValueType",
    "NetPresentValueType101",
    "NetPresentValueType26",
    "NetPresentValueType37",
    "NetRefrigerationCapacityType",
    "NoCooling",
    "NoCoolng",
    "NoHeating",
    "NormalizationYearsType",
    "NormalizedType",
    "NumberOfBallastsPerLuminaireType",
    "NumberOfBusinessesType",
    "NumberOfDiscreteCoolingStagesType",
    "NumberOfDiscreteCoolingStagesType138",
    "NumberOfDiscreteFanSpeedsCoolingType",
    "NumberOfDiscreteFanSpeedsHeatingType",
    "NumberOfHeatingStagesType",
    "NumberOfHeatingStagesType123",
    "NumberOfLampsPerBallastType",
    "NumberOfLampsPerLuminaireType",
    "NumberOfLuminairesType",
    "NumberOfMealsType",
    "NumberOfRefrigerantReturnLinesType",
    "NumberOfUnitsType",
    "OMCostAnnualSavingsType",
    "OMCostAnnualSavingsType95",
    "OccupancyClassification",
    "OccupancyLevelType",
    "OccupancyLevels",
    "OccupancyScheduleIDType",
    "OccupantQuantityType207",
    "OffCycleHeatLossCoefficientType",
    "OnSiteGenerationTypeType",
    "OnSiteStorageTransmissionGenerationSystemType",
    "OnSiteStorageTransmissionGenerationSystemsType",
    "OnsiteRenewableSystemElectricityExportedType",
    "Other",
    "OtherCombination",
    "OtherCostAnnualSavingsType",
    "OtherEscalationRatesType",
    "OtherFinancialIncentivesType",
    "OtherHVACSystemType",
    "OtherHVACSystemsType",
    "OtherHVACType68",
    "OtherHVACTypeType",
    "OtherType",
    "OtherType17",
    "OtherType196",
    "OtherType28",
    "OutputCapacityType",
    "OutputCapacityType106",
    "OutputCapacityType112",
    "OutputCapacityType122",
    "OutsideAirResetMaximumCoolingSupplyTemperatureType",
    "OutsideAirResetMaximumHeatingSupplyTemperatureType",
    "OutsideAirResetMinimumCoolingSupplyTemperatureType",
    "OutsideAirResetMinimumHeatingSupplyTemperatureType",
    "OutsideAirTemperatureLowerLimitCoolingResetControlType",
    "OutsideAirTemperatureLowerLimitHeatingResetControlType",
    "OutsideAirTemperatureUpperLimitCoolingResetControlType",
    "OutsideAirTemperatureUpperLimitHeatingResetControlType",
    "OverhangHeightAboveWindowType",
    "OverhangProjectionType",
    "Ownership",
    "OwnershipStatus",
    "PVType",
    "PackageFirstCostType",
    "PackageOfMeasuresType",
    "ParasiticFuelConsumptionRateType",
    "PartLoadRatioBelowWhichHotGasBypassOperatesType",
    "PartialOperationPercentageType",
    "PercentGuaranteedSavingsType",
    "PercentOccupiedByOwnerType",
    "PercentOfWindowAreaShadedType",
    "PercentPremisesServedType",
    "PercentSkylightAreaType",
    "PercentageOfCommonSpaceType",
    "PerimeterType",
    "PerimeterZoneDepthType",
    "Photoluminescent",
    "PhotovoltaicModuleLengthType",
    "PhotovoltaicModuleRatedPowerType",
    "PhotovoltaicModuleWidthType",
    "PhotovoltaicSystemArrayAzimuthType",
    "PhotovoltaicSystemInverterEfficiencyType",
    "PhotovoltaicSystemMaximumPowerOutputType",
    "PhotovoltaicSystemNumberOfArraysType",
    "PhotovoltaicSystemNumberOfModulesPerArrayType",
    "PhotovoltaicSystemRackingSystemTiltAngleMaxType",
    "PhotovoltaicSystemRackingSystemTiltAngleMinType",
    "PipeInsulationThicknessType",
    "PipeInsulationThicknessType131",
    "PipeInsulationThicknessType134",
    "PipeInsulationThicknessType172",
    "PipeLocationType",
    "PipeLocationType132",
    "PipeLocationType135",
    "PipeLocationType173",
    "PlantsType",
    "Plasma",
    "PlugLoadNominalPowerType",
    "PlugLoadPeakPowerType",
    "PlugLoadReductionsType",
    "PlugLoadStandbyPowerType",
    "PlugLoadType",
    "PlugLoadsType",
    "PoolAreaType",
    "PoolType",
    "PoolVolumeType",
    "PoolsType",
    "PortfolioManager",
    "PortfolioManagerType",
    "PremisesAffectedType",
    "PremisesIdentifiers",
    "PrimaryContactID",
    "Priority",
    "ProcessLoadPeakPowerType",
    "ProcessLoadStandbyPowerType",
    "ProcessLoadType",
    "ProcessLoadsType",
    "ProjectMarkupType",
    "PumpDutyCycleType",
    "PumpEfficiencyType",
    "PumpInstalledFlowRateType",
    "PumpMaximumFlowRateType",
    "PumpMinimumFlowRateType",
    "PumpPowerDemandType",
    "PumpSystemType",
    "PumpSystemsType",
    "QualificationsType",
    "Quantity",
    "QuantityOfLaundryType",
    "RadiantType133",
    "RankingType",
    "RankingsType",
    "RatePeriodType",
    "RatePeriodType39",
    "RatePeriodType47",
    "RateScheduleType",
    "RateTierType",
    "RatedCoolingSensibleHeatRatioType",
    "RatedCoolingSensibleHeatRatioType144",
    "RatedCoolingSensibleHeatRatioType146",
    "RatedHeatPumpSensibleHeatRatioType",
    "RatedLampLifeType",
    "ReactivePowerChargeType",
    "RecirculationEnergyLossRateType",
    "RecirculationFlowRateType",
    "RecirculationLoopCountType",
    "RecirculationType",
    "RecoveryEfficiencyType",
    "RecurringIncentivesType",
    "ReferenceCase",
    "Refrigerant",
    "RefrigerantChargeFactorType",
    "RefrigerantChargeFactorType141",
    "RefrigerationCompressorType175",
    "RefrigerationEnergyType",
    "RefrigerationSystemCategoryType",
    "RefrigerationSystemType",
    "RefrigerationSystemsType",
    "RefrigerationType",
    "RefrigerationUnitSizeType",
    "RefrigerationUnitType178",
    "RemovalType",
    "RenewableEnergySystemsType",
    "ReplacementType",
    "ReportType",
    "RequiredVentilationRateType",
    "RequiredVentilationRateType161",
    "ResidualValueType",
    "ResourceBoundary",
    "ResourceUnits",
    "ResourceUseIDType",
    "ResourceUseType",
    "ResourceUsesType",
    "ReturnDuctPercentConditionedSpaceType",
    "RoofAreaType",
    "RoofCeilingSystemType",
    "RoofCeilingSystemsType",
    "RoofExteriorSolarAbsorptanceType",
    "RoofExteriorThermalAbsorptanceType",
    "RoofFramingDepthType",
    "RoofFramingFactorType",
    "RoofFramingSpacingType",
    "RoofIDType",
    "RoofInsulatedAreaType",
    "RoofInsulationThicknessType",
    "RoofInsulationType",
    "RoofRValueType",
    "RoofUFactorType",
    "ScenarioType",
    "ScenarioTypeType",
    "ScenariosType",
    "ScheduleDetailsType",
    "ScheduleType",
    "SchedulesType",
    "ScoreType",
    "SelfLuminous",
    "SetbackTemperatureHeatingType",
    "SetpointTemperatureCoolingType",
    "SetpointTemperatureHeatingType",
    "SetupTemperatureCoolingType",
    "SideA1OrientationType",
    "SideLengthType",
    "SideType",
    "SidesType",
    "SimplePaybackType",
    "SimplePaybackType100",
    "SimplePaybackType25",
    "SimplePaybackType36",
    "SimplifiedType",
    "SimulatedType",
    "SiteEnergyUseIntensityType",
    "SiteEnergyUseType",
    "SiteEnergyUseType208",
    "SiteType",
    "SiteType198",
    "SitesType",
    "SkylightIDType",
    "SkylightPitchType",
    "SkylightType",
    "SlabAreaType",
    "SlabAreaType192",
    "SlabExposedPerimeterType",
    "SlabExposedPerimeterType194",
    "SlabHeating",
    "SlabInsulationCondition",
    "SlabInsulationOrientation",
    "SlabInsulationThicknessType",
    "SlabInsulationThicknessType195",
    "SlabOnGradeType",
    "SlabPerimeterType",
    "SlabPerimeterType193",
    "SolarHeatGainCoefficientType",
    "SolarThermalSystemCollectorAreaType",
    "SolarThermalSystemCollectorAzimuthType",
    "SolarThermalSystemCollectorTiltType",
    "SolarThermalSystemStorageVolumeType",
    "SolarThermalType",
    "SolarType",
    "SolidStateLightingType",
    "SourceEnergyUseIntensityType",
    "SourceEnergyUseIntensityType210",
    "SourceEnergyUseType",
    "SourceEnergyUseType209",
    "SourceHeatingPlantIDType",
    "SourceSiteRatioType",
    "SpaceHeatingSystemType",
    "SpaceIDType",
    "SpaceIDType12",
    "SpaceIDType14",
    "SpaceType",
    "SpaceType204",
    "SpatialUnitsType",
    "SpotExhaustType",
    "StandardPracticeType",
    "StaticPressureInstalledType",
    "SteamBoilerMaximumOperatingPressureType",
    "SteamBoilerMaximumOperatingPressureType111",
    "SteamBoilerMinimumOperatingPressureType",
    "SteamBoilerMinimumOperatingPressureType110",
    "StorageTankInsulationRValueType",
    "StorageTankInsulationThicknessType",
    "StorageTankType",
    "StorageType",
    "StreetAddressDetailType",
    "StreetNumberNumericType",
    "SubsectionType",
    "SubsectionsType",
    "SuctionVaporTemperatureType",
    "SummerPeakElectricityReductionType",
    "SummerPeakElectricityReductionType21",
    "SummerPeakElectricityReductionType32",
    "SummerPeakElectricityReductionType91",
    "SummerPeakType",
    "SupplyDuctPercentConditionedSpaceType",
    "SupplyFractionOfDuctLeakageType",
    "SystemIDProvidingHeatType",
    "SystemIDReceivingHeatType",
    "SystemPerformanceRatio",
    "SystemsType1",
    "TankHeatingTypeType",
    "TankHeightType",
    "TankPerimeterType",
    "TankVolumeType",
    "TargetType",
    "TechnologyCategoryType",
    "TemporalStatus",
    "ThermalEfficiencyType",
    "ThermalEfficiencyType118",
    "ThirdPartyCertification",
    "TieredRateType",
    "TimeOfUsePeriodType",
    "TimeOfUseRateType",
    "TimeSeriesDataType",
    "TimeSeriesType",
    "TotalHeatRejectionType",
    "TrueType",
    "TrueType129",
    "TrueType148",
    "TrueType151",
    "TrueType156",
    "TrueType168",
    "TrueType171",
    "TrueType176",
    "TrueType180",
    "TrueType189",
    "TrueType197",
    "TrueType55",
    "TrueType9",
    "TypeOfMeasureType",
    "TypeOfRateStructureType",
    "TypeType",
    "UncategorizedType",
    "UnitDensityType",
    "Unknown",
    "UnventedType",
    "UseTypeType",
    "UsefulLifeType",
    "UserDefinedFieldType",
    "UserDefinedFields",
    "UtilityBillsType",
    "UtilityType",
    "VentedType",
    "VentilationControlMethod",
    "VentilationRateType",
    "VentilationRateType160",
    "VerticalFinDepthType",
    "VisibleTransmittanceType",
    "WallAreaType",
    "WallExteriorSolarAbsorptanceType",
    "WallExteriorThermalAbsorptanceType",
    "WallFramingDepthType",
    "WallFramingFactorType",
    "WallFramingSpacingType",
    "WallIDType",
    "WallInsulationThicknessType",
    "WallInsulationType",
    "WallRValueType",
    "WallSystemType",
    "WallSystemsType",
    "WallUFactorType",
    "WasherType",
    "WasteWaterVolumeType",
    "WaterAndSewerConservationSystemsType",
    "WaterCooledCondenserFlowControl",
    "WaterCooledType",
    "WaterCostType",
    "WaterFixtureCyclesPerDayType",
    "WaterFixtureFractionHotWaterType",
    "WaterFixtureRatedFlowRateType",
    "WaterFixtureVolumePerCycleType",
    "WaterHeaterEfficiencyType174",
    "WaterIntensityType",
    "WaterPriceEscalationRateType",
    "WaterResource",
    "WaterSideEconomizerDBTemperatureMaximumType",
    "WaterSideEconomizerDBTemperatureMaximumType158",
    "WaterSideEconomizerTemperatureMaximumType",
    "WaterSideEconomizerTemperatureMaximumType157",
    "WaterSideEconomizerTemperatureSetpointType",
    "WaterSideEconomizerType",
    "WaterSideEconomizerType150",
    "WaterSideEconomizerType155",
    "WaterTemperatureType",
    "WaterUseType",
    "WaterUseType57",
    "WaterUsesType",
    "WeatherDataSource",
    "WeatherDataStationIDType",
    "WeatherTypeType",
    "WellCountType",
    "WholeBuildingType",
    "WindowHeightType",
    "WindowHorizontalSpacingType",
    "WindowIDType",
    "WindowSillHeightType",
    "WindowToWallRatioType",
    "WindowType",
    "WindowWidthType",
    "WinterPeakElectricityReductionType",
    "WinterPeakElectricityReductionType22",
    "WinterPeakElectricityReductionType33",
    "WinterPeakElectricityReductionType92",
    "WinterPeakType",
    "WorkPlaneHeightType",
    "XOffsetType",
    "YOffsetType",
    "ZOffsetType",
    "ZoneIDType",
    "ZoneIDType11",
    "ZoneIDType13",
    "ZoneIDType15",
    "ZoneType",
    "ZoneType202"
]
